---
title: CCF201712-4
date: 2020-01-30 23:20:52
tags: 
categories: 算法
---
<meta name="referrer" content="no-referrer" />


# CCF201712-4
==80分 代码==
原因：边权有可能超出int表示范围（第二个为满分代码）
```cpp
#include<iostream>
#include<vector>
#define INF 10000000 
using namespace std;

typedef struct{
	int weight;	//记录权值	 
	int r;	//记录路径当前小路长度 
}edge;
typedef struct{
	int d;
	int t;
}myarray;
int dijistra(vector<vector<myarray> > array,int n){
	vector<int> path(n+1,1);
	vector<edge> dst;
	for(int i=0;i<=n;i++){
		edge t;
		if(array[1][i].t==1){
			t.r = array[1][i].d;
			t.weight = array[1][i].d * array[1][i].d;
		}
		else{
			t.r = 0;
			t.weight = array[1][i].d; 
		}
		dst.push_back(t);
	}
	vector<int> visit(n+1,0);
	visit[1] = 1;
	dst[0].r = 0;
	int cnt =n;
	/*
	cout<<"weight: ";
	for(int i=0;i<=n;i++){
		cout<<dst[i].weight<<" ";
	}
	cout<<endl;
	cout<<"r: "; 
	for(int i=0;i<=n;i++){
		cout<<dst[i].r<<" ";
	}
	cout<<endl;
	cout<<"visit: ";
	for(int i=0;i<=n;i++){
		cout<<visit[i]<<" ";
	}
	cout<<endl;*/
	while(cnt--){
		int min = INF;
		int v = 0; 
		for(int i=1;i<n+1;i++){
			if(!visit[i]&&dst[i].weight<min){
				min = dst[i].weight;
				v = i;
			}
		}
		visit[v] = 1;
		if(v==n) return dst[v].weight;
		edge p = dst[v];		
		for(int i=1;i<n+1;i++){
			if(!visit[i]){
				edge q = dst[i];
				myarray a = array[i][v];
				if(a.t==0){
					if(p.weight+a.d<q.weight){
						dst[i].weight = p.weight+a.d;
						dst[i].r = 0;
					}
	
				}
				else if(a.t==1){
					int add = a.d * a.d + 2 * a.d * p.r;
					if(p.weight+add<q.weight){
						dst[i].weight = p.weight+add;
						dst[i].r += a.d;
					}
				}
			}
			
		}
		/*
		cout<<cnt<<"次"<<endl;
		cout<<"weight: ";
		for(int i=0;i<=n;i++){
			cout<<dst[i].weight<<" ";
		}
		cout<<endl;
		cout<<"r: ";
		for(int i=0;i<=n;i++){
			cout<<dst[i].r<<" ";
		}
		cout<<endl;
		cout<<"visit: ";
		for(int i=0;i<=n;i++){
			cout<<visit[i]<<" ";
		}
		cout<<endl;
		*/
	}
	return 0;
}
void func(){
	int m,n;
	cin>>n>>m;
	myarray test;
	test.d = INF;
	test.t = -1;
	vector<vector<myarray> > array(n+1,vector<myarray>(n+1));
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			array[i][j] = test; 
		}
	}
	for(int i=0;i<m;i++){
		int t,a,b,c;
		cin>>t>>a>>b>>c;
		array[a][b].d = c;
		array[a][b].t = t;
		array[b][a].d = c;
		array[b][a].t = t;
	}
	int ans = dijistra(array,n);
	cout<<ans;
}
int main(){
	func();
	return 0;
}
 

```
==满分代码==
```cpp
#include<iostream>
#include<vector>
using namespace std;

//-2147483648-2147483647
const int INF = 1 << 30;
const int maxn = 501;
typedef long long ll;
typedef struct {
	int type;		//0或1
	ll len;		//道路长度
	int to;			//路径顶点
}Edge;

vector<vector<Edge> > load(maxn);
ll d[maxn];
ll small[maxn];
bool visit[maxn];

void dijistra(int n) {
	for (int i = 1;i <= n;i++) {
		d[i] = INF;
		visit[i] = false;
		small[i] = 0;
	}
	d[1] = 0;
	d[0] = INF + 1;
	while (true) {
		int v = 0;
		for (int i = 1;i <= n;i++) {
			if ((d[i] < d[v])&&(!visit[i])) {
				v = i;
			}
		}
		if (v == n) {
			cout << d[n];
			return;
		}
		visit[v] = true;
		for (int u = 0;u < load[v].size();u++) {
			int to = load[v][u].to;
			if (load[v][u].type == 0) {
				if (d[v] + load[v][u].len <= d[to]) {
					small[to] = 0;
					d[to] = d[v] + load[v][u].len;
				}
			}
			else {
				ll len = d[v] + load[v][u].len * load[v][u].len + 2 * load[v][u].len * small[v];
				if (len < d[to]) {
					d[to] = len;
					small[to] = small[v] + load[v][u].len;
				}
			}
		}
	}
}

int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 0;i < m;i++) {
		Edge tmp;
		int t, a, b, c;
		cin >> t >> a >> b >> c;
		tmp.type = t;
		tmp.len = c;
		tmp.to = a;
		load[b].push_back(tmp);
		tmp.to = b;
		load[a].push_back(tmp);
	}
	dijistra(n);
	return 0;
}

```
该题为dijistra算法的应用，只需要将经典dijistra算法中边的放缩根据题目题目做出稍微的修改

邻接链表的使用
=
```cpp
vector<vector<Edge> > load(maxn);
for (int i = 0;i < m;i++) {
		Edge tmp;
		int t, a, b, c;
		cin >> t >> a >> b >> c;
		tmp.type = t;
		tmp.len = c;
		tmp.to = a;
		load[b].push_back(tmp);
		tmp.to = b;
		load[a].push_back(tmp);
}
for (int u = 0;u < load[v].size();u++) 
```
int的表示范围为

==-2147483648-2147483647==
-2的31次方到2的31次方
