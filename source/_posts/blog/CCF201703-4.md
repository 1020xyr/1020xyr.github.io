---
title: CCF201703-4
date: 2020-02-02 10:27:04
tags: 
categories: 算法
---
<meta name="referrer" content="no-referrer" />


# CCF201703-4 
==未优化的dijistra算法（80分 运行超时）==
```cpp
#include<iostream>
#include<vector>
using namespace std;

typedef long long ll;
const ll INF = 1 << 30;
typedef struct {
	ll len;
	int to;
}Edge;
ll max(ll a, ll b) {
	if (a > b) {
		return a;
	}
	return b;
}
int main() {
	int n, m;
	cin >> n >> m;
	vector<vector<Edge> >load(n+1);
	ll d[n + 1];
	bool visit[n + 1];
	for (int i = 0;i < m;i++) {
		Edge tmp;
		int a, b, c;
		cin >> a >> b >> c;
		tmp.len = c;
		tmp.to = a;
		load[b].push_back(tmp);
		tmp.to = b;
		load[a].push_back(tmp);
	}
	for (int i = 1;i <= n;i++) {
		d[i] = INF;
		visit[i] = false;
	}
	d[1] = 0;
	d[0] = INF + 1;
	while (true) {
		int v = 0;
		for (int u = 1;u <= n;u++) {
			if ((!visit[u]) && d[u] < d[v]) {
				v = u;
			}
		}

		if (v == n) {
			cout << d[n] << endl;
			return 0;
		}
		visit[v] = true;
		for (int u = 0;u < load[v].size();u++) {
			int to = load[v][u].to;
			ll len = max(d[v], load[v][u].len);
			if (len < d[to]) {
				d[to] = len;
			}
		}
	}
}
```
==用优先队列实现的dijistra算法==

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

typedef long long ll;
const ll INF = 1 << 30;
typedef struct {
	ll len;
	int to;
}Edge;
struct Node{
	ll dist;
	int u;
	Node(ll D,int U):dist(D),u(U){}
	bool operator < (const Node& n) const{
		return dist > n.dist;
	}
};
ll max(ll a, ll b) {
	if (a > b) {
		return a;
	}
	return b;
}
int main() {
	int n, m;
	cin >> n >> m;
	vector<vector<Edge> >load(n + 1);
	ll d[n + 1];
	bool visit[n + 1];
	for (int i = 0;i < m;i++) {
		Edge tmp;
		int a, b, c;
		cin >> a >> b >> c;
		tmp.len = c;
		tmp.to = a;
		load[b].push_back(tmp);
		tmp.to = b;
		load[a].push_back(tmp);
	}
	for (int i = 1;i <= n;i++) {
		d[i] = INF;
		visit[i] = false;
	}
	d[1] = 0;
	priority_queue<Node> q;
	q.push(Node(d[1], 1));

	while (true) {
		Node x = q.top();
		q.pop();
		int v = x.u;
		if (v == n) {
			cout << d[n] << endl;
			return 0;
		}
		if (visit[v]) continue;
		visit[v] = true;
		for (int u = 0;u < load[v].size();u++) {
			int to = load[v][u].to;
			ll len = max(d[v], load[v][u].len);
			if (len < d[to]) {
				d[to] = len;
				q.push(Node(d[to], to));
			}
		}
	}
}
	

```
优先队列的使用

```cpp
struct Node{
	ll dist;
	int u;
	Node(ll D,int U):dist(D),u(U){}
	bool operator < (const Node& n) const{
		return dist > n.dist;
	}
};
priority_queue<Node> q;
q.push(Node(d[1], 1));
while (true) {
	Node x = q.top();
	q.pop();
	int v = x.u;
	if (v == n) {
		cout << d[n] << endl;
		return 0;
	}
	if (visit[v]) continue;
	visit[v] = true;
	for (int u = 0;u < load[v].size();u++) {
		int to = load[v][u].to;
		ll len = max(d[v], load[v][u].len);
		if (len < d[to]) {
			d[to] = len;
			q.push(Node(d[to], to));
		}
	}
}
```

