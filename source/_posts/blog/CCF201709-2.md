---
title: CCF201709-2
date: 2020-01-30 23:23:30
tags: 
categories: 算法
---
<meta name="referrer" content="no-referrer" />


# CCF201709-2

```cpp
#include<iostream>
#include <algorithm>
using namespace std;
typedef struct {
	int time;
	int num_key;
	bool is_up;
}teacher;
int* init_key(int n) {
	int* keys = new int[n];
	for (int i = 0;i < n;i++)
		keys[i] = i + 1;
	return keys;
}
teacher* init_teacher(int k) {
	teacher* t = new teacher[2 * k];
	int num = 0;
	int num_key, uptime, times;
	for (int i = 0;i < k;i++) {
		cin >> num_key >> uptime >> times;
		t[num] = { uptime ,num_key , true };
		t[num + 1] = { uptime + times ,num_key , false };
		num = num + 2;
	}
	return t;
}
void swap(teacher& x, teacher& y) {
	teacher tmp;
	tmp = x;
	x = y;
	y = tmp;
}
bool compare(teacher x, teacher y) {
	if (x.time >= y.time) {
		if (x.time > y.time) {
			return false;
		}
		else if (x.time == y.time) {
			if (x.is_up != y.is_up) {
				if (x.is_up) {
					return false;
				}
			}
			else if (x.num_key > y.num_key&& x.is_up == false) {
				return false;
			}
		}
	}
	return true;
}
void sort(teacher*& t, int k) {
	sort(t, t + 2 * k, compare);
}

void up(teacher t, int*& keys,int n) {
	for (int i = 0;i < n;i++) {
		if (t.num_key == keys[i]) {
			keys[i] = 0;
			break;
		}
	}
}
void down(teacher t, int*& keys, int n) {
	for (int i = 0;i < n;i++) {
		if (keys[i] == 0) {
			keys[i] = t.num_key;
			break;
		}
	}
}
void func(int*& keys, teacher* t,int k,int n) {
	for (int i = 0;i < 2 *k;i++) {
		if (t[i].is_up) {
			up(t[i], keys, n);
		}
		else {
			down(t[i], keys, n);
		}
	}
}
void Print(int*& keys, int n) {
	for (int i = 0;i < n;i++) {
		cout << keys[i] << ' ';
	}
}
int main() {
	int n, k;
	cin >> n >> k;
	int* array = init_key(n);
	teacher* t = init_teacher(k);
	sort(t, k);
	func(array, t, k, n);
	Print(array, n);
	return 0;
}

```

