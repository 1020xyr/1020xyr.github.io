---
title: CCF201903-2
date: 2019-11-25 20:56:58
tags: ccf201903-2
categories: 算法
---
<meta name="referrer" content="no-referrer" />


## CCF201903-2
[题目](https://blog.csdn.net/tigerisland45/article/details/99167285)
评测100分代码
```cpp
#include<iostream>
#include<string>
using namespace std;
void print_ans(int* ans){
	for(int i=0;i<4;i++){
		cout<<ans[i]<<" ";
	}
	cout<<endl;
}
int* find(int j,int* ans){		//找出操作符前后两个操作数 
	int * res = new int[2];
	int p,q;
	p = j / 2;
	while(ans[p]==-100000){
		p--;
	}
	q = j / 2 + 1;
	while(ans[q]==-100000){
		q++;
	}
	res[0] = p;
	res[1] = q;
	return res; 
}
void fun(){
	int n;
	cin>>n;
	char tmp = getchar();
	int ans[4];
	for(int i=0;i<n;i++){	
		string in;
		cin>>in;
		for(int i=0;i<4;i++){			//提取操作数 
			ans[i] = in[2*i] - '0';
		}
		for(int i=0;i<7;i++){
			if(in[i] == 'x'){
				int* res = find(i,ans);
				int p =res[0];
				int q = res[1];
				ans[p] = ans[p] * ans [q];			//将结果保存在第一个操作数中，标记第二个操作数 
				ans[q] = -100000;
				in[i] = 'q';						//标记操作符 
			}
			if(in[i] == '/'){
				int* res = find(i,ans);
				int p =res[0];
				int q = res[1];
				ans[p] = ans[p] / ans [q];
				ans[q] = -100000;
				in[i] = 'q';
			}
		}
		for(int i=0;i<7;i++){
			if(in[i] == '+'){
				int* res = find(i,ans);
				int p =res[0];
				int q = res[1];
				ans[p] = ans[p] + ans [q];
				ans[q] = -100000;
				in[i] = 'q';
	
			}
			if(in[i] == '-'){
				int* res = find(i,ans);
				int p =res[0];
				int q = res[1];
				ans[p] = ans[p] - ans [q];
				ans[q] = -100000;
				in[i] = 'q';
			}
		}
		for(int i=0;i<4;i++){
			if(ans[i]!=-100000){		//找出最终结果 
				if(ans[i]==24)
					cout<<"Yes"<<endl;
				else
					cout<<"No"<<endl;
			}
		}
	}
		
}
int main(){
	fun();
}
/*
10
9+3+4x3
5+4x5x5
7-9-9+8
5x6/5x4
3+5+7+9
1x1+9-9
1x9-5/9
8/5+6x9
6x7-3x6
6x4+4x5
*/
```

