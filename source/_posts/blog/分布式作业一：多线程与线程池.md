---
title: 分布式作业一：多线程与线程池
date: 2020-03-14 21:56:13
tags: 
categories: 分布式作业
---
<meta name="referrer" content="no-referrer" />




## 多线程
### 题目
将基于TCP协议的Client-Sever通信程序示例的服务端程序改造成多线程版
### 源码
整理后

```java
// 服务端程序
import java.io.*;
import java.net.*;

// 通过扩展Thread类来创建多线程
class MyThread extends Thread {
    private Socket clientSocket;

    MyThread(Socket client) {
        clientSocket = client;
    }

    public void run()  {
        try {
            InputStream inStream = clientSocket.getInputStream();
            OutputStream outStream = clientSocket.getOutputStream();
            /*
             InputStream：以字节为单位 InputStreamReader：以字符为单位
             BufferedReader： 以行为为单位进行处理（\r \r\n)

               */
            BufferedReader in = new BufferedReader(new InputStreamReader(inStream));
            PrintWriter out = new PrintWriter(outStream);

            String line = null;
            while ((line = in.readLine()) != null) {
                System.out.println("Thread Number:"+ this.getName());
                System.out.println("Message from this client:" + line);
                out.println(line);
                out.flush();
            }
        }catch (Exception e) {
            System.out.println("Exception");
            return;
        }
        finally {
            try {
                clientSocket.close();
            }
            catch (Exception e){
                e.printStackTrace();
                return;
            }
        }
    }
}

public class Server {
    public static void main(String[] args) throws Exception  {
        // ClientSocket 为通信socket
        Socket clientSocket = null;
        // 监听8189端口 ServerSocket为监听socket
        ServerSocket listenSocket = new ServerSocket(8189);

        System.out.println("Server listening at 8189");
        while(true) {
            // 从连接队列中取出通信socket
            clientSocket = listenSocket.accept();
            System.out.println("Accepted connection from client");
            // 创建新线程并执行线程函数
            MyThread t = new MyThread(clientSocket);
            t.start();
        }
    }
}



```

```java
// 客户端程序
import java.io.*;
import java.net.*;

public class Client {

    public static void main(String[] args) throws Exception {

        String userInput = null;
        String echoMessage = null;

        BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));

        // 创建通信socket，连接服务端程序
        Socket socket = new Socket("127.0.0.1", 8189);
        System.out.println("Connected to Server");

        InputStream inStream = socket.getInputStream();
        OutputStream outStream = socket.getOutputStream();
        BufferedReader in = new BufferedReader(new InputStreamReader(inStream));
        PrintWriter out = new PrintWriter(outStream);


        while(!(userInput=stdIn.readLine()).equals("quit"))
        {
            out.println(userInput);
            out.flush();
            echoMessage = in.readLine();
            System.out.println("Echo from server: " + echoMessage);
        }

        socket.close();

    }
}
```
## 线程池
### 题目
将基于TCP协议的Client-Sever通信程序示例的服务端程序改造成线程池版

### 源码

```java
// 服务端程序 
// 客户端程序与多线程版客户端程序一样
import java.io.*;
import java.net.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

// 通过实现Runnable接口来创建多线程
class MyThread implements Runnable{
    private Socket clientSocket;

    MyThread(Socket client) {
        clientSocket = client;
    }

    public void run()  {
        try {
            InputStream inStream = clientSocket.getInputStream();
            OutputStream outStream = clientSocket.getOutputStream();
            BufferedReader in = new BufferedReader(new InputStreamReader(inStream));
            PrintWriter out = new PrintWriter(outStream);

            String line = null;
            while ((line = in.readLine()) != null) {
                System.out.println("Message from this client:" + line);
                out.println(line);
                out.flush();
            }
        }catch (Exception e) {
            System.out.println("Exception");
            return;
        }
        finally {
            try {
                clientSocket.close();
            }
            catch (Exception e){
                e.printStackTrace();
                return;
            }
        }
    }
}

public class Server {
    public static void main(String[] args) throws Exception  {
        Socket clientSocket = null;
        ServerSocket listenSocket = new ServerSocket(8189);
        /*
            创建ThreadPoolExecutor
            参数意义：
                corePoolSize：线程池初始线程数目 6
                maximumPoolSize：线程池最大允许线程数目 12
                keepAliveTime：线程持续时间 100ms
                capacity：等待队列长度 10
                只有在线程数超过初始线程数目并且等待队列满的情况下才会继续创建新线程

         */
        ThreadPoolExecutor executor = new ThreadPoolExecutor(6,12,100, TimeUnit.MILLISECONDS,new ArrayBlockingQueue<Runnable>(10));
        System.out.println("Server listening at 8189");
        while(true) {
            clientSocket = listenSocket.accept();
            System.out.println("Accepted connection from client");
            MyThread t = new MyThread(clientSocket);
            // 执行线程函数
            executor.execute(t);
        }
    }
}



```

