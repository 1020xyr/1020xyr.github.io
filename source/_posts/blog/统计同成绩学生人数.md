---
title: 统计同成绩学生人数
date: 2020-02-04 20:09:23
tags: 
categories: 算法
---
<meta name="referrer" content="no-referrer" />


# 统计同成绩学生人数

```cpp
cin>>n;
while(n!=0){
	cin>>n;
} 
```
改成
```cpp
while(cin>>n){
	if(n==0) break;
}

while (scanf ("%d",&n) != EOF && n != 0)

==while (cin>>n && n != 0)==
```
## 解释
cin cout 返回值的解释
 1.cin和cout是iostream类的2个对象,而对象是无所谓返回值的.有返回值的是<<还有>>这2个操作符.由于我们知道,==操作符其实也就是函数==(在操作符重载的时候可以清晰的认识到).而>>操作符返回的是它的左操作数(left-operand).对于cin>>value;返回左操作数就是操作的流的引用,也就是istream&.

2.但是好像还是不对,因为while里面判断的是bool值,难道还能判断istream&吗?

打开<ISTREAM>头文件，找到类模板basic_istream的定义，摘出这么两个语来：

```cpp
 typedef basic_istream<_E, _Tr> _Myt;

   _Myt& operator>>(......) ......
```

   这说明cin >>的返回值类型就是basic_istream&，可是放到while()中情况又该是怎样的。while()中要求是布尔表达式，难不成basic_istream&类型可以转换成bool类型？继续查看头文件，发现所有的operator重载函数都是<<和>>，没有找到用于类型转换的操作那就只好追溯到父类basic_ios了。

   打开头文件<IOS.H>，找到ios的定义，其中有这么一条语句，类型转换函数的定义：

```cpp
 operator void *() const { 
 	if(state&(badbit|failbit) ) return 0; 
 	return (void this; 
 }

```

有这个函数的定义之后，编译器会在需要的情况下将ios类型自动转换为void*类型。因此，在表达式while (cin >> m >> n)中，括号中的表达式为了匹配bool类型将自动转换为void*类型。如果读入时发生错误返回0，否则返回cin的地址。


```cpp
#include<iostream>
#include<vector>

using namespace std;
int main(){
	int n;
	int grade;
	int res;
	while(cin>>n){
		if(n==0) break;
		vector<int> a(101,0);
		for(int i =0;i<n;i++){
			cin>>grade;
			a[grade]++;
		}
		cin>>res;
		cout<<a[res]<<endl;
	}
	return 0;
} 
```
