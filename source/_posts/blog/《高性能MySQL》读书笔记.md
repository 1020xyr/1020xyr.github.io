---
title: 《高性能MySQL》读书笔记
date: 2023-04-30 22:39:34
tags: mysql 数据库
categories: 学习记录
index_img: https://img-blog.csdnimg.cn/1635e52860574ef9808e971e43df1455.jpeg
---
<meta name="referrer" content="no-referrer" />



把目录全写出来只是单纯为了激励自己，不知道啥时候能全部看完这本书，有点厚。。。。


很多原理性的东西已经在 **《数据密集型应用设计》** 这本书里看过了，可以先看看这本书
## 第一章 MySQL架构与历史
![](https://img-blog.csdnimg.cn/87683a5c27cb4926aa90d8866dbbcfe5.png#pic_center)
**MySQL逻辑架构**
摘抄自该博客：[MySQL逻辑架构](https://zhuanlan.zhihu.com/p/416970649#:~:text=MySQL%E6%9C%80%E9%87%8D%E8%A6%81%E3%80%81%E6%9C%80%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C%E7%9A%84%E7%89%B9%E6%80%A7%E5%B0%B1%E6%98%AF%E5%AE%83%E7%9A%84%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84,%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%9E%B6%E6%9E%84%E5%B0%86%EF%BC%9A%20%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E3%80%81%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E4%BB%BB%E5%8A%A1%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8F%90%E5%8F%96%20%E4%B8%89%E9%83%A8%E5%88%86%E5%88%86%E7%A6%BB%E3%80%82)
MySQL最重要、最与众不同的特性就是它的存储引擎架构，这种架构将：查询处理、其他系统任务、数据的存储与提取 三部分分离。所以，带来的好处就是可以在使用时根据性能、特性，以及其他需求来选择数据存储方式。

存储引擎架构分为三层，自上而下，分为第一层：连接层；第二层：服务层；第三层：引擎层。

第一层：连接层：

MySQL的最上层是连接服务，引入了线程池的概念，允许多台客户端连接。主要工作是：连接处理、授权认证、安全防护等。

连接层为通过安全认证的接入用户提供线程，同样，在该层上可以实现基于SSL 的安全连接。

第二层：服务层：

服务层用于处理核心服务，如标准的SQL接口、查询解析、SQL优化和统计、全局的和引擎依赖的缓存与缓冲器等等。所有的与存储引擎无关的工作，如过程、函数等，都会在这一层来处理。在该层上，服务器会解析查询并创建相应的内部解析树，并对其完成优化，如确定查询表的顺序，是否利用索引等，最后生成相关的执行操作。如果是SELECT 语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

第三层：引擎层：

存储引擎层，存储引擎负责实际的MySQL数据的存储与提取，服务器通过API 与 存储引擎进行通信。不同的存储引擎功能和特性有所不同，这样可以根据实际需要有针对性的使用不同的存储引擎。


**锁粒度**
所谓锁策略，就是在锁的开销和数据安全性之间寻求平衡，这种平衡当然也会影响到性能。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时也会失去另外一些应用场景的良好支持。锁策略一般分为表示（table lock）和行级锁（row lock）。


**可重复读与MVCC**
可重复读是MySQL的默认事务隔离级别。MVCC（多版本并发控制）是通过保存某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。
在可重复读隔离级别下，MVCC各操作实现：
查询：
InnoDB会根据以下两个条件检查每行记录：
&emsp;a. InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
&emsp;b. 行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行在事务开始之前未被删除。
只有符合上述两个条件的记录才能返回作为查询结果。

插入：
InnoDB为新插入的每一行保存当前系统版本号作为行版本号

删除：
InnoDB为删除的每一行保存当前系统版本号作为行删除标识

更新：
InnoDB为插入一行新记录，保存当前系统版本号为行版本号，同时保存当前系统版本号到原来的行作为行删除标记（拆分为删除+插入操作）

InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别为可重复读，并且通过间隙锁（next-key locking）策略来防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

推荐阅读：[通过各种简单案例，让你彻底搞懂 MySQL 中的锁机制与 MVCC](https://tonydong.blog.csdn.net/article/details/103324323)
## 第二章 MySQL基准测试


## 第三章 服务器性能剖析


## 第四章 Schema与数据类型优化

## 第五章 创建高性能的索引


## 第六章 查询性能优化

## 第七章 MySQL高级特性

## 第八章 优化服务器设置

## 第九章 操作系统与硬件优化

## 第十章 复制

## 第十一章 可扩展的MySQL

## 第十二章 高可用性

## 第十三章 云端的MySQL

## 第十四章 应用层优化

## 第十五章 备份与恢复

## 第十六章 MySQL用户工具

## 附录





