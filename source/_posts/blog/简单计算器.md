---
title: 简单计算器
date: 2020-02-04 20:47:06
tags: 
categories: 算法
---
<meta name="referrer" content="no-referrer" />


##  简单计算器
## 各个输入函数（字符串输入）
**1、scanf函数（包含头文件#include <stdio.h>）**
scanf函数一般格式为scanf(“%s”,st),<mark>但scanf默认回车和空格是输入不同组之间的间隔和结束符号</mark>，所以输入带空格，tab或者回车的字符串是不可以的。

```cpp
scanf(“%[^c]”,str);
```

其中“c”是一个具体的字符常量（包括控制字符）。当输入字符串时，字符“c”将被当作当前输入的结束符。

```cpp
	char st[50];
	scanf("%[^\n]",st);// \n作为字符串输入的结束符
```


2. **cin**
```cpp
#include <iostream>
```

cin是C++中最常用的输入语句，当遇到<mark>空格或者回车键</mark>即停止。

3. **gets()**

可以无限读取，<mark>以回车结束读取</mark>，C语言中的函数，在C++中运行会产生bug。在C11标准中已被正式删除，<mark>建议不要用</mark>！！！

4. **getline()**
```cpp
#include <string>
```

若定义变量为<mark>string类型</mark>，注意不是字符型数组。则要考虑getline()函数。用法如下：

		

```cpp
		string st;
 
        getline(cin,st);
```

5. **cin.get (char *str, int maxnum)***

cin.get()函数可以接收空格，遇回车结束输入。
```cpp
 char st[50];
 cin.get(st,50);
```
5. **cin.getline (char *str, int maxnum)***
```cpp
#include <string>
```
cin.getline()函数可以同cin.get()函数类似，也可接收空格，遇回车结束输入。
[参考博客](https://blog.csdn.net/zhouhongkai06/article/details/79035005)

### 算法过程
1.设立两个堆栈，一个用来保存运算符，另一个用来保存数字。

2.在表达式首尾添加标记运算符，该运算符运算优先级最低(<mark>可以使设置为首部优先级最低，尾部优先级次之</mark>）。

3.从左至右依次遍历字符串，若遍历到运算符，则将其与运算符栈栈顶元素
进行比较，若运算符栈栈顶运算符优先级小于该运算符或者此时运算符栈为（<mark>实际上不会为空，存在首部运算符</mark>），
则将该运算符压入堆栈。遍历字符串中下一个元素。

4.若运算符栈栈顶运算符优先级大于该运算符，则<mark>弹出该栈顶运算符</mark>，再从
数字栈中依次弹出两个栈顶数字，完成弹出的运算符对应的运算得到结果后，再
将该结果压入数字栈，重复比较此时栈顶运算符与当前遍历到的运算符优先级，
视其优先级大小重复步骤 3 或步骤 4。

5.若遍历到表达式中的数字，则直接压入数字栈。

6.若运算符堆栈中仅存有两个运算符且栈顶元素为我们人为添加的标记运
算符，那么表达式运算结束，此时数字堆栈中唯一的数字即为表达式的值。

<mark>另外由于表达式中的操作数是存入堆栈，故出堆栈顺序与原先顺序相反</mark>

**函数返回两个值**
使用pair

代码节选
```cpp
typedef pair<int, int> mytype;
mytype GetNumber(string s, int index) {
	mytype value(ans, index);
	return value;
}
mytype value = GetNumber(s, index);
nums.push(value.first);
```
简单计算器实现代码
```cpp
#include<iostream>
#include<stack>
#include<string>
using namespace std;
int getPro(char function) {
	if (function == '*' || function == '/') {
		return 3;
	}
	else if (function == '+' || function == '-') {
		return 2;
	}
	else if(function == 'a'){
		return 1;
	}
	else {
		return 0;
	}
}
double count(double a, double b, char func) {
	switch (func) {
	case '*':
		return a * b;
	case '/':
		return a / b;
	case '+':
		return a + b;
	case '-':
		return a - b;
	}
	return 0;
}
bool process_stack(stack<double>& numbers, stack<char>& functions, char func) {
	int top_pro;
	int func_pro;
	char top;
	top = functions.top();
	top_pro = getPro(top);
	func_pro = getPro(func);
	if (top_pro >= func_pro) {
		functions.pop();
		double a, b;
		b = numbers.top();
		numbers.pop();
		a = numbers.top();
		numbers.pop();
		double ans = count(a, b, top);
		numbers.push(ans);
		return true;
	}
	functions.push(func);
	return false;
}
typedef pair<int, int> mytype;
mytype GetNumber(string s, int index) {
	int ans = 0;
	while (index < s.length() && s[index] >= '0' && s[index] <= '9') {
		ans = ans * 10 + s[index] - '0';
		index++;
	}
	mytype value(ans, index);
	return value;
}
int main() {
	string s;
	stack<double> nums;
	stack<char> operators;
	while (getline(cin,s)) {
		if (s[0] == '0' && s.length() == 1) {
			break;
		}
		while (!operators.empty()) operators.pop();
		operators.push('z');
		char oper;
		double num;
		int index = 0;
		while (true) {
			mytype value = GetNumber(s, index);
			nums.push(value.first);
			if (value.second == s.length()) {
				while (process_stack(nums, operators, 'a')) {}
				double ans = nums.top();
				nums.pop();
				printf("%.2f\n", ans);
				break;
			}
			oper = s[value.second+1];
			index = value.second + 3;
			while (process_stack(nums, operators, oper)) {}
		}
	}
}
```

