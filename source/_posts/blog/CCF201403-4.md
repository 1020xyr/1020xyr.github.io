---
title: CCF201403-4
date: 2020-02-02 10:40:24
tags: 
categories: 算法
---
<meta name="referrer" content="no-referrer" />


# CCF201403-4
```cpp
#include<iostream>
#include<queue>
#include<vector>
using namespace std;

typedef struct route{
	long long  x,y;
	int step;
	int count;
}route;
bool below(long long x1,long long y1,long long x2,long long y2,long long r){
	long long x = (x1-x2)*(x1-x2);
	long long y = (y1-y2)*(y1-y2);
	return (x+y <= r*r);
}
int BFS(int n,int m,int k,long long r){
	vector<vector<long long> > array(n+m,vector<long long>(2,0));
	for(int i=0;i<n+m;i++){
		cin>>array[i][0]>>array[i][1];
	}	
	vector<bool> visit(n+m,false);
	queue<route> q;
	route first;
	first.x = array[0][0];
	first.y = array[0][1];
	first.step = 0;
	first.count = 0;
	q.push(first);
	visit[0] = true;
	long long ex = array[1][0];
	long long ey = array[1][1];
	while(!q.empty()){
		route front = q.front();
		long long x = front.x;
		long long y = front.y;
		q.pop();
		
		if(x==ex&&y==ey){
			return front.step-1;
		}
		for(int i=0;i<n+m;i++){
			if(!visit[i]&&below(x,y,array[i][0],array[i][1],r)){
				visit[i] = true;
				route tmp;
				tmp.x = array[i][0];
				tmp.y = array[i][1];
				if(i>=n){
					tmp.count = front.count + 1;
				}
				else{
					tmp.count = front.count ;
				}
				tmp.step = front.step+1;
				if(tmp.count<=k)
					q.push(tmp);
			}
		} 
	} 
	return 0;
}
int main(){
	int n,m,k;
	long long r;
	cin>>n>>m>>k>>r;
	int step = BFS(n,m,k,r);
	cout<<step;
	return 0;
}

```

