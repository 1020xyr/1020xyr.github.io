<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/main.jpg"><link rel="icon" href="/img/main.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="问题描述1fio --filename&#x3D;&#x2F;dev&#x2F;xxx_dev --direct&#x3D;1 --rw&#x3D;write --bs&#x3D;1M --ioengine&#x3D;libaio --iodepth&#x3D;1 --runtime&#x3D;60 --numjobs&#x3D;1 --time_based --group_reporting --name&#x3D;&quot;test xxx&quot; --eta-newline&#x3D;1  承接"><meta property="og:type" content="article"><meta property="og:title" content="fio下发的请求大小不确定"><meta property="og:url" content="https://www.jiasun.top/blog/fio%E4%B8%8B%E5%8F%91%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%B0%8F%E4%B8%8D%E7%A1%AE%E5%AE%9A.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="问题描述1fio --filename&#x3D;&#x2F;dev&#x2F;xxx_dev --direct&#x3D;1 --rw&#x3D;write --bs&#x3D;1M --ioengine&#x3D;libaio --iodepth&#x3D;1 --runtime&#x3D;60 --numjobs&#x3D;1 --time_based --group_reporting --name&#x3D;&quot;test xxx&quot; --eta-newline&#x3D;1  承接"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/1efb0ebc9fb84995b78f1665f64794e5.png"><meta property="article:published_time" content="2023-06-12T02:30:39.000Z"><meta property="article:modified_time" content="2023-10-31T14:45:59.125Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="fio blk-mq 驱动 内核源码"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/1efb0ebc9fb84995b78f1665f64794e5.png"><title>fio下发的请求大小不确定 - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="fio下发的请求大小不确定"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-06-12 10:30" pubdate>2023年6月12日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 20k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 166 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">fio下发的请求大小不确定</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fio --filename=/dev/xxx_dev --direct=1 --rw=write --bs=1M --ioengine=libaio --iodepth=1 --runtime=60 --numjobs=1 --time_based --group_reporting --name=<span class="hljs-string">&quot;test xxx&quot;</span> --eta-newline=1<br></code></pre></td></tr></table></figure><p>承接<a href="https://www.jiasun.top/blog/fio%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html">fio引发的一些问题</a>，在使用blk_queue_max_hw_sectors设置最大扇区后，本以为全部搞定了，但用fio测试块设备速度时，却发现速度有时候180MB，有时候700MB，开启驱动打印后发现虽然bs设置为1M，但有时候执行下发的请求大小就不是1M，是一些奇奇怪怪的数字，nlb为3d8，6ef之类的，而且如果刚开始不是7ff，则一直不是7ff，如果刚开始是7ff，则一直是7ff。故打算找到问题的原因，并使速度一直维持在700MB。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>首先我想的是在请求大小为1M与请求大小不是1M的函数调用栈是不是有一些差异，故在驱动中插入dump_stack，输出大小为1M时的函数调用栈和不为1M的调用栈，发现调用栈一致</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 请求大小不为1MB</span><br>[  +0.000007] request received: pos=279856 bytes=368640 cur_bytes=4096 <span class="hljs-built_in">dir</span>=W<br>[  +0.000002] CPU: 3 PID: 3623 Comm: fio Kdump: loaded Tainted: G           OE     5.4.18-35-generic <span class="hljs-comment">#21-KYLINOS</span><br>[  +0.000001] Hardware name: GITSTAR GITSTAR-MF20A/GM9-2665, BIOS 03.12 02/15/22 23:09:42<br>[  +0.000001] Call trace:<br>[  +0.000004]  dump_backtrace+0x0/0x178<br>[  +0.000001]  show_stack+0x14/0x20<br>[  +0.000002]  dump_stack+0xac/0xd0<br>[  +0.000005]  hps_queue_rq+0xf4/0x160 [Hps]<br>[  +0.000002]  blk_mq_dispatch_rq_list+0x9c/0x5e8<br>[  +0.000002]  blk_mq_do_dispatch_sched+0x60/0x100<br>[  +0.000001]  blk_mq_sched_dispatch_requests+0x158/0x1b8<br>[  +0.000003]  __blk_mq_run_hw_queue+0x90/0x158<br>[  +0.000001]  __blk_mq_delay_run_hw_queue+0x1d4/0x1d8<br>[  +0.000002]  blk_mq_run_hw_queue+0x9c/0x120<br>[  +0.000001]  blk_mq_sched_insert_requests+0x84/0x150<br>[  +0.000002]  blk_mq_flush_plug_list+0x100/0x160<br>[  +0.000002]  blk_flush_plug_list+0xdc/0x110<br>[  +0.000001]  blk_finish_plug+0x30/0x40<br>[  +0.000002]  blkdev_write_iter+0xb4/0x138<br>[  +0.000001]  aio_write+0xd8/0x180<br>[  +0.000002]  io_submit_one+0x604/0x8a8<br>[  +0.000001]  sys_io_submit+0x168/0x238<br>[  +0.000002]  el0_svc_naked+0x30/0x34<br>[  +0.000002] push sq cmd to fifo<br>[  +0.000001] fifo avail:  65536<br>[  +0.000001] SQ info：opc b slba 44530  nlb 2cf   cid 154   buf fa100000 <br><br><span class="hljs-comment"># 请求大小为1MB</span><br>[  +0.000159] request received: pos=901120 bytes=1048576 cur_bytes=4096 <span class="hljs-built_in">dir</span>=W<br>[  +0.000004] CPU: 3 PID: 3677 Comm: fio Kdump: loaded Tainted: G           OE     5.4.18-35-generic <span class="hljs-comment">#21-KYLINOS</span><br>[  +0.000001] Hardware name: GITSTAR GITSTAR-MF20A/GM9-2665, BIOS 03.12 02/15/22 23:09:42<br>[  +0.000001] Call trace:<br>[  +0.000005]  dump_backtrace+0x0/0x178<br>[  +0.000002]  show_stack+0x14/0x20<br>[  +0.000002]  dump_stack+0xac/0xd0<br>[  +0.000008]  hps_queue_rq+0xf4/0x160 [Hps]<br>[  +0.000005]  blk_mq_dispatch_rq_list+0x9c/0x5e8<br>[  +0.000002]  blk_mq_do_dispatch_sched+0x60/0x100<br>[  +0.000002]  blk_mq_sched_dispatch_requests+0x158/0x1b8<br>[  +0.000002]  __blk_mq_run_hw_queue+0x90/0x158<br>[  +0.000002]  __blk_mq_delay_run_hw_queue+0x1d4/0x1d8<br>[  +0.000002]  blk_mq_run_hw_queue+0x9c/0x120<br>[  +0.000001]  blk_mq_sched_insert_requests+0x84/0x150<br>[  +0.000002]  blk_mq_flush_plug_list+0x100/0x160<br>[  +0.000002]  blk_flush_plug_list+0xdc/0x110<br>[  +0.000002]  blk_finish_plug+0x30/0x40<br>[  +0.000002]  blkdev_write_iter+0xb4/0x138<br>[  +0.000002]  aio_write+0xd8/0x180<br>[  +0.000002]  io_submit_one+0x604/0x8a8<br>[  +0.000003]  sys_io_submit+0x168/0x238<br>[  +0.000003]  el0_svc_naked+0x30/0x34<br>[  +0.000214] send sq cmd<br>[  +0.000002] SQ info：opc b slba dc000  nlb 7ff   cid 50   buf fa100000<br></code></pre></td></tr></table></figure><h2 id="回顾nvme-set-queue-limits函数"><a href="#回顾nvme-set-queue-limits函数" class="headerlink" title="回顾nvme_set_queue_limits函数"></a>回顾nvme_set_queue_limits函数</h2><p>以nvme驱动作为对照组，在nvme驱动中插入打印语句，看nvme驱动有没有类似情况，没发现这种情况，倒是结束时会出现一些其他大小的请求。</p><p>然后想想，不如把nvme_set_queue_limits函数设置的函数都设置一下吧。<br>首先输出一些nvme驱动中各set函数的参数，照猫画虎在自己写的驱动里用一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nvme_set_queue_limits</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl,</span><br><span class="hljs-params">				  <span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br>	<span class="hljs-type">bool</span> vwc = <span class="hljs-literal">false</span>;<br><br>	<span class="hljs-keyword">if</span> (ctrl-&gt;max_hw_sectors) &#123;<br>		u32 max_segments =<br>			(ctrl-&gt;max_hw_sectors / (ctrl-&gt;page_size &gt;&gt; <span class="hljs-number">9</span>)) + <span class="hljs-number">1</span>;<br><br>		max_segments = min_not_zero(max_segments, ctrl-&gt;max_segments);<br>		blk_queue_max_hw_sectors(q, ctrl-&gt;max_hw_sectors);<br>		blk_queue_max_segments(q, <span class="hljs-type">min_t</span>(u32, max_segments, USHRT_MAX));<br>		printk(KERN_WARNING <span class="hljs-string">&quot;max_hw_sectors %d max_segments %d&quot;</span>,<br>		       ctrl-&gt;max_hw_sectors,<br>		       <span class="hljs-type">min_t</span>(u32, max_segments, USHRT_MAX));<br>	&#125;<br>	<span class="hljs-keyword">if</span> ((ctrl-&gt;quirks &amp; NVME_QUIRK_STRIPE_SIZE) &amp;&amp;<br>	    is_power_of_2(ctrl-&gt;max_hw_sectors))<br>		blk_queue_chunk_sectors(q, ctrl-&gt;max_hw_sectors);<br>	blk_queue_virt_boundary(q, ctrl-&gt;page_size - <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span> (ctrl-&gt;vwc &amp; NVME_CTRL_VWC_PRESENT)<br>		vwc = <span class="hljs-literal">true</span>;<br>	blk_queue_write_cache(q, vwc, vwc);<br>	printk(KERN_WARNING <span class="hljs-string">&quot;mask %d vwc %d&quot;</span>, ctrl-&gt;page_size - <span class="hljs-number">1</span>, vwc);<br>&#125;<br><br>[  +<span class="hljs-number">0.002594</span>] max_hw_sectors <span class="hljs-number">2048</span> max_segments <span class="hljs-number">127</span><br>[  +<span class="hljs-number">0.000002</span>] mask <span class="hljs-number">4095</span> vwc <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>相关函数介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * blk_queue_max_segments - set max hw segments for a request for this queue</span><br><span class="hljs-comment"> * @q:  the request queue for the device</span><br><span class="hljs-comment"> * @max_segments:  max number of segments</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> *    Enables a low level driver to set an upper limit on the number of</span><br><span class="hljs-comment"> *    hw data segments in a request.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">blk_queue_max_segments</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> max_segments)</span>;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * blk_queue_virt_boundary - set boundary rules for bio merging</span><br><span class="hljs-comment"> * @q:  the request queue for the device</span><br><span class="hljs-comment"> * @mask:  the memory boundary mask</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">blk_queue_virt_boundary</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mask)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * blk_queue_write_cache - configure queue&#x27;s write cache</span><br><span class="hljs-comment"> * @q:		the request queue for the device</span><br><span class="hljs-comment"> * @wc:		write back cache on or off</span><br><span class="hljs-comment"> * @fua:	device supports FUA writes, if true</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Tell the block layer about the write cache of @q.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">blk_queue_write_cache</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-type">bool</span> wc, <span class="hljs-type">bool</span> fua)</span>;<br></code></pre></td></tr></table></figure><p>驱动设置前后成员值对比</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">    PRINT_INFO(<span class="hljs-string">&quot;before: max sector:%d max seg:%d mask:%d&quot;</span>, queue_max_sectors(xxx_dev-&gt;<span class="hljs-built_in">queue</span>),<br>               queue_max_segments(xxx_dev-&gt;<span class="hljs-built_in">queue</span>), queue_virt_boundary(xxx_dev-&gt;<span class="hljs-built_in">queue</span>));<br>    blk_queue_max_hw_sectors(xxx_dev-&gt;<span class="hljs-built_in">queue</span>, (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>) / (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>)); <span class="hljs-comment">// 最大1M数据</span><br>    blk_queue_max_segments(xxx_dev-&gt;<span class="hljs-built_in">queue</span>, <span class="hljs-number">127</span>);<br>    blk_queue_virt_boundary(xxx_dev-&gt;<span class="hljs-built_in">queue</span>, <span class="hljs-number">4096</span> - <span class="hljs-number">1</span>);<br>    blk_queue_write_cache(xxx_dev-&gt;<span class="hljs-built_in">queue</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    PRINT_INFO(<span class="hljs-string">&quot;after: max sector:%d max seg:%d mask:%d&quot;</span>, queue_max_sectors(xxx_dev-&gt;<span class="hljs-built_in">queue</span>),<br>               queue_max_segments(xxx_dev-&gt;<span class="hljs-built_in">queue</span>), queue_virt_boundary(xxx_dev-&gt;<span class="hljs-built_in">queue</span>));<br><br>[  +<span class="hljs-number">0.000073</span>] before: max sector:<span class="hljs-number">255</span> max seg:<span class="hljs-number">128</span> mask:<span class="hljs-number">0</span><br>[  +<span class="hljs-number">0.000002</span>] after: max sector:<span class="hljs-number">2048</span> max seg:<span class="hljs-number">127</span> mask:<span class="hljs-number">4095</span><br></code></pre></td></tr></table></figure><p><em>可惜设置完成后这种情况还是会出现，过几天再研究一下， 从函数调用栈 起始扇区 生成的请求大小等方面找原因。</em></p><h2 id="研究内核调用栈"><a href="#研究内核调用栈" class="headerlink" title="研究内核调用栈"></a>研究内核调用栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">[  +<span class="hljs-number">0.000005</span>]  hps_queue_rq+<span class="hljs-number">0xf4</span>/<span class="hljs-number">0x160</span> [Hps]<br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_dispatch_rq_list+<span class="hljs-number">0x9c</span>/<span class="hljs-number">0x5e8</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_do_dispatch_sched+<span class="hljs-number">0x60</span>/<span class="hljs-number">0x100</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_sched_dispatch_requests+<span class="hljs-number">0x158</span>/<span class="hljs-number">0x1b8</span><br>[  +<span class="hljs-number">0.000003</span>]  __blk_mq_run_hw_queue+<span class="hljs-number">0x90</span>/<span class="hljs-number">0x158</span><br>[  +<span class="hljs-number">0.000001</span>]  __blk_mq_delay_run_hw_queue+<span class="hljs-number">0x1d4</span>/<span class="hljs-number">0x1d8</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_run_hw_queue+<span class="hljs-number">0x9c</span>/<span class="hljs-number">0x120</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_sched_insert_requests+<span class="hljs-number">0x84</span>/<span class="hljs-number">0x150</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_flush_plug_list+<span class="hljs-number">0x100</span>/<span class="hljs-number">0x160</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_flush_plug_list+<span class="hljs-number">0xdc</span>/<span class="hljs-number">0x110</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_finish_plug+<span class="hljs-number">0x30</span>/<span class="hljs-number">0x40</span><br>[  +<span class="hljs-number">0.000002</span>]  blkdev_write_iter+<span class="hljs-number">0xb4</span>/<span class="hljs-number">0x138</span><br>[  +<span class="hljs-number">0.000001</span>]  aio_write+<span class="hljs-number">0xd8</span>/<span class="hljs-number">0x180</span><br>[  +<span class="hljs-number">0.000002</span>]  io_submit_one+<span class="hljs-number">0x604</span>/<span class="hljs-number">0x8a8</span><br>[  +<span class="hljs-number">0.000001</span>]  sys_io_submit+<span class="hljs-number">0x168</span>/<span class="hljs-number">0x238</span><br>[  +<span class="hljs-number">0.000002</span>]  el0_svc_naked+<span class="hljs-number">0x30</span>/<span class="hljs-number">0x34</span><br></code></pre></td></tr></table></figure><p>对于以上调用栈从后往前推，看请求大小的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">blk_rq_bytes</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> rq-&gt;__data_len;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Returns true if we did some work AND can potentially do more.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">blk_mq_dispatch_rq_list</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q, <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,</span><br><span class="hljs-params">			     <span class="hljs-type">bool</span> got_budget)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_hw_ctx</span> *<span class="hljs-title">hctx</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>, *<span class="hljs-title">nxt</span>;</span><br>    <br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Now process all the entries, sending them to the driver.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">do</span> &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_queue_data</span> <span class="hljs-title">bd</span>;</span><br><br>		rq = list_first_entry(<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> request, queuelist); <span class="hljs-comment">// 从链表中取出相应请求</span><br><br>		hctx = rq-&gt;mq_hctx;<br><br>		list_del_init(&amp;rq-&gt;queuelist);<br><br>		bd.rq = rq;<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Flag last if we have no more requests, or if we have more</span><br><span class="hljs-comment">		 * but can&#x27;t assign a driver tag to it.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (list_empty(<span class="hljs-built_in">list</span>))<br>			bd.last = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">else</span> &#123;<br>			nxt = list_first_entry(<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> request, queuelist);<br>			bd.last = !blk_mq_get_driver_tag(nxt);<br>		&#125;<br><br>		ret = q-&gt;mq_ops-&gt;queue_rq(hctx, &amp;bd);	<span class="hljs-comment">// 调用驱动定义的queue_rq函数</span><br><br>		<span class="hljs-keyword">if</span> (unlikely(ret != BLK_STS_OK)) &#123;		<span class="hljs-comment">// 返回错误，调用blk_mq_end_request函数</span><br>			errors++;<br>			blk_mq_end_request(rq, BLK_STS_IOERR);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br><br>		queued++;<br>	&#125; <span class="hljs-keyword">while</span> (!list_empty(<span class="hljs-built_in">list</span>));<br>    <br><br><span class="hljs-comment">// 看到注释中的scsi很奇怪    </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Only SCSI implements .get_budget and .put_budget, and SCSI restarts</span><br><span class="hljs-comment"> * its queue by itself in its completion handler, so we don&#x27;t need to</span><br><span class="hljs-comment"> * restart queue if .get_budget() fails to get the budget.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Returns -EAGAIN if hctx-&gt;dispatch was found non-empty and run_work has to</span><br><span class="hljs-comment"> * be run again.  This is necessary to avoid starving flushes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">blk_mq_do_dispatch_sched</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_queue</span> *<span class="hljs-title">e</span> =</span> q-&gt;elevator;<br>	LIST_HEAD(rq_list);<br><br>	<span class="hljs-keyword">do</span> &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">rq</span>;</span><br><br>		<span class="hljs-keyword">if</span> (e-&gt;type-&gt;ops.has_work &amp;&amp; !e-&gt;type-&gt;ops.has_work(hctx))<br>			<span class="hljs-keyword">break</span>;<br><br>		rq = e-&gt;type-&gt;ops.dispatch_request(hctx);<br><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Now this rq owns the budget which has to be released</span><br><span class="hljs-comment">		 * if this rq won&#x27;t be queued to driver via .queue_rq()</span><br><span class="hljs-comment">		 * in blk_mq_dispatch_rq_list().</span><br><span class="hljs-comment">		 */</span><br>		list_add(&amp;rq-&gt;queuelist, &amp;rq_list);<br>	&#125; <span class="hljs-keyword">while</span> (blk_mq_dispatch_rq_list(q, &amp;rq_list, <span class="hljs-literal">true</span>));<br><br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到blk_mq_do_dispatch_sched注释中的SCSI，就觉得有点不对劲，故查看nvme驱动调用栈与本驱动调用第一个不同的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">[  +<span class="hljs-number">0.000002</span>]  nvme_queue_rq.cold+<span class="hljs-number">0x28</span>/<span class="hljs-number">0x97</span> [nvme]<br>[  +<span class="hljs-number">0.000002</span>]  __blk_mq_try_issue_directly+<span class="hljs-number">0x116</span>/<span class="hljs-number">0x1c0</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_request_issue_directly+<span class="hljs-number">0x4b</span>/<span class="hljs-number">0xe0</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_try_issue_list_directly+<span class="hljs-number">0x46</span>/<span class="hljs-number">0xb0</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_sched_insert_requests+<span class="hljs-number">0xae</span>/<span class="hljs-number">0x100</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_flush_plug_list+<span class="hljs-number">0x1e8</span>/<span class="hljs-number">0x290</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_flush_plug_list+<span class="hljs-number">0xe3</span>/<span class="hljs-number">0x110</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_finish_plug+<span class="hljs-number">0x26</span>/<span class="hljs-number">0x34</span><br>[  +<span class="hljs-number">0.000001</span>]  blkdev_write_iter+<span class="hljs-number">0xbd</span>/<span class="hljs-number">0x140</span><br>[  +<span class="hljs-number">0.000001</span>]  aio_write+<span class="hljs-number">0xec</span>/<span class="hljs-number">0x1a0</span><br><br> [  +<span class="hljs-number">0.000005</span>]  hps_queue_rq+<span class="hljs-number">0xf4</span>/<span class="hljs-number">0x160</span> [Hps]<br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_dispatch_rq_list+<span class="hljs-number">0x9c</span>/<span class="hljs-number">0x5e8</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_do_dispatch_sched+<span class="hljs-number">0x60</span>/<span class="hljs-number">0x100</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_sched_dispatch_requests+<span class="hljs-number">0x158</span>/<span class="hljs-number">0x1b8</span><br>[  +<span class="hljs-number">0.000003</span>]  __blk_mq_run_hw_queue+<span class="hljs-number">0x90</span>/<span class="hljs-number">0x158</span><br>[  +<span class="hljs-number">0.000001</span>]  __blk_mq_delay_run_hw_queue+<span class="hljs-number">0x1d4</span>/<span class="hljs-number">0x1d8</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_run_hw_queue+<span class="hljs-number">0x9c</span>/<span class="hljs-number">0x120</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_mq_sched_insert_requests+<span class="hljs-number">0x84</span>/<span class="hljs-number">0x150</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_mq_flush_plug_list+<span class="hljs-number">0x100</span>/<span class="hljs-number">0x160</span><br>[  +<span class="hljs-number">0.000002</span>]  blk_flush_plug_list+<span class="hljs-number">0xdc</span>/<span class="hljs-number">0x110</span><br>[  +<span class="hljs-number">0.000001</span>]  blk_finish_plug+<span class="hljs-number">0x30</span>/<span class="hljs-number">0x40</span><br>[  +<span class="hljs-number">0.000002</span>]  blkdev_write_iter+<span class="hljs-number">0xb4</span>/<span class="hljs-number">0x138</span><br>[  +<span class="hljs-number">0.000001</span>]  aio_write+<span class="hljs-number">0xd8</span>/<span class="hljs-number">0x180</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 查看nvme回溯栈与本驱动回溯栈的第一个不同函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">blk_mq_sched_insert_requests</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx,</span><br><span class="hljs-params">				  <span class="hljs-keyword">struct</span> blk_mq_ctx *ctx,</span><br><span class="hljs-params">				  <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>, <span class="hljs-type">bool</span> run_queue_async)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_queue</span> *<span class="hljs-title">e</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * blk_mq_sched_insert_requests() is called from flush plug</span><br><span class="hljs-comment">	 * context only, and hold one usage counter to prevent queue</span><br><span class="hljs-comment">	 * from being released.</span><br><span class="hljs-comment">	 */</span><br>	percpu_ref_get(&amp;q-&gt;q_usage_counter);<br><br>	e = hctx-&gt;<span class="hljs-built_in">queue</span>-&gt;elevator;<br>	<span class="hljs-keyword">if</span> (e &amp;&amp; e-&gt;type-&gt;ops.insert_requests)<br>		e-&gt;type-&gt;ops.insert_requests(hctx, <span class="hljs-built_in">list</span>, <span class="hljs-literal">false</span>);<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * try to issue requests directly if the hw queue isn&#x27;t</span><br><span class="hljs-comment">		 * busy in case of &#x27;none&#x27; scheduler, and this way may save</span><br><span class="hljs-comment">		 * us one extra enqueue &amp; dequeue to sw queue.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (!hctx-&gt;dispatch_busy &amp;&amp; !e &amp;&amp; !run_queue_async) &#123;<br>			blk_mq_try_issue_list_directly(hctx, <span class="hljs-built_in">list</span>);  <span class="hljs-comment">// nvme驱动</span><br>			<span class="hljs-keyword">if</span> (list_empty(<span class="hljs-built_in">list</span>))<br>				<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>		blk_mq_insert_requests(hctx, ctx, <span class="hljs-built_in">list</span>);<br>	&#125;<br><br>	blk_mq_run_hw_queue(hctx, run_queue_async);	<span class="hljs-comment">// 本驱动</span><br> out:<br>	percpu_ref_put(&amp;q-&gt;q_usage_counter);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出区分点在于hctx-&gt;queue-&gt;elevator</p><p>查看请求队列初始化时对elevator成员的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化队列时是否设置elevator成员</span><br><span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_mq_init_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">uninit_q</span>, *<span class="hljs-title">q</span>;</span><br><br>	uninit_q = blk_alloc_queue_node(GFP_KERNEL, <span class="hljs-built_in">set</span>-&gt;numa_node);<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Initialize the queue without an elevator. device_add_disk() will do</span><br><span class="hljs-comment">	 * the initialization.</span><br><span class="hljs-comment">	 */</span><br>	q = blk_mq_init_allocated_queue(<span class="hljs-built_in">set</span>, uninit_q, <span class="hljs-literal">false</span>);<br><br>	<span class="hljs-keyword">return</span> q;<br>&#125;<br><br><span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_mq_init_allocated_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">						  <span class="hljs-keyword">struct</span> request_queue *q,</span><br><span class="hljs-params">						  <span class="hljs-type">bool</span> elevator_init)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (elevator_init)<br>		elevator_init_mq(q);<br>&#125;<br></code></pre></td></tr></table></figure><p>elevator_init为false，并不初始化elevator成员</p><p>全局搜索elevator_init_mq函数使用情况<br><img src="https://img-blog.csdnimg.cn/18d46c6b70664454b2a5e1777b154c44.png" srcset="/img/loading.gif" lazyload><br>另外一次使用为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在另外一处使用elevator_init_mq函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">device_add_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *parent, <span class="hljs-keyword">struct</span> gendisk *disk,</span><br><span class="hljs-params">		     <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> attribute_group **groups)</span><br><br>&#123;<br>	__device_add_disk(parent, disk, groups, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __device_add_disk - add disk information to kernel list</span><br><span class="hljs-comment"> * @parent: parent device for the disk</span><br><span class="hljs-comment"> * @disk: per-device partitioning information</span><br><span class="hljs-comment"> * @groups: Additional per-device sysfs groups</span><br><span class="hljs-comment"> * @register_queue: register the queue if set to true</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function registers the partitioning information in @disk</span><br><span class="hljs-comment"> * with the kernel.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">FIXME:</span> error handling</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __device_add_disk(<span class="hljs-keyword">struct</span> device *parent, <span class="hljs-keyword">struct</span> gendisk *disk,<br>			      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> attribute_group **groups,<br>			      <span class="hljs-type">bool</span> register_queue)<br>&#123;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The disk queue should now be all set with enough information about</span><br><span class="hljs-comment">	 * the device for the elevator code to pick an adequate default</span><br><span class="hljs-comment">	 * elevator if one is needed, that is, for devices requesting queue</span><br><span class="hljs-comment">	 * registration.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (register_queue)<br>		elevator_init_mq(disk-&gt;<span class="hljs-built_in">queue</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>nr_hw_queues不等于1则e&#x3D;NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For a device queue that has no required features, use the default elevator</span><br><span class="hljs-comment"> * settings. Otherwise, use the first elevator available matching the required</span><br><span class="hljs-comment"> * features. If no suitable elevator is find or if the chosen elevator</span><br><span class="hljs-comment"> * initialization fails, fall back to the &quot;none&quot; elevator (no elevator).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">elevator_init_mq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_type</span> *<span class="hljs-title">e</span>;</span><br>	<br>	<span class="hljs-keyword">if</span> (!elv_support_iosched(q))<br>		<span class="hljs-keyword">return</span>;<br><br>	<span class="hljs-keyword">if</span> (unlikely(q-&gt;elevator))<br>		<span class="hljs-keyword">return</span>;<br><br>	<span class="hljs-keyword">if</span> (!q-&gt;required_elevator_features)<br>		e = elevator_get_default(q);<br>	<span class="hljs-keyword">else</span><br>		e = elevator_get_by_features(q);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For single queue devices, default to using mq-deadline. If we have multiple</span><br><span class="hljs-comment"> * queues or mq-deadline is not available, default to &quot;none&quot;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> elevator_type *<span class="hljs-title function_">elevator_get_default</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (q-&gt;nr_hw_queues != <span class="hljs-number">1</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">return</span> elevator_get(q, <span class="hljs-string">&quot;mq-deadline&quot;</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相关博客，可以简要阅读一下：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/501198341">Linux block 层详解（3）- IO请求处理过程</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kanie/p/15252921.html">mq-deadline调度器原理及源码分析</a><br><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/block/blk-mq.html">Multi-Queue Block IO Queueing Mechanism (blk-mq)</a></p><p><em>尝试直接将nr_hw_queues设置成2，看是否可以解决该问题且不产生新的问题</em></p><h2 id="BLK-MQ-F-NO-SCHED"><a href="#BLK-MQ-F-NO-SCHED" class="headerlink" title="BLK_MQ_F_NO_SCHED"></a>BLK_MQ_F_NO_SCHED</h2><p>在驱动中打印elevator相关信息，发现是bfq而不是mq-deadline</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PRINT_INFO(<span class="hljs-string">&quot;elevator:%p name %s&quot;</span>,disk-&gt;queue-&gt;elevator,disk-&gt;queue-&gt;elevator-&gt;<span class="hljs-built_in">type</span>-&gt;elevator_name);<br>elevator:00000000e697a3e1 name bfq<br></code></pre></td></tr></table></figure><p>查看nvme驱动queue如何设置使得elevator为NULL (admin queue硬件队列为1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_alloc_admin_tags</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (!dev-&gt;ctrl.admin_q) &#123;<br>		dev-&gt;admin_tagset.ops = &amp;nvme_mq_admin_ops;<br>		dev-&gt;admin_tagset.nr_hw_queues = <span class="hljs-number">1</span>;<br><br>		dev-&gt;admin_tagset.queue_depth = NVME_AQ_MQ_TAG_DEPTH;<br>		dev-&gt;admin_tagset.timeout = ADMIN_TIMEOUT;<br>		dev-&gt;admin_tagset.numa_node = dev_to_node(dev-&gt;dev);<br>		dev-&gt;admin_tagset.cmd_size = nvme_pci_cmd_size(dev, <span class="hljs-literal">false</span>);<br>		dev-&gt;admin_tagset.flags = BLK_MQ_F_NO_SCHED;  <span class="hljs-comment">// 关键一行</span><br>		dev-&gt;admin_tagset.driver_data = dev;<br><br>		<span class="hljs-keyword">if</span> (blk_mq_alloc_tag_set(&amp;dev-&gt;admin_tagset))<br>			<span class="hljs-keyword">return</span> -ENOMEM;<br>		dev-&gt;ctrl.admin_tagset = &amp;dev-&gt;admin_tagset;<br><br>		dev-&gt;ctrl.admin_q = blk_mq_init_queue(&amp;dev-&gt;admin_tagset);<br>		<span class="hljs-keyword">if</span> (IS_ERR(dev-&gt;ctrl.admin_q)) &#123;<br>			blk_mq_free_tag_set(&amp;dev-&gt;admin_tagset);<br>			<span class="hljs-keyword">return</span> -ENOMEM;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (!blk_get_queue(dev-&gt;ctrl.admin_q)) &#123;<br>			nvme_dev_remove_admin(dev);<br>			dev-&gt;ctrl.admin_q = <span class="hljs-literal">NULL</span>;<br>			<span class="hljs-keyword">return</span> -ENODEV;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span><br>		blk_mq_unquiesce_queue(dev-&gt;ctrl.admin_q);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查看BLK_MQ_F_NO_SCHED使用<br><img src="https://img-blog.csdnimg.cn/685551bbc4ca482794f1ce598a3800fe.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">elv_support_iosched</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (!q-&gt;mq_ops ||<br>	    (q-&gt;tag_set &amp;&amp; (q-&gt;tag_set-&gt;flags &amp; BLK_MQ_F_NO_SCHED)))<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">elevator_init_mq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_type</span> *<span class="hljs-title">e</span>;</span><br>	<br>	<span class="hljs-keyword">if</span> (!elv_support_iosched(q))<br>		<span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>也就是说设置一下BLK_MQ_F_NO_SCHED就可以了</p><p>设置完成后再次打印相关信息，发现 <strong>%p与%llx的结果不一样</strong> （飞腾处理器+麒麟操作系统）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">PRINT_INFO(<span class="hljs-string">&quot;elevator:%llx&quot;</span>,disk-&gt;<span class="hljs-built_in">queue</span>-&gt;elevator);<br><span class="hljs-comment">// 输出 elevator:0</span><br><br>PRINT_INFO(<span class="hljs-string">&quot;elevator:%p&quot;</span>,disk-&gt;<span class="hljs-built_in">queue</span>-&gt;elevator);<br><span class="hljs-comment">// 输出 elevator:00000000353e5884</span><br><br>PRINT_INFO(<span class="hljs-string">&quot;elevator:%p&quot;</span>,disk-&gt;<span class="hljs-built_in">queue</span>-&gt;elevator);<br><br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br>PRINT_INFO(<span class="hljs-string">&quot;%llx %p&quot;</span>,p,p);<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">elevator:000000009037421b</span><br><span class="hljs-comment">0 000000009037421b</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>ubuntu虚拟机输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br>  <span class="hljs-type">int</span>* p = <span class="hljs-number">0x0</span>;<br>  <span class="hljs-type">int</span> c = <span class="hljs-number">0x1234</span>;<br>  <span class="hljs-type">int</span>* p_c = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x12345678</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p: %p  %p  %p\n&quot;</span>, a, p, <span class="hljs-number">0x1234</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;llx:  %llx  %llx %llx\n&quot;</span>, a, p, <span class="hljs-number">0x1234</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p: %p  %p  %p\n&quot;</span>, &amp;a, &amp;p, <span class="hljs-number">0x1234</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;llx: %llx  %llx  %llx\n&quot;</span>, &amp;a, &amp;p, <span class="hljs-number">0x1234</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p: %p  %p\n&quot;</span>, c, p_c);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;llx: %llx  %llx\n&quot;</span>, c, p_c);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">p: 0x7b  (nil)  0x1234</span><br><span class="hljs-comment">llx:  7b  0 1234</span><br><span class="hljs-comment">p: 0x7fff635f9fd0  0x7fff635f9fd8  0x1234</span><br><span class="hljs-comment">llx: 7fff635f9fd0  7fff635f9fd8  1234</span><br><span class="hljs-comment">p: 0x1234  0x12345678</span><br><span class="hljs-comment">llx: 1234  12345678</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>有些时候输出不一样，有些时候输出一样，<strong>故建议不要用%p，用%llx保险一点</strong><br>不过倒霉的是，即使设置了BLK_MQ_F_NO_SCHED，函数调用栈也变得与nvme驱动一致，还是会出现不一致请求大小的情况。</p><p><em>打算从请求起始扇区号，请求大小修改轨迹之类的点尝试解决该问题</em></p><h2 id="很久后的更新——奇怪的max-segments"><a href="#很久后的更新——奇怪的max-segments" class="headerlink" title="很久后的更新——奇怪的max_segments"></a>很久后的更新——奇怪的max_segments</h2><p>过了几个月后，重新调试驱动程序，同样出现了fio请求大小不一致的问题，不过这次时常出现特殊扇区数（1016），而这个值恰好和以前抄nvme驱动中blk_queue_max_segments的参数127有关系。（127 * 8 &#x3D; 1016, 8 * 512 &#x3D; 4096），而后将max_segments改成256后，请求大小变成了2048个扇区（1M大小），<mark>然而nvme驱动将max_segments设置成127，却没有出现请求大小不一致的情况</mark>，因此想看一下这个参数到底是啥含义？nvme驱动为什么要把设置成127？</p><p>nvme驱动将max_segments设置成127的原因仅仅是不想额外分配页（分散聚合dma相关，没仔细研究）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">41</span>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">42   * These can be higher, but we need to ensure that any command doesn&#x27;t</span><br><span class="hljs-comment">43   * require an sg allocation that needs more than a page of data.</span><br><span class="hljs-comment">44   */</span><br><span class="hljs-number">45</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_MAX_KB_SZ	4096</span><br><span class="hljs-number">46</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_MAX_SEGS	127</span><br></code></pre></td></tr></table></figure><p>那么这个参数的含义又是什么呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title function_">queue_max_segments</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> q-&gt;limits.max_segments;<br>&#125;<br><span class="hljs-comment">// 影响bio bi_vcnt(即bvec数目)</span><br><span class="hljs-keyword">if</span> (bio-&gt;bi_vcnt &gt;= queue_max_segments(q))<br><span class="hljs-comment">// 影响nr_phys_segments参数大小 </span><br><span class="hljs-keyword">if</span> (rq-&gt;nr_phys_segments &gt; queue_max_segments(q)) &#123;<br>    printk(KERN_ERR <span class="hljs-string">&quot;%s: over max segments limit. (%hu &gt; %hu)\n&quot;</span>,<br>           __func__, rq-&gt;nr_phys_segments, queue_max_segments(q));<br>    <span class="hljs-keyword">return</span> BLK_STS_IOERR;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Number of scatter-gather DMA addr+len pairs after</span><br><span class="hljs-comment">* physical address coalescing is performed.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> nr_phys_segments;<br></code></pre></td></tr></table></figure><p>request bio bio_vec三个结构体的关系有点头痛，有兴趣的可以自行查看相关文档或源码</p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/443820555">一个块IO的一生：从Pagecache到Request(流程图详解)</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Linux-tech/p/12961286.html">linux IO Block layer 解析</a></p><p><img src="https://img-blog.csdnimg.cn/99ac7c464b8647fc8841ac2720e195e7.png" srcset="/img/loading.gif" lazyload></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/geshifei/article/details/120590183">linux block layer第二篇bio 的操作</a></p><p><img src="https://img-blog.csdnimg.cn/58dc2341d5814a498e73977d60d55314.png" srcset="/img/loading.gif" lazyload></p><p>在nvme驱动中加上以下打印查看相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">print_req_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bio</span>;</span><br>	<span class="hljs-type">int</span> bio_cnt = <span class="hljs-number">0</span>;<br>	__rq_for_each_bio (bio, req) &#123;<br>		printk(KERN_WARNING <span class="hljs-string">&quot;bio vcnt %d&quot;</span>, bio-&gt;bi_vcnt);<br>		bio_cnt++;<br>	&#125;<br>	printk(KERN_WARNING <span class="hljs-string">&quot;bio cnt:%d&quot;</span>, bio_cnt);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">req_iterator</span> <span class="hljs-title">iter</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> <span class="hljs-title">bvec</span>;</span><br>	<span class="hljs-type">int</span> bvec_cnt = <span class="hljs-number">0</span>;<br>	rq_for_each_segment (bvec, req, iter) &#123;<br>		<span class="hljs-keyword">if</span> (bvec_cnt &lt; <span class="hljs-number">3</span>) &#123;<br>			printk(KERN_WARNING <span class="hljs-string">&quot;offset:%d len:%d &quot;</span>, bvec.bv_offset,<br>			       bvec.bv_len);<br>		&#125;<br>		bvec_cnt++;<br>	&#125;<br>	printk(KERN_WARNING <span class="hljs-string">&quot;bio vec cnt:%d&quot;</span>, bvec_cnt);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> ns is NULL when called on the admin queue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">blk_status_t</span> <span class="hljs-title function_">nvme_queue_rq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx,</span><br><span class="hljs-params">				  <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> blk_mq_queue_data *bd)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ns</span> *<span class="hljs-title">ns</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>-&gt;queuedata;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">nvmeq</span> =</span> hctx-&gt;driver_data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_dev</span> *<span class="hljs-title">dev</span> =</span> nvmeq-&gt;dev;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">req</span> =</span> bd-&gt;rq;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_iod</span> *<span class="hljs-title">iod</span> =</span> blk_mq_rq_to_pdu(req);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_command</span> <span class="hljs-title">cmnd</span>;</span><br>	<span class="hljs-type">blk_status_t</span> ret;<br><br>	iod-&gt;aborted = <span class="hljs-number">0</span>;<br>	iod-&gt;npages = <span class="hljs-number">-1</span>;<br>	iod-&gt;nents = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We should not need to do this, but we&#x27;re still using this to</span><br><span class="hljs-comment">	 * ensure we can drain requests on a dying queue.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(!test_bit(NVMEQ_ENABLED, &amp;nvmeq-&gt;flags)))<br>		<span class="hljs-keyword">return</span> BLK_STS_IOERR;<br><br>	ret = nvme_setup_cmd(ns, req, &amp;cmnd);<br>	<span class="hljs-keyword">if</span> (ret)<br>		<span class="hljs-keyword">return</span> ret;<br><br>	<span class="hljs-keyword">if</span> (blk_rq_nr_phys_segments(req)) &#123;<br>		ret = nvme_map_data(dev, req, &amp;cmnd);<br>		<span class="hljs-keyword">if</span> (ret)<br>			<span class="hljs-keyword">goto</span> out_free_cmd;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (blk_integrity_rq(req)) &#123;<br>		ret = nvme_map_metadata(dev, req, &amp;cmnd);<br>		<span class="hljs-keyword">if</span> (ret)<br>			<span class="hljs-keyword">goto</span> out_unmap_data;<br>	&#125;<br>	printk(KERN_WARNING <span class="hljs-string">&quot;request received: pos=%llx bytes=%x &quot;</span><br>			    <span class="hljs-string">&quot;cur_bytes=%u dir=%c\n&quot;</span>,<br>	       (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)blk_rq_pos(req), blk_rq_bytes(req),<br>	       blk_rq_cur_bytes(req), rq_data_dir(req) ? <span class="hljs-string">&#x27;W&#x27;</span> : <span class="hljs-string">&#x27;R&#x27;</span>);<br><br>	<span class="hljs-comment">// struct request_queue *q = req-&gt;q;</span><br>	<span class="hljs-comment">// int r_size = blk_queue_get_max_sectors(q, REQ_OP_READ);</span><br>	<span class="hljs-comment">// int w_size = blk_queue_get_max_sectors(q, REQ_OP_WRITE);</span><br>	<span class="hljs-comment">// printk(KERN_WARNING &quot;max read size:%d  max write size:%d\n&quot;, r_size,</span><br>	<span class="hljs-comment">//        w_size);</span><br>	<span class="hljs-comment">// if (blk_rq_bytes(req) == 100 * 1024) &#123;</span><br>	<span class="hljs-comment">// 	dump_stack();</span><br>	<span class="hljs-comment">// &#125;</span><br>	<span class="hljs-comment">// BUG_ON(blk_rq_bytes(req) == 101 * 1024);</span><br>	<span class="hljs-comment">// WARN_ON(blk_rq_bytes(req) == 102 * 1024);</span><br>	<span class="hljs-comment">// printk(KERN_WARNING &quot;nvme_queue_rq preempt_count:%d&quot;, preempt_count());</span><br>	<span class="hljs-comment">// struct bio_vec vec = req_bvec(req);</span><br><br>	<span class="hljs-comment">// // printk(KERN_WARNING &quot;bv len:%d&quot;, vec.bv_len);</span><br>	<span class="hljs-comment">// if (blk_rq_count_bios(req) == 1) &#123;</span><br>	<span class="hljs-comment">// 	printk(KERN_WARNING &quot;bv cnt:%d&quot;, req-&gt;bio[0].bi_vcnt);</span><br>	<span class="hljs-comment">// &#125;</span><br>	printk(KERN_WARNING <span class="hljs-string">&quot;max sector:%d max seg:%d mask:%d&quot;</span>,<br>	       queue_max_sectors(hctx-&gt;<span class="hljs-built_in">queue</span>), queue_max_segments(hctx-&gt;<span class="hljs-built_in">queue</span>),<br>	       queue_virt_boundary(hctx-&gt;<span class="hljs-built_in">queue</span>));<br>	printk(KERN_WARNING <span class="hljs-string">&quot;bio num:%d nr_phys_segments:%d &quot;</span>,<br>	       blk_rq_count_bios(req), blk_rq_nr_phys_segments(req));<br>	print_req_info(req);<br><br>	blk_mq_start_request(req);<br><br>	nvme_submit_cmd(nvmeq, &amp;cmnd, bd-&gt;last);<br>	<span class="hljs-keyword">return</span> BLK_STS_OK;<br>out_unmap_data:<br>	nvme_unmap_data(dev, req);<br>out_free_cmd:<br>	nvme_cleanup_cmd(req);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用fio测试，bs&#x3D;1M，输出如下：</p><p><img src="https://img-blog.csdnimg.cn/52907cd59353440d85d74ad87aef7a60.png" srcset="/img/loading.gif" lazyload></p><p>不知道为什么bio vcnt与bio vec cnt不能对应上，之后有空再看看这个问题吧，目前也不一定真解决了这个问题。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" class="category-chain-item">内核驱动开发记录</a> </span><span class="category-chain"><a href="/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/" class="category-chain-item">踩坑日记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/fio-blk-mq-%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/" class="print-no-link">#fio blk-mq 驱动 内核源码</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/blog/%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95.html" title="实习机试代码记录"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">实习机试代码记录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7crash%E4%BD%BF%E7%94%A8.html" title="内核调试工具crash使用"><span class="hidden-mobile">内核调试工具crash使用</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var e=Object.assign({appId:"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz",appKey:"0e2MMh7ddBCGGytOe9UEy5NP",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://uu0wegco.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>