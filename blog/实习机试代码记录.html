<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/main.jpg"><link rel="icon" href="/img/main.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="2023-03-11  美团机试题目：美团2024届暑期实习第一轮后端笔试详解通过了前三道，花了一堆时间在第四道上，一分没得，第五题都没时间看。题目的设置有点无语，一到四题安排在一起，第五题安排在一起，当时不知道提交后可以继续修改，进了一到四题的项就不敢提交，以为第五题单独放一起肯定很难，最后没时间了看了一下第五题，比较简单。搞不明白为啥要把第五题单独列一个项，要不然怎样都能写出四道来 第一"><meta property="og:type" content="article"><meta property="og:title" content="实习机试代码记录"><meta property="og:url" content="https://www.jiasun.top/blog/%E5%AE%9E%E4%B9%A0%E6%9C%BA%E8%AF%95%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="2023-03-11  美团机试题目：美团2024届暑期实习第一轮后端笔试详解通过了前三道，花了一堆时间在第四道上，一分没得，第五题都没时间看。题目的设置有点无语，一到四题安排在一起，第五题安排在一起，当时不知道提交后可以继续修改，进了一到四题的项就不敢提交，以为第五题单独放一起肯定很难，最后没时间了看了一下第五题，比较简单。搞不明白为啥要把第五题单独列一个项，要不然怎样都能写出四道来 第一"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jiasun-blog.oss-cn-hangzhou.aliyuncs.com/blog/202311020930718.png"><meta property="article:published_time" content="2023-08-15T14:59:58.000Z"><meta property="article:modified_time" content="2023-11-02T01:31:22.818Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="实习记录 机试代码"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://jiasun-blog.oss-cn-hangzhou.aliyuncs.com/blog/202311020930718.png"><title>实习机试代码记录 - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="实习机试代码记录"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-08-15 22:59" pubdate>2023年8月15日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 40k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 335 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">实习机试代码记录</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><h2 id="2023-03-11-美团机试"><a href="#2023-03-11-美团机试" class="headerlink" title="2023-03-11  美团机试"></a>2023-03-11 美团机试</h2><p>题目：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/464400810240233472?sourceSSR=search">美团2024届暑期实习第一轮后端笔试详解</a><br>通过了前三道，花了一堆时间在第四道上，一分没得，第五题都没时间看。题目的设置有点无语，一到四题安排在一起，第五题安排在一起，当时不知道提交后可以继续修改，进了一到四题的项就不敢提交，以为第五题单独放一起肯定很难，最后没时间了看了一下第五题，比较简单。搞不明白为啥要把第五题单独列一个项，要不然怎样都能写出四道来</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>小美有一个由数字字符组成的字符串。现在她想对这个字符串进行一些修改。 具体地，她可以将文个字符串中任意位置字符修改为任意的数字字符。她想知道，至少进行多少次修改，可以使得“修改后的字符串不包含两个连续相同的字符?<br>例如，对于字符串”111222333”, 她可以进行3次修改将其变为” 121212313”。输入描述<br>一行，一个字符串s，保证s只包含数字字符。1&lt;&#x3D;|s|&lt;&#x3D; 100000输出描述<br>一行，一个整数，表示修改的最少次数。</p><p><strong>思路</strong><br>简单题，遇见相同的字符直接改成数字字符之外的‘a’即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  string s;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (s[i] == s[i - <span class="hljs-number">1</span>]) &#123;<br>        s[i] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        cnt++;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>小团在一个n*m的网格地图上探索。 网格地图上第i行第j列的格子用坐标(i,j)简记。初始时，小团的位置在地图的左上角，即坐标(1,1)。 地图上的每个格子 上都有一定的金币， 特别地，小团位于的初始位置(1,1)上的金币为0。小团在进行探索移动时，可以选择向右移动-格(即从(x,y)到达(x,y+1))或向下移动一格(即从(x,y)到达(x+1,y)) 。地图上的每个格子都有一个颜色，红，色或蓝色。如果小团次移动前后的两个格子颜色不同，那么他需要支付k个金币才能够完成这-次移动;如果移动前后的两个格子颜色相同，则不需要支付金币。小团可以在任意格子选择结束探索。现在给你网格地图上每个格子的颜色与金币数量，假设小团初始时的金币数量为0，请你帮助小团计算出最优规划，使他能获得最多的金币，输出能获得的最多 金币数量即可。注意:要求保证小团任意时刻金币数量不小于零。</p><p>输入描述<br>第一行是三个用空格隔开的整数n、m和k，表示网格地图的行数为n,列数为m,在不同颜色的两个格子间移动需要支付k个金币。<br>接下来n行，每行是一个长度为m的字符串， 字符串仅包含字符R’或’ B’。第i行字符串的第j个字符表示地图上第i行第j列的格子颜色，如果字符为’ R’ 则表示格子颜色为红色，为’B’ 表示格子颜色为蓝色。<br>接下来是个n行m列的非负整数矩阵，第i行第j列的数字表示地图上第行第j列的格子上的金币数量。保证所有数据中数字大小都是介于[0, 10]的整数。<br>1&lt;&#x3D;n,m&lt;&#x3D;200, 1&lt;&#x3D;k&lt;&#x3D;5。</p><p><strong>思路</strong><br>刚开始直接暴力回溯，运行超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义全局变量</span><br>string color[<span class="hljs-number">201</span>];<br><span class="hljs-type">int</span> coin_num[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> max_coin_num;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cur_coin_num)</span> </span>&#123;<br>  max_coin_num = <span class="hljs-built_in">max</span>(max_coin_num, cur_coin_num);<br>  <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; n) &#123;  <span class="hljs-comment">// 向下移动</span><br>    <span class="hljs-type">int</span> offer = color[x][y] == color[x + <span class="hljs-number">1</span>][y] ? <span class="hljs-number">0</span> : -k;<br>    <span class="hljs-keyword">if</span> (cur_coin_num + offer &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y, cur_coin_num + offer + coin_num[x + <span class="hljs-number">1</span>][y]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; m) &#123;  <span class="hljs-comment">// 向右移动</span><br>    <span class="hljs-type">int</span> offer = color[x][y] == color[x][y + <span class="hljs-number">1</span>] ? <span class="hljs-number">0</span> : -k;<br>    <span class="hljs-keyword">if</span> (cur_coin_num + offer &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, cur_coin_num + offer + coin_num[x][y + <span class="hljs-number">1</span>]);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; color[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; coin_num[i][j];<br>      &#125;<br>    &#125;<br>    max_coin_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; max_coin_num &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面用动态规划写了一个版本，通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  string color[<span class="hljs-number">201</span>];<br>  <span class="hljs-type">int</span> coin_num[<span class="hljs-number">201</span>][<span class="hljs-number">201</span>];<br>  <span class="hljs-type">int</span> n, m, k;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; color[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; coin_num[i][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">max_coin_num</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));  <span class="hljs-comment">// 全部设成-1，不可达</span><br>    max_coin_num[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-type">int</span> value = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 从上方转移而来</span><br>          <span class="hljs-type">int</span> offer = color[i][j] == color[i - <span class="hljs-number">1</span>][j] ? <span class="hljs-number">0</span> : -k;<br>          value = <span class="hljs-built_in">max</span>(value, max_coin_num[i - <span class="hljs-number">1</span>][j] + offer);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 从左边转移而来</span><br>          <span class="hljs-type">int</span> offer = color[i][j] == color[i][j - <span class="hljs-number">1</span>] ? <span class="hljs-number">0</span> : -k;<br>          value = <span class="hljs-built_in">max</span>(value, max_coin_num[i][j - <span class="hljs-number">1</span>] + offer);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 进行状态转移</span><br>          max_coin_num[i][j] = value + coin_num[i][j];<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计算最大金币数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, max_coin_num[i][j]);<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>小美是位天文爱好者， 她收集了接下来段时间中所有 会划过她所在的观测地上空的流星信息。具体地，她收集了n个流星在她所在观测地上空的出现时刻和消失时刻。对于一个流星，若’其的出现时刻为s，消失时刻为t，那么小美在时间段[s, t]都能够观测到它。对于一个时刻，观测地上空出现的流星数量越多，则小美认为该时刻越好。小美希望能够选择一个最佳的时刻进行观测和摄影，使她能观测到最多数量的流星。现在小美想知道 ，在这个最佳时刻，她最多能观测到多少个流星以及一共有多少个最佳时刻可供她选择。</p><p>输入描述<br>第一行是一个正整数n,表示流星的数量。<br>第二行是n个用空格隔开的正整数，第i个数si表示第i个流星的出现时间。<br>第三行是n个用空格隔开的正整数，第i个数ti表示第i个流星的消失时间。<br>1&lt;&#x3D;n&lt;&#x3D;100000, 1&lt;&#x3D;si&lt;&#x3D;ti&lt;&#x3D;10^9<br>输出描述<br>输出一行用空格隔开的两个数x和y,其中x表示小美能观测到的最多流星数，y表示可供她选择的最佳时刻数量。</p><p><strong>思路</strong><br>排序，从左往右计算可观测的流星数量，不过后面看别人说标准解法是差分数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>  <span class="hljs-type">int</span> value;      <span class="hljs-comment">// 时间</span><br>  <span class="hljs-type">bool</span> is_start;  <span class="hljs-comment">// 是否为起始观测时间</span><br>  <span class="hljs-type">int</span> number;     <span class="hljs-comment">// 观测流星数目</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, s, t;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-function">vector&lt;Node&gt; <span class="hljs-title">star</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; s;<br>      star[i].value = s;<br>      star[i].is_start = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;<br>      cin &gt;&gt; t;<br>      star[i].value = t;<br>      star[i].is_start = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> Node&amp; n1, <span class="hljs-type">const</span> Node&amp; n2) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> n1.value &lt; n2.value || (n1.value == n2.value &amp;&amp; n1.is_start == <span class="hljs-literal">true</span>); &#125;;  <span class="hljs-comment">// 尽可能让起始观测时间在终止观测时间之前</span><br>    <span class="hljs-built_in">sort</span>(star.<span class="hljs-built_in">begin</span>(), star.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-type">int</span> observer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max_observer = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (star[i].is_start) &#123;  <span class="hljs-comment">// 遇到起始时间，观测数加一</span><br>        observer++;<br>        star[i].number = observer;<br>      &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 遇到终止时间，当前观测数不变，之后观测数减一</span><br>        star[i].number = observer;<br>        observer--;<br>      &#125;<br>      max_observer = <span class="hljs-built_in">max</span>(max_observer, star[i].number);<br>    &#125;<br>    <span class="hljs-type">int</span> time_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (star[i].number == max_observer) &#123;  <span class="hljs-comment">// 一定为start-end组合，跳过end节点</span><br>        time_num += star[i + <span class="hljs-number">1</span>].value - star[i].value + <span class="hljs-number">1</span>;<br>        i++;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; max_observer &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; time_num &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>小D和小W最近在玩坦克大战，双方操控自己的坦克在16*1 6的方格图上战斗，小D的坦克初始位置在地图的左上角，朝向为右，其坐标(0,0)， 小W的坦克初始位置在地图右下角，朝向为左，坐标为(15,15)。坦克不能移动到地图外，坦克会占领自己所在的格子，己方的坦克不可以进入对方占领过的格子。每一个回合双方必须对自己的坦克下达以下5种指令中的一种:<br>.移动指令U:回合结束后，使己方坦克朝向为上，若上方的格子未被对方占领，则向当前朝向移动一个单位(横坐标-1)，否则保持不动;<br>.移动指令D:回合结束后，使己方坦克朝向为下，若下方的格子未被对方占领，则向当前朝向移动一个单位(横坐标+1)，否则保持不动，<br>.移动指令L:回合结束后，使己方坦克朝向为左,若左侧的格子未被对方占领，则向当前朝向移动一个单位(纵坐标-1) ,否则保持不动;<br>.移动指令R:回合结束后，使己方坦克朝向为右，若右侧的格子未被对方占领，则向当前朝向移动一个单位(纵坐标+1)，否则保持不动;<br>. 开火指令F:己方坦克在当前回合立即向当前朝向开火;</p><p>己方坦克开火后，当前回合己方坦克的正前方若有对方的坦克，对方的坦克将被摧毁，游戏结束，己方获得胜利;若双方的坦克在同一-回合被摧毁，游戏结束，判定为平局;若双方的坦克在同一回合内进入到同一个未被占领的格子，则双方的坦克发生碰撞，游戏结束，判定为平局;当游戏进行到第256个回合后，游戏结束，若双方坦克均未被摧毁，则占领格子数多的一方获得胜利，若双方占领的格子数一样多，判定为平局。*注意， 若-方开火， 另-方移动，则认为是先开火，后移动。</p><p>现在小D和小W各自给出一串长度为256的指令字符串， 请你帮助他们计算出游戏将在多少个回合后结束，以及游戏的结果。</p><p>输入描述<br>输入共两行，每行为一串长度为256的指令宁符串，字符串中只包含“U”，“D”，“L” “R”，“F”这五个字符。第一行表示小D的指令，第工行表示小W的指令。<br>输出描述<br>输出一共两行，第一行一个整数k，表示游戏将在k个回合后结束。第二行为游戏的结 果，若小D获胜则输出“D”，若小W获胜则输出“W”若平局则输出“P”</p><p><strong>思路</strong><br>大模拟，40分钟一分没得，懒得贴代码了</p><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>给一棵有n个点的有根树，点的编号为1到n，根为1。每个点的颜色是红色或者蓝色。对于树上的一个点，如果其子树中(不包括该点本身)红色点和蓝色点的数量相同，那么我们称该点是平衡的。</p><p>请你计算给定的树中有多少个点是平衡点。</p><p>输入描述<br>第一行是一个正整数n，表示有n个点。<br>接下来行一个长度为n的字符串，仅包含字符R’和’B’， 第i个字符表示编号为的节点的颜色，字符为’R’ 表示红色，’ B’ 表示蓝色。<br>接下来一行n-1个用空格隔开的整数，第1个整数表示编号为i+ 1的点的父亲节点编号。1&lt;&#x3D;n&lt;&#x3D;10000</p><p>输出描述<br>一行一个整数，表示树上平衡点的个数。</p><p><strong>思路</strong><br>没写，无语的题目安排</p><h2 id="2023-03-12-拼多多机试"><a href="#2023-03-12-拼多多机试" class="headerlink" title="2023-03-12 拼多多机试"></a>2023-03-12 拼多多机试</h2><p>题目链接： <a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/465266427595948032?sourceSSR=search">2023暑期实习-笔试-拼多多-算法实习生</a><br>晚上的笔试，过了三道半</p><h3 id="第一题-多多的压缩编码II"><a href="#第一题-多多的压缩编码II" class="headerlink" title="第一题 多多的压缩编码II"></a>第一题 多多的压缩编码II</h3><p>还原压缩后的字符串<br>输入 10a1b1c<br>输出 aaaaaaaaaabc</p><p><strong>思路</strong><br>简单题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  string s;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>      <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;  <span class="hljs-comment">// 遇见数字</span><br>        number = number * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;                     <span class="hljs-comment">// 遇见字母</span><br>        ans += <span class="hljs-built_in">string</span>(number, c);  <span class="hljs-comment">// 添加number个字符c</span><br>        number = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题-多多的飞机大战游戏"><a href="#第二题-多多的飞机大战游戏" class="headerlink" title="第二题 多多的飞机大战游戏"></a>第二题 多多的飞机大战游戏</h3><p>多多最近下载了一款飞机大战的游戏，多多可以通过游戏上的不同发射按键来控制飞机发射子弹：<br>按下A键，飞机会发射出2枚子弹，每个子弹会对命中的敌人造成1点固定伤害，但不能作用于同个敌人。<br>按下B键，飞机会发射出1枚子弹，子弹会对命中的敌人造成巨额伤害并瞬间将其秒杀。</p><p>多多是个游戏高手，总是能操控子弹命中想要命中的敌人。这个游戏—共有 T 个关卡，消灭当前关卡全部敌人后，发射出去多余的子弹会消失，游戏会自动进入下一个关卡。<br>假设每个关卡都会在屏幕中同时出现N个敌人，这N个敌人所能承受的伤害也已经知道。多多想知道，每个关卡自己最少按几次发射按键就可以将敌人全部消灭。<br>输入描述<br>第一行输入一个固定数字T（1&lt;&#x3D;T&#x3D;1000）表示关卡的总数量，N（1&lt;&#x3D;N&lt;&#x3D;200）表示每个关卡出现的敌人数量。<br>接下来T行，每行有N个数字D1，D2，…，Dw（1&lt;&#x3D; Di &lt;&#x3D; 200）分别表示这N个敌人所能承受的伤害。</p><p>输出描述<br>结果共有N行，每行一个数字，分别表示对于这个关卡，最少按几次发射按键就可以将敌人全部消灭。</p><p><strong>思路</strong><br>承受伤害为1按A键，大于1则直接按B键</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> t, n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; t &gt;&gt; n) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++) &#123;<br>      <span class="hljs-type">int</span> di;<br>      unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;  <span class="hljs-comment">// 承受伤害敌人与相应数目</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        cin &gt;&gt; di;<br>        cnt[di]++;<br>      &#125;<br>      <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [damage, num] : cnt) &#123;<br>        <span class="hljs-keyword">if</span> (damage == <span class="hljs-number">1</span>) &#123;       <span class="hljs-comment">// 全部选择A键</span><br>          ans += (num + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 向上取整</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">// 全部选择B键</span><br>          ans += num;<br>        &#125;<br>      &#125;<br>      cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题-多多的团建计划"><a href="#第三题-多多的团建计划" class="headerlink" title="第三题 多多的团建计划"></a>第三题 多多的团建计划</h3><p>多多君准备了三个活动（分别编号A、B和C)，每个活动分别有人数上限以及每个人参加的费用。<br>参加团建的有N个人(分别编号1~N），每个人先投票选择若干个意向的活动，最终每个人只能参加其中一个。<br>多多君收集完投票结果后，发现如何安排成为了大难题：如何在满足所有人的意向的情况下，使得活动的总费用最少。<br>于是多多君找到了擅长编程的你，希望你能帮助找到个合理的团建计划。</p><p>输入描述<br>第一行，一个整数N（1&lt;&#x3D;N&lt;&#x3D;100），代表准备参加活动的人数。<br>接下来N行，每行一个由 “ABC” 组成的字符串，其中第i行表示第i个人投票了哪几个活动。输入保证字符串非空，且由大写的 “ABC” 字符组成。<br>最后三行，每行两个整数，分别表示三个活动的人数上限以及每个人参加的费用。<br>输出描述<br>输出共2行<br>如果能满足所有人的要求，第一行输出 “YES”，第二行输出最少的总费用。<br>如果不能满足所有人的要求，第一行输出 “NO”，第二行输出最多能满足多少人。</p><p><strong>思路</strong><br>本来想用贪心，但觉得贪心策略不一定对，就直接用dfs暴力枚举所有可能了，好像得了40-60分，太久了，忘了<br>但使用贪心虽然得不到满分，也有80-90分了，不能一昧地暴力回溯</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kINf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">vote</span><span class="hljs-params">(<span class="hljs-number">101</span>)</span></span>;  <span class="hljs-comment">// 每个人投票的活动</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;      <span class="hljs-comment">// 活动限制</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">money</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;      <span class="hljs-comment">// 活动费用</span><br><span class="hljs-type">int</span> min_total;             <span class="hljs-comment">// 最小总费用</span><br><span class="hljs-type">int</span> max_require;           <span class="hljs-comment">// 最多满足多少人</span><br><span class="hljs-type">bool</span> can_all_require;      <span class="hljs-comment">// 是否能满足</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_money</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; origin_limit, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; cur_limit)</span> </span>&#123;  <span class="hljs-comment">// 通过活动名额差值计算总费用</span><br>  <span class="hljs-type">int</span> total_money = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    total_money += (origin_limit[i] - cur_limit[i]) * money[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> total_money;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_all_zero</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; cur_limit)</span> </span>&#123; <span class="hljs-keyword">return</span> cur_limit[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; cur_limit[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; cur_limit[<span class="hljs-number">2</span>] == <span class="hljs-number">0</span>; &#125;  <span class="hljs-comment">// 活动是否全部参加完</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur_index, vector&lt;<span class="hljs-type">int</span>&gt; cur_limit, <span class="hljs-type">int</span> cur_require)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (cur_index &gt;= n || <span class="hljs-built_in">is_all_zero</span>(cur_limit)) &#123;               <span class="hljs-comment">// 当前下标越界或活动全部参加完</span><br>    <span class="hljs-keyword">if</span> (cur_require == n) &#123;                                     <span class="hljs-comment">// 已经满足所有人</span><br>      min_total = <span class="hljs-built_in">min</span>(min_total, <span class="hljs-built_in">get_money</span>(limit, cur_limit));  <span class="hljs-comment">// 计算最小总费用</span><br>      can_all_require = <span class="hljs-literal">true</span>;                                   <span class="hljs-comment">// 可以满足所有人</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      max_require = <span class="hljs-built_in">max</span>(max_require, cur_require);  <span class="hljs-comment">// 计算最多满足人数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (vote[cur_index].<span class="hljs-built_in">length</span>() == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果只有一个人（好像和下面的代码冗余了，不知道我当时怎么想的）</span><br>    <span class="hljs-type">char</span> c = vote[cur_index][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (cur_limit[c - <span class="hljs-string">&#x27;A&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 当前活动尚有名额</span><br>      cur_limit[c - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>      <span class="hljs-built_in">dfs</span>(cur_index + <span class="hljs-number">1</span>, cur_limit, cur_require + <span class="hljs-number">1</span>);<br>      cur_limit[c - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (can_all_require) &#123;  <span class="hljs-comment">// 已经存在满足所有人的选择，略过当前选择</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-built_in">dfs</span>(cur_index + <span class="hljs-number">1</span>, cur_limit, cur_require);  <span class="hljs-comment">// 不考虑该人</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : vote[cur_index]) &#123;  <span class="hljs-comment">// 依次选择各个活动</span><br>      <span class="hljs-keyword">if</span> (cur_limit[c - <span class="hljs-string">&#x27;A&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>        cur_limit[c - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>        <span class="hljs-built_in">dfs</span>(cur_index + <span class="hljs-number">1</span>, cur_limit, cur_require + <span class="hljs-number">1</span>);<br>        cur_limit[c - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (can_all_require) &#123;  <span class="hljs-comment">// 已经存在满足所有人的选择，略过当前选择</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(cur_index + <span class="hljs-number">1</span>, cur_limit, cur_require);  <span class="hljs-comment">// 不考虑该人</span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; vote[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>      cin &gt;&gt; limit[i] &gt;&gt; money[i];<br>    &#125;<br><br>    min_total = kINf;<br>    max_require = <span class="hljs-number">0</span>;<br>    can_all_require = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, limit, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (min_total == kINf) &#123;  <span class="hljs-comment">// 不能满足所有人</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl &lt;&lt; max_require &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 可以满足所有人</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl &lt;&lt; min_total &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四题-多多的餐厅客流量"><a href="#第四题-多多的餐厅客流量" class="headerlink" title="第四题 多多的餐厅客流量"></a>第四题 多多的餐厅客流量</h3><p>多多君开了一家自助餐厅，为了更好地管理库存，多多君每天需要对之前的客流量数据进行分析，并根据客流量的平均数和中位数来制定合理的备货策略。<br>输入描述<br>第一行一个整数N,表示餐厅营业总天数(0&lt;n&lt;&#x3D;200,000),&lt; p&#x3D;””&gt;&lt;&#x2F;n&lt;&#x3D;200,000),&lt;&gt;<br>第二行共N个整数,分别表示第i天的客流量R:(0&#x3D; R:1, 000, 000)。</p><p>输出描述<br>输出共两行：<br>第一行长度为N，其中第i个值表示前i天客流量的平均值；第二行长度为N，其中第i个值表示前i天客流量的中位数。<br>一共有N天，每天的客流量为 Ri，求第1天到第i天的平均数和中位数，结果四舍五入保留整数。</p><p><strong>思路</strong><br>没啥思路，就用插入排序过了，标准方法是<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetInterge</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;  <span class="hljs-comment">// 四舍五入</span><br>  <span class="hljs-type">int</span> n = d;<br>  <span class="hljs-type">double</span> test = n + <span class="hljs-number">0.5</span>;<br>  <span class="hljs-keyword">if</span> (d &gt;= test) &#123;<br>    <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> val)</span> </span>&#123;  <span class="hljs-comment">// 借助二分查找实现插入排序</span><br>  <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">upper_bound</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), val);<br>  vec.<span class="hljs-built_in">emplace</span>(iter, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">avg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mid</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-type">int</span> r;<br>      cin &gt;&gt; r;<br>      sum += r;<br>      avg[i] = <span class="hljs-built_in">GetInterge</span>(sum / i);  <span class="hljs-comment">// 求平均值</span><br>      <span class="hljs-built_in">InsertSort</span>(vec, r);<br>      <span class="hljs-type">double</span> tmp = vec[i / <span class="hljs-number">2</span>] + vec[(i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>      mid[i] = <span class="hljs-built_in">GetInterge</span>(tmp / <span class="hljs-number">2</span>);  <span class="hljs-comment">// 求中位数</span><br>    &#125;<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      cout &lt;&lt; avg[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      cout &lt;&lt; mid[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2023-3-15-阿里机试"><a href="#2023-3-15-阿里机试" class="headerlink" title="2023-3-15 阿里机试"></a>2023-3-15 阿里机试</h2><p>题目链接: <a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/465657292063506432?sourceSSR=search">大厂真题|3月15日阿里春招笔试三道题</a><br>晚上的笔试，七道单选，八道多选，三道编程题，编程题过了2道半，不能使用本地IDE，故没当时的代码（临结束的时候应该把所有的代码拷贝到剪切板的）</p><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><p><img src="https://img-blog.csdnimg.cn/ece0fb30ca8a459ca565b6ef81b16b67.png" srcset="/img/loading.gif" lazyload><br><strong>思路</strong><br>满二叉树，首先根据数组构建二叉树，而后寻找根节点，最后递归求解满二叉树，仅当两个子树皆为满二叉树且节点数目相同时该树为满二叉树</p><p><strong>按记忆打的，不一定对</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>  TreeNode* left;<br>  TreeNode* right;<br>  <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">using</span> Result = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt;;  <span class="hljs-comment">// 节点数量-是否为满二叉树</span><br><br><span class="hljs-function">Result <span class="hljs-title">GetNodeInfo</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span>&amp; full_node_num)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 空节点</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>&#125;;<br>  &#125;<br>  Result left_info = <span class="hljs-built_in">GetNodeInfo</span>(node-&gt;left, full_node_num);<br>  Result right_info = <span class="hljs-built_in">GetNodeInfo</span>(node-&gt;right, full_node_num);<br>  <span class="hljs-type">bool</span> is_full = (left_info.first == right_info.first) &amp;&amp; left_info.second &amp;&amp; right_info.second;  <span class="hljs-comment">// 两个子节点均为满二叉树且节点数目一致</span><br>  <span class="hljs-type">int</span> nodes = left_info.first + right_info.first + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (is_full) &#123;  <span class="hljs-comment">// 满二叉树节点加一</span><br>    full_node_num++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;nodes, is_full&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-function">vector&lt;TreeNode&gt; <span class="hljs-title">tree_node</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// 树节点</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">appear</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 节点是否出现在输入中</span><br>    <span class="hljs-comment">// 构建二叉树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-type">int</span> x, y;<br>      cin &gt;&gt; x &gt;&gt; y;<br>      <span class="hljs-keyword">if</span> (x != <span class="hljs-number">-1</span>) &#123;<br>        tree_node[i].left = &amp;tree_node[x];<br>        appear[x] = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (y != <span class="hljs-number">-1</span>) &#123;<br>        tree_node[i].right = &amp;tree_node[y];<br>        appear[y] = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 寻找根节点（未出现的节点）</span><br>    <span class="hljs-type">int</span> root = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!appear[i]) &#123;<br>        root = i;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计算满二叉树节点数目</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">GetNodeInfo</span>(&amp;tree_node[root], ans);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">2 3</span><br><span class="hljs-comment">4 5</span><br><span class="hljs-comment">-1 -1</span><br><span class="hljs-comment">-1 -1</span><br><span class="hljs-comment">-1 -1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><p><img src="https://img-blog.csdnimg.cn/41f98b906d674530a62e7765ce44652b.png" srcset="/img/loading.gif" lazyload><br>三个数最大值减最小值&#x3D;1，使用map记录数组与出现次数，对每个数字处理number与number+1的次数问题，注意结果可能超过int表示范围，需用long long存储</p><p><strong>按记忆打的，不一定对</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    map&lt;<span class="hljs-type">int</span>, ll&gt; ma;  <span class="hljs-comment">// 数字-出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-type">int</span> x;<br>      cin &gt;&gt; x;<br>      ma[x]++;<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [number, times] : ma) &#123;<br>      <span class="hljs-keyword">if</span> (ma.<span class="hljs-built_in">count</span>(number + <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 考虑number-number+1的组合</span><br>        ll another_times = ma[number + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (times &gt; <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 选择两个number 一个number+1</span><br>          ans += times * (times - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * another_times;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (another_times &gt; <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 选择两个number+1 一个number</span><br>          ans += another_times * (another_times - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * times;<br>        &#125;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><p><img src="https://img-blog.csdnimg.cn/405182b5cb58423a9901ffb729eb12ff.png" srcset="/img/loading.gif" lazyload><br><strong>思路</strong><br>由于是第三题，所以我默认它很难，我就直接使用暴力回溯写了一遍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">数组排序<br>dfs:<br>	<span class="hljs-number">0</span>: 达到终止条件，计算极差<br>	<span class="hljs-number">1</span>: 将数组首部数据乘<span class="hljs-number">2</span><br>	<span class="hljs-number">2</span>: dfs<br>	<span class="hljs-number">3</span>: 还原数组<br>	<span class="hljs-number">4</span>: 将数组尾部数据除<span class="hljs-number">2</span><br>	<span class="hljs-number">5</span>: dfs<br>	<span class="hljs-number">6</span>: 还原数组<br></code></pre></td></tr></table></figure><p>细想一下可以知道，这根本不需要dfs，只需要for循环即可，不过我养成了思维定式，第三题一律暴力回溯</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">前面i个数据乘<span class="hljs-number">2</span>，后面k-i个数据除<span class="hljs-number">2</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;i++)&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>		首部数据乘<span class="hljs-number">2</span><br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;k-i;j++)&#123;<br>		尾部数据除<span class="hljs-number">2</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外我使用全排列写了一遍，不再使用以上的策略，直接所有情况枚举一遍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;vec.<span class="hljs-built_in">size</span>();i++)&#123;<br>	<span class="hljs-built_in">swap</span>(vec[i],vec[start];<br>	当前数字乘<span class="hljs-number">2</span><br>	dfs<br>	还原数字<br>	当前数字除<span class="hljs-number">2</span><br>	dfs<br>	还原数字<br>	<span class="hljs-built_in">swap</span>(vec[i],vec[start];<br>&#125;<br></code></pre></td></tr></table></figure><p>最终我的解法都以超时结束，不知道用for循环实现可以得多少分</p><h2 id="2023-3-16-蚂蚁机试"><a href="#2023-3-16-蚂蚁机试" class="headerlink" title="2023-3-16 蚂蚁机试"></a>2023-3-16 蚂蚁机试</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/465980489178836992?sourceSSR=search">「技术笔试」蚂蚁金服 2023-03-16</a><br>最终得分2.3分，第三题写了40分钟只得了30分，一直没找到bug</p><h3 id="第一题-整数抽取"><a href="#第一题-整数抽取" class="headerlink" title="第一题 整数抽取"></a>第一题 整数抽取</h3><p>1e14 范围以内的一个正整数，将其每一数位上的奇数和偶数分别抽取出来组成两个新的数字，求这两差的绝对值。<br><strong>思路</strong><br>先将数字压入栈，然后计算奇数 偶数大小，上面的题解使用的是字符串存储数字，省去了压栈这一步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">GetValue</span><span class="hljs-params">(stack&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;  <span class="hljs-comment">// 计算数字大小</span><br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>    ans = ans * <span class="hljs-number">10</span> + s.<span class="hljs-built_in">top</span>();<br>    s.<span class="hljs-built_in">pop</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; one, two;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">int</span> num = n % <span class="hljs-number">10</span>;<br>      <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 偶数</span><br>        two.<span class="hljs-built_in">emplace</span>(num);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 奇数</span><br>        one.<span class="hljs-built_in">emplace</span>(num);<br>      &#125;<br>      n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">GetValue</span>(one) - <span class="hljs-built_in">GetValue</span>(two)) &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题-组装电脑"><a href="#第二题-组装电脑" class="headerlink" title="第二题 组装电脑"></a>第二题 组装电脑</h3><p>n 组零件，每组零件有若干种，每一种有一个价格和性能。你需要从每组里面选出一种零件，使得总价格不超过 x，并且性能总和最大。<br>n &lt;&#x3D; 40, 所有零件的种类数不超过 40，其他数值 1e9。<br><strong>思路</strong><br>首先简单判断一下是否能完成组装，不能就直接返回，能的话就使用dfs穷举所有可能，找到最大性能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;  <span class="hljs-comment">// 全部使用long long存储，避免溢出</span><br><span class="hljs-type">const</span> ll kInf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;pair&lt;ll, ll&gt;&gt;&gt;&amp; vec, ll cur_index, ll cur_x, ll cur_v, ll&amp; max_v)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (cur_index &gt;= vec.<span class="hljs-built_in">size</span>()) &#123;  <span class="hljs-comment">// 选完所有零件，计算最大性能</span><br>    max_v = <span class="hljs-built_in">max</span>(max_v, cur_v);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [a, v] : vec[cur_index]) &#123;<br>    <span class="hljs-keyword">if</span> (cur_x &gt;= a) &#123;  <span class="hljs-comment">// 选择可选的零件</span><br>      <span class="hljs-built_in">dfs</span>(vec, cur_index + <span class="hljs-number">1</span>, cur_x - a, cur_v + v, max_v);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n, x;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; x) &#123;<br>    vector&lt;vector&lt;pair&lt;ll, ll&gt;&gt;&gt; <span class="hljs-built_in">arr</span>(n);<br>    ll min_x = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 最小零件价格总和</span><br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      ll m, a, v;<br>      ll min_a = kInf;<br>      cin &gt;&gt; m;<br>      arr[i] = vector&lt;pair&lt;ll, ll&gt;&gt;(m);<br>      <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; arr[i][j].first;<br>        min_a = <span class="hljs-built_in">min</span>(min_a, arr[i][j].first);  <span class="hljs-comment">// 记录该类型零件最小价格</span><br>      &#125;<br>      <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; arr[i][j].second;<br>      &#125;<br>      min_x += min_a;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &lt; min_x) &#123;  <span class="hljs-comment">// 无法完成组装</span><br>      cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(arr, <span class="hljs-number">0</span>, x, <span class="hljs-number">0</span>, ans);  <span class="hljs-comment">// 计算最大零件价值和</span><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题-带传送阵的矩阵游离"><a href="#第三题-带传送阵的矩阵游离" class="headerlink" title="第三题 带传送阵的矩阵游离"></a>第三题 带传送阵的矩阵游离</h3><p>n 行 m 列的矩阵，每个位置上有一个元素。你可以上下左右行走，代价是前后两个位置元素值差的绝对值。另外，你最多可以使用一次传送阵（只能从一个数跳到另外一个相同的树），求从走上角走到右下角最少需要多少时间。<br>1 &lt;&#x3D; n, m &lt;&#x3D; 500, 1 &lt;&#x3D; aij &lt;&#x3D; 1e9。</p><p><strong>思路</strong><br>刚开始想了想，如果用dfs，应该能得30-60分，但当时时间也挺多的，就想完全通过。方法就是计算各点到起点的距离，计算各点到终点的距离，设使用传送阵的起始点为x，终点为y，最终的路径长度即为dist_form_start[x] + 0（传送阵代价） + dist_to_end[y]，可惜代码有bug，只得了30分，我觉得我思路是没问题的</p><p>以下为有bug的版本，先计算两个最短距离，然后使用传送计算最终距离</p><p><strong>额，好像优先队列没设置为小顶堆，有点尴尬，这样都能得30分，运气不错</strong><br>设置方式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 自带的比较函数</span><br>priority_queue&lt;TP, vector&lt;TP&gt;, greater&lt;TP&gt;&gt; q;<br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p1, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p2) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> p1.second &gt; p2.second; &#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">qu</span>(cmp);<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll kInf = <span class="hljs-number">0xfffffffffffff</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n, m;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>    vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">arr</span>(n, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m));<br>    unordered_map&lt;ll, vector&lt;pair&lt;ll, ll&gt;&gt;&gt; ma;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; arr[i][j];<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span> (ma.<span class="hljs-built_in">count</span>(arr[i][j]) == <span class="hljs-number">0</span>) &#123;<br>          vector&lt;pair&lt;ll, ll&gt;&gt; tmp;<br>          tmp.<span class="hljs-built_in">emplace_back</span>(i, j);<br>          ma[arr[i][j]] = tmp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          ma[arr[i][j]].<span class="hljs-built_in">emplace_back</span>(i, j);<br>        &#125;<br>      &#125;<br>    &#125;<br>    vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">dist1</span>(n, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m, kInf));<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visit1</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    priority_queue&lt;tuple&lt;ll, ll, ll&gt;&gt; qu;<br>    dist1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    qu.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [from_start, i, j] = qu.<span class="hljs-built_in">top</span>();<br>      qu.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">if</span> (visit1[i][j]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      visit1[i][j] = <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i + <span class="hljs-number">1</span>][j]);<br>        <span class="hljs-keyword">if</span> (dist1[i + <span class="hljs-number">1</span>][j] &gt; cur_dist) &#123;<br>          dist1[i + <span class="hljs-number">1</span>][j] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i + <span class="hljs-number">1</span>, j);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i - <span class="hljs-number">1</span>][j]);<br>        <span class="hljs-keyword">if</span> (dist1[i - <span class="hljs-number">1</span>][j] &gt; cur_dist) &#123;<br>          dist1[i - <span class="hljs-number">1</span>][j] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i - <span class="hljs-number">1</span>, j);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; m) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i][j + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (dist1[i][j + <span class="hljs-number">1</span>] &gt; cur_dist) &#123;<br>          dist1[i][j + <span class="hljs-number">1</span>] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i, j + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i][j - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (dist1[i][j - <span class="hljs-number">1</span>] &gt; cur_dist) &#123;<br>          dist1[i][j - <span class="hljs-number">1</span>] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i, j - <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">dist2</span>(n, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m, kInf));<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visit2</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    dist2[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    qu.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [from_start, i, j] = qu.<span class="hljs-built_in">top</span>();<br>      qu.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">if</span> (visit2[i][j]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      visit2[i][j] = <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i + <span class="hljs-number">1</span>][j]);<br>        <span class="hljs-keyword">if</span> (dist2[i + <span class="hljs-number">1</span>][j] &gt; cur_dist) &#123;<br>          dist2[i + <span class="hljs-number">1</span>][j] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i + <span class="hljs-number">1</span>, j);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i - <span class="hljs-number">1</span>][j]);<br>        <span class="hljs-keyword">if</span> (dist2[i - <span class="hljs-number">1</span>][j] &gt; cur_dist) &#123;<br>          dist2[i - <span class="hljs-number">1</span>][j] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i - <span class="hljs-number">1</span>, j);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; m) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i][j + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (dist2[i][j + <span class="hljs-number">1</span>] &gt; cur_dist) &#123;<br>          dist2[i][j + <span class="hljs-number">1</span>] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i, j + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>        ll cur_dist = from_start + <span class="hljs-built_in">abs</span>(arr[i][j] - arr[i][j - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (dist2[i][j - <span class="hljs-number">1</span>] &gt; cur_dist) &#123;<br>          dist2[i][j - <span class="hljs-number">1</span>] = cur_dist;<br>          qu.<span class="hljs-built_in">emplace</span>(cur_dist, i, j - <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    vector&lt;vector&lt;ll&gt;&gt; <span class="hljs-built_in">dist</span>(n, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m, kInf));<br>    ll min_dist = kInf;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">auto</span> vec = ma[arr[i][j]];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [xi, xj] : vec) &#123;<br>          <span class="hljs-keyword">if</span> (dist1[i][j] != kInf &amp;&amp; dist2[xi][xj] != kInf) &#123;<br>            dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist1[i][j] + dist2[xi][xj]);<br>          &#125;<br>        &#125;<br>        min_dist = <span class="hljs-built_in">min</span>(min_dist, dist[i][j]);<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; min_dist &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比之下，牛客网上的题解就简洁多了，多加一个维度k，对维度同样使用状态转移，更加通用的做法，并且在处理方向上，我还是用习惯的方法，对每个方向进行枚举，<strong>而题解中则使用dir数组进行统一处理</strong>，既方便又不容易出错，map赋值时我还对是否存在该值进行分类讨论，实际上是不需要的，如果不存在map会先设置默认值而后进行更新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    <span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>], ny = y + dir[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= n || ny &lt; <span class="hljs-number">0</span> || ny &gt;= m || v[nx][ny][z] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (d[nx][ny][z] &gt; dist + <span class="hljs-built_in">abs</span>(a[x][y] - a[nx][ny])) &#123;<br>        d[nx][ny][z] = dist + <span class="hljs-built_in">abs</span>(a[x][y] - a[nx][ny]);<br>        q.<span class="hljs-built_in">push</span>(&#123;d[nx][ny][z], nx, ny, z&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2023-03-19-米哈游机试"><a href="#2023-03-19-米哈游机试" class="headerlink" title="2023-03-19 米哈游机试"></a>2023-03-19 米哈游机试</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/467108267630534656">全网首发-真题分享|3月19日米哈游校招研发岗三道题</a><br>参考题解：<br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/467114902348374016?sourceSSR=search">米哈游笔试题目思路（客户端卷）</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/467094961188532224?sourceSSR=search">米哈游后端笔试题解</a></p><h3 id="第一题-2"><a href="#第一题-2" class="headerlink" title="第一题"></a>第一题</h3><p>米小游拿到了一个矩阵，矩阵上有一格有一个颜色，为红色( R )。绿色( G )和蓝色( B )这三种颜色的一种。然而米小游是蓝绿色盲，她无法分游蓝色和绿色，所以在米小游眼里看来，这个矩阵只有两种颜色，因为蓝色和绿色在她眼里是一种颜色。米小游会把相同颜色的部分看成是一个连通块。请注意，这里的连通划是上下左右四连通的。由于色盲的原因，米小游自己看到的连通块数量可能比真实的连通块数量少。你可以帮米小游计算连通块少了多少吗？</p><p><strong>思路</strong><br>看到连通分量，就自然而然想用并查集实现，实际上只需要连接两个方向的节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;  <span class="hljs-comment">// 并查集类</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> size) &#123;  <span class="hljs-comment">// 初始化</span><br>    data_ = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      data_[i] = i;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;  <span class="hljs-comment">// 查找</span><br>    <span class="hljs-keyword">if</span> (data_[k] == k) &#123;<br>      <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    data_[k] = <span class="hljs-built_in">Find</span>(data_[k]);<br>    <span class="hljs-keyword">return</span> data_[k];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;  <span class="hljs-comment">// 合并</span><br>    <span class="hljs-type">int</span> rootp = <span class="hljs-built_in">Find</span>(p);<br>    <span class="hljs-type">int</span> rootq = <span class="hljs-built_in">Find</span>(q);<br>    data_[rootp] = rootq;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 连通分量数目</span><br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data_.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (data_[i] == i) &#123;<br>        size++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-type">int</span>&gt; data_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m;<br>  <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">arr</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(m));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; arr[i][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 真实情况连通数量</span><br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf1</span><span class="hljs-params">(n * m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>          <span class="hljs-type">int</span> nx = i + dir[k][<span class="hljs-number">0</span>];<br>          <span class="hljs-type">int</span> ny = j + dir[k][<span class="hljs-number">1</span>];<br>          <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m &amp;&amp; arr[i][j] == arr[nx][ny]) &#123;<br>            uf1.<span class="hljs-built_in">Union</span>(i * m + j, nx * m + ny);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> size1 = uf1.<span class="hljs-built_in">Size</span>();<br>    <span class="hljs-comment">// 视角连通分量数量</span><br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf2</span><span class="hljs-params">(n * m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>          <span class="hljs-type">int</span> nx = i + dir[k][<span class="hljs-number">0</span>];<br>          <span class="hljs-type">int</span> ny = j + dir[k][<span class="hljs-number">1</span>];<br>          <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m &amp;&amp; ((arr[i][j] == <span class="hljs-string">&#x27;R&#x27;</span>) == (arr[nx][ny] == <span class="hljs-string">&#x27;R&#x27;</span>))) &#123;<br>            uf2.<span class="hljs-built_in">Union</span>(i * m + j, nx * m + ny);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> size2 = uf2.<span class="hljs-built_in">Size</span>();<br>    cout &lt;&lt; size1 - size2 &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dfs的解法如下，比并查集少一点代码，写起来快点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; vec, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visit, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">char</span> target, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>  visit[x][y] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 设置成已访问</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;  <span class="hljs-comment">// 遍历四个方向</span><br>    <span class="hljs-type">int</span> nx = x + dir[k][<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> ny = y + dir[k][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m &amp;&amp; visit[nx][ny] == <span class="hljs-literal">false</span> &amp;&amp; vec[nx][ny] == target) &#123;  <span class="hljs-comment">// 坐标合法，未访问过，为目标值</span><br>      <span class="hljs-built_in">dfs</span>(vec, visit, nx, ny, target, n, m);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">arr</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(m));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        cin &gt;&gt; arr[i][j];<br>      &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visit1</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> cnt1 = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 连通分量数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span> (visit1[i][j] == <span class="hljs-literal">false</span>) &#123;<br>          cnt1++;<br>          <span class="hljs-built_in">dfs</span>(arr, visit1, i, j, arr[i][j], n, m);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将蓝色改成绿色</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>          arr[i][j] = <span class="hljs-string">&#x27;G&#x27;</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visit2</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> cnt2 = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 连通分量数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">if</span> (visit2[i][j] == <span class="hljs-literal">false</span>) &#123;<br>          cnt2++;<br>          <span class="hljs-built_in">dfs</span>(arr, visit2, i, j, arr[i][j], n, m);<br>        &#125;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; cnt1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; cnt2 &lt;&lt; endl;<br>    cout &lt;&lt; cnt1 - cnt2 &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题-2"><a href="#第二题-2" class="headerlink" title="第二题"></a>第二题</h3><p>米小游拿到了一个字符串 s 。她可以进行任意次以下两种操作：<br>1 删除 s 的一个 “mhy” 子序列。<br>2 添加一个 “mhy” 子序列在 s 上。<br>例如，给定 s 为 “mhbdy” ，米小游进行一次操作后可以使 s 变成 “bd” ，或者变成 “mhmbhdyy” 。<br>米小游想知道，经过若干次操作后 s 是否可以变成 t ？<br>注：子序列在原串中的顺序也是从左到右，但可以不连续。</p><p><strong>思路</strong><br>觉得写不出来，就直接进行骗分策略，看了别人的题解才发现解法很简单，最重要的是想到mhy三个字母的序列不重要<br><img src="https://img-blog.csdnimg.cn/aff0c420726e4a3eaac89d664d1e74ee.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Check</span><span class="hljs-params">(string&amp; s, string&amp; t)</span> </span>&#123;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num1</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num2</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-comment">// 统计字符串各字母次数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>    num1[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t) &#123;<br>    num2[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>  &#125;<br>  <span class="hljs-type">int</span> m, h, y;  <span class="hljs-comment">// 记录mhy字母次数差值</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-string">&#x27;m&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>      m = num1[i] - num2[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-string">&#x27;h&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>      h = num1[i] - num2[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-string">&#x27;y&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>      y = num1[i] - num2[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num1[i] != num2[i]) &#123;  <span class="hljs-comment">// 其他字母数量不相等，不能转换</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (m == h) &amp;&amp; (h == y);  <span class="hljs-comment">// 差值相等则可以进行转换</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> q;<br>  cin &gt;&gt; q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>    string s, t;<br>    cin &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Check</span>(s, t)) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题-2"><a href="#第三题-2" class="headerlink" title="第三题"></a>第三题</h3><p><img src="https://img-blog.csdnimg.cn/b91f4f8298d745d0a31fdf2aca9bb826.png" srcset="/img/loading.gif" lazyload><br><strong>思路：</strong><br>我的思路与题解一样，只不过我少了倍数预处理的一步，直接两层for循环找到因数更新dp数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMax = <span class="hljs-number">1e6</span> + <span class="hljs-number">1</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(kMax, <span class="hljs-literal">false</span>)</span></span>;   <span class="hljs-comment">// visit[i]: 数字i是否出现</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">factor</span>(kMax);  <span class="hljs-comment">// factor[i]: i的各个因数</span><br><span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dp</span><span class="hljs-params">(kMax, <span class="hljs-number">0</span>)</span></span>;            <span class="hljs-comment">// dp[i]: 以i结尾的数字集合数目</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; a[i];<br>    visit[a[i]] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数字排序</span><br>  <span class="hljs-type">int</span> max_n = a[n - <span class="hljs-number">1</span>];      <span class="hljs-comment">// 最大数字</span><br>  <span class="hljs-comment">// 预处理倍数关系</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max_n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= max_n; j += i) &#123;<br>      <span class="hljs-keyword">if</span> (visit[j] == <span class="hljs-literal">true</span>) &#123;<br>        factor[j].<span class="hljs-built_in">emplace_back</span>(i);  <span class="hljs-comment">// i为j的因数</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : factor[a[i]]) &#123;<br>      dp[a[i]] += dp[num] + <span class="hljs-number">1</span>;  <span class="hljs-comment">// a[i]可以和num的数字集合全部组合一遍，最后加上&#123;num,a[i]&#125;</span><br>    &#125;<br>    dp[a[i]] %= mod;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    ans += dp[a[i]];<br>  &#125;<br>  ans %= mod;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2023-03-23-腾讯音乐笔试"><a href="#2023-03-23-腾讯音乐笔试" class="headerlink" title="2023-03-23 腾讯音乐笔试"></a>2023-03-23 腾讯音乐笔试</h2><p>题目：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/469584031672246272?sourceSSR=search">3.23 腾讯音乐 暑期 实习 技术类 笔试</a><br>中途肚子痛，提前半小时交卷了，第一题写了一半，第二题dfs骗了几十分，第三题签到</p><p><strong>笔试或面试前千万别吃坏肚子</strong></p><h3 id="第一题-3"><a href="#第一题-3" class="headerlink" title="第一题"></a>第一题</h3><p><img src="https://img-blog.csdnimg.cn/bde52599e53443259a8ce2811710c857.png" srcset="/img/loading.gif" lazyload><br>这个问题可以分解成两个子问题：<br>1 通过层序遍历得到奇偶层节点个数<br>2 假设奇数层节点个数为k，解决是否能从[1,n]中选择k个数，总和为target问题</p><p>若1-n总和为偶数，则target为sum&#x2F;2，若为奇数，则target为sum&#x2F;2或sum&#x2F;2+1</p><p>代码片段如下：（不一定对）<br>第一步：层序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">fun</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>  queue&lt;Info&gt; qu;<br>  <span class="hljs-type">int</span> one = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 奇数节点数</span><br>  <span class="hljs-type">int</span> two = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 偶数节点数</span><br>  stack&lt;TreeNode*&gt; one_stack;  <span class="hljs-comment">// 奇数节点栈</span><br>  stack&lt;TreeNode*&gt; two_stack;  <span class="hljs-comment">// 偶数节点栈</span><br>  qu.<span class="hljs-built_in">emplace</span>(root, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>    Info info = qu.<span class="hljs-built_in">front</span>();<br>    TreeNode* node = info.first;<br>    <span class="hljs-type">int</span> level = info.second;<br>    qu.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>      one++;<br>      one_stack.<span class="hljs-built_in">emplace</span>(node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      two++;<br>      two_stack.<span class="hljs-built_in">emplace</span>(node);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 将左子树节点压入队列</span><br>      qu.<span class="hljs-built_in">emplace</span>(node-&gt;left, level + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 将右子树节点压入队列</span><br>      qu.<span class="hljs-built_in">emplace</span>(node-&gt;right, level + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步：选择k个数总和为target<br>双指针法求得可能结果<br><img src="https://img-blog.csdnimg.cn/d3cb5ea22bf848399175e09e3bd085dc.png" srcset="/img/loading.gif" lazyload><br>刚开始左区域最大，右区域为空，此时sum最小，而后一直将left right向左移动，增大sum，直至sum&gt;target</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">FindSuitNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// [1,n]中选择k个数，总和为target</span><br>  <span class="hljs-comment">// 等差数列求和公式：Sn = n * (a1 + an) / 2</span><br>  <span class="hljs-type">int</span> min_sum = k * (<span class="hljs-number">1</span> + k) / <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> max_sum = k * (n - k + <span class="hljs-number">1</span> + n) / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (target &lt; min_sum || target &gt; max_sum) &#123;<br>    <span class="hljs-comment">// printf(&quot;target %d: no suit number\n&quot;, target);</span><br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>  <span class="hljs-comment">// 如果target属于[min_sum,max_sum]，则target一定能取到</span><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">seq</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    seq[i] = i + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 最后数据构成：0...left  extra_num right+1...n-1</span><br>  <span class="hljs-type">int</span> left = k - <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> sum = min_sum;<br>  <span class="hljs-type">int</span> extra_num = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> sub = seq[right] - seq[left];<br>    <span class="hljs-keyword">if</span> (sum + sub &lt; target) &#123;  <span class="hljs-comment">// 小于目标值，将右侧元素加入集合</span><br>      left--;<br>      right--;<br>      sum += sub;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      extra_num = seq[left] + target - sum;<br>      left--;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= left; i++) &#123;<br>    ans.<span class="hljs-built_in">emplace_back</span>(seq[i]);<br>  &#125;<br><br>  ans.<span class="hljs-built_in">emplace_back</span>(extra_num);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = right + <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    ans.<span class="hljs-built_in">emplace_back</span>(seq[i]);<br>  &#125;<br>  <span class="hljs-comment">// 校验结果</span><br>  <span class="hljs-type">int</span> result = <span class="hljs-built_in">accumulate</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (result != target) &#123;  <span class="hljs-comment">// 总和不为target</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;target: %d result: %d\n&quot;</span>, target, result);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() != k) &#123;  <span class="hljs-comment">// 数量错误</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong ans size: %d&quot;</span>, ans.<span class="hljs-built_in">size</span>());<br>  &#125;<br>  set&lt;<span class="hljs-type">int</span>&gt; se;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : ans) &#123;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1</span> || num &gt; n) &#123;  <span class="hljs-comment">// 数字超出范围</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong value: %d\n&quot;</span>, num);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (se.<span class="hljs-built_in">count</span>(num) &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 重复数字</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;repeat value: %d\n&quot;</span>, num);<br>    &#125;<br>    se.<span class="hljs-built_in">emplace</span>(num);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>; j++) &#123;<br>      <span class="hljs-built_in">FindSuitNumber</span>(<span class="hljs-number">100</span>, j, i);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题-3"><a href="#第二题-3" class="headerlink" title="第二题"></a>第二题</h3><p><img src="https://img-blog.csdnimg.cn/ca7533316384473db93d93c5c566525e.png" srcset="/img/loading.gif" lazyload><br>算法实现中为避免函数参数过多，可以将公有的数据结构放在类成员中，且没必要遵循命名规范（类成员名后加_），类成员的设置应该在具体实现前想好。</p><p>第二题看别人说是最大值最小化问题，使用二分+贪心的方法解决，但没看到啥具体实现<br>（二分答案，贪心验证答案是否符合，符合就再缩小一点答案，不符合就扩大一点 ）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;  <span class="hljs-comment">// 计算str[str,end)的metric，种类x长度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;           <span class="hljs-comment">// 字符出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>      num[i] = char_num_[end][i] - char_num_[start][i];<br>    &#125;<br>    <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 不同字符数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (num[i] &gt; <span class="hljs-number">0</span>) &#123;<br>        diff++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> diff * (end - start);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">computeMaxValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> max_value = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 计算最大metric</span><br>    <span class="hljs-comment">// 分割位置集合[0,seq0,seq1,..seqk-1,length]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k_; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i == k_ - <span class="hljs-number">1</span>) &#123;<br>        max_value = <span class="hljs-built_in">max</span>(max_value, <span class="hljs-built_in">getValue</span>(seq_[i], length_));  <span class="hljs-comment">// 最后一个切割位置，与数组末尾配对</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        max_value = <span class="hljs-built_in">max</span>(max_value, <span class="hljs-built_in">getValue</span>(seq_[i], seq_[i + <span class="hljs-number">1</span>]));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_value;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span>&amp; max_value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index == k_) &#123;<br>      max_value = <span class="hljs-built_in">min</span>(max_value, <span class="hljs-built_in">computeMaxValue</span>());  <span class="hljs-comment">// 记录最小的最大metric</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; seq_.<span class="hljs-built_in">size</span>(); i++) &#123;  <span class="hljs-comment">// 全排列，但seq[i]&gt;seq[i-1]</span><br>      <span class="hljs-keyword">if</span> (seq_[i] &gt; seq_[index - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-built_in">swap</span>(seq_[index], seq_[i]);<br>        <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, max_value);<br>        <span class="hljs-built_in">swap</span>(seq_[index], seq_[i]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    k_ = k;<br>    length_ = str.<span class="hljs-built_in">length</span>();<br>    char_num_ = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(str.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>));  <span class="hljs-comment">// char_num_[i]表示s[i]前的各字符出现次数，用于快速计算区间字符种类</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">length</span>(); i++) &#123;<br>      char_num_[i + <span class="hljs-number">1</span>] = char_num_[i];<br>      char_num_[i + <span class="hljs-number">1</span>][str[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">getValue</span>(<span class="hljs-number">0</span>, str.<span class="hljs-built_in">length</span>());  <span class="hljs-comment">// 不需要分割，直接计算metric</span><br>    &#125;<br>    seq_ = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(str.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">length</span>(); i++) &#123;<br>      seq_[i] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, ans);  <span class="hljs-comment">// 第一位一定为0，数组开始索引为1</span><br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; char_num_;<br>  vector&lt;<span class="hljs-type">int</span>&gt; seq_;<br>  <span class="hljs-type">int</span> k_;<br>  <span class="hljs-type">int</span> length_;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Solution solution;<br>  solution.<span class="hljs-built_in">getMaxValue</span>(<span class="hljs-string">&quot;ababbbb&quot;</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题-3"><a href="#第三题-3" class="headerlink" title="第三题"></a>第三题</h3><p>签到题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCnt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>      <span class="hljs-type">int</span> sub = <span class="hljs-built_in">abs</span>(str[i] - str[i + <span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">if</span> (sub == <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span> || sub == <span class="hljs-number">0</span>) &#123;<br>        ans++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2023-03-26-腾讯笔试"><a href="#2023-03-26-腾讯笔试" class="headerlink" title="2023-03-26 腾讯笔试"></a>2023-03-26 腾讯笔试</h2><p>题目：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/feed/main/detail/0a0c1366f1b74df8844fc31b2681d13f?sourceSSR=search">腾讯笔试记录0326（研发）</a><br>就写出了第一第二题，第三题题目有点问题，导致我写了40分钟没得啥分，一直没理解最后一个样例是怎么来的，第四第五题一看就是我不会的题目，随便写了写</p><h3 id="第一题-链表操作"><a href="#第一题-链表操作" class="headerlink" title="第一题 链表操作"></a>第一题 链表操作</h3><p>链表中相邻节点两两一组，然后相邻两组之间进行交换<br>类似的题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a><br>直接将链表节点指针存入数组，便于理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-function">ListNode <span class="hljs-title">virt_head</span><span class="hljs-params">(<span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">// 虚拟头节点</span><br>    virt_head.next = head;<br>    vector&lt;ListNode*&gt; arr;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>      arr.<span class="hljs-built_in">emplace_back</span>(cur);<br>      cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-type">int</span> num = arr.<span class="hljs-built_in">size</span>();<br>    ListNode* prev = &amp;virt_head;  <span class="hljs-comment">// 待处理组的前一个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">3</span> &lt; num; i += <span class="hljs-number">4</span>) &#123;<br>      prev-&gt;next = arr[i + <span class="hljs-number">2</span>];              <span class="hljs-comment">// 指向第二组的头节点</span><br>      arr[i + <span class="hljs-number">1</span>]-&gt;next = arr[i + <span class="hljs-number">3</span>]-&gt;next;  <span class="hljs-comment">// 指向第二组后一个节点</span><br>      prev = arr[i + <span class="hljs-number">1</span>];                    <span class="hljs-comment">// 更新prev节点</span><br>      arr[i + <span class="hljs-number">3</span>]-&gt;next = arr[i];            <span class="hljs-comment">// 更新第二组的next为第一组头节点</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">4</span> == <span class="hljs-number">3</span>) &#123;  <span class="hljs-comment">// 剩下3个节点，特殊处理</span><br>      prev-&gt;next = arr[num - <span class="hljs-number">1</span>];<br>      arr[num - <span class="hljs-number">2</span>]-&gt;next = arr[num - <span class="hljs-number">1</span>]-&gt;next;<br>      arr[num - <span class="hljs-number">1</span>]-&gt;next = arr[num - <span class="hljs-number">3</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> virt_head.next;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="第二题-重组字符串"><a href="#第二题-重组字符串" class="headerlink" title="第二题 重组字符串"></a>第二题 重组字符串</h3><p>给定N个字符串，每个字符串全部由小写字母组成，且每个字符串的长度最多为8,请你断有多少重组字符串，重组字符串有以下规则：1.从每个字符串里面都抽取1个字母组成。2.新字符串不能有2个相同的字母。请问总共能组成多少个重组字符串。</p><p>字符串长度比较小，用dfs暴力枚举即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> index, string cur_str, set&lt;string&gt;&amp; res)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (index == strs.<span class="hljs-built_in">size</span>()) &#123;  <span class="hljs-comment">// 加入结果集合</span><br>    res.<span class="hljs-built_in">emplace</span>(cur_str);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : strs[index]) &#123;<br>    <span class="hljs-keyword">if</span> (cur_str.<span class="hljs-built_in">find</span>(c) == string::npos) &#123;  <span class="hljs-comment">// 无重复字母</span><br>      cur_str.<span class="hljs-built_in">push_back</span>(c);                 <span class="hljs-comment">// 加入字符串</span><br>      <span class="hljs-built_in">dfs</span>(strs, index + <span class="hljs-number">1</span>, cur_str, res);   <span class="hljs-comment">// 遍历下一个字符串</span><br>      cur_str.<span class="hljs-built_in">pop_back</span>();                   <span class="hljs-comment">// 还原</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">strs</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; strs[i];<br>  &#125;<br>  set&lt;string&gt; ans;  <span class="hljs-comment">// 使用set去重</span><br>  <span class="hljs-built_in">dfs</span>(strs, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, ans);<br>  cout &lt;&lt; ans.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题-最小权值排列数组"><a href="#第三题-最小权值排列数组" class="headerlink" title="第三题 最小权值排列数组"></a>第三题 最小权值排列数组</h3><p>给定2个整数数组A,B,数组长度都为N,数组B为权值数组，权值数据范国为[0,2],请你构造一个数组C,满足以下条件：<br>1,长应为N<br>2.数组元素范国为[1,N],且元素值不能更复，即为N的一个排列<br>3.如果数组下标i&lt;j，且有B[i]&gt;B[j],那么一定要保证C[i]&gt;C[j]<br>4数组C与数组A每个元素之差的和的绝对值最小.</p><p>按理来说样例的答案应该是98，但样例是104，一直想不出来为什么<br><img src="https://img-blog.csdnimg.cn/d02540c53975475791da05a7098afa9d.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMax = <span class="hljs-number">2</span> * <span class="hljs-number">10e5</span> + <span class="hljs-number">1</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(kMax)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">B</span><span class="hljs-params">(kMax)</span></span>;<br><span class="hljs-type">int</span> n;<br>ll ans = <span class="hljs-number">0xffffffffffff</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;ll&gt;&amp; seq, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> one_min, <span class="hljs-type">int</span> two_min)</span> </span>&#123;  <span class="hljs-comment">// one_min 前面1位置的最小值 two_min 前面2位置的最小值</span><br>  <span class="hljs-keyword">if</span> (index == n) &#123;<br>    ll array_abs_sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 差值的绝对值之和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      array_abs_sum += <span class="hljs-built_in">abs</span>(seq[i] - A[i]);<br>    &#125;<br>    ans = <span class="hljs-built_in">min</span>(ans, array_abs_sum);<br>    <span class="hljs-comment">// 打印样例序列</span><br>    <span class="hljs-keyword">if</span> (array_abs_sum == <span class="hljs-number">98</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : seq) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>      cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (B[index] == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (seq[i] &lt; one_min &amp;&amp; seq[i] &lt; two_min) &#123;  <span class="hljs-comment">// 需小于1最小值与2最小值</span><br>        <span class="hljs-built_in">swap</span>(seq[i], seq[index]);<br>        <span class="hljs-built_in">dfs</span>(seq, index + <span class="hljs-number">1</span>, one_min, two_min);<br>        <span class="hljs-built_in">swap</span>(seq[i], seq[index]);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (B[index] == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (seq[i] &lt; two_min) &#123;  <span class="hljs-comment">// 需小于2最小值</span><br>        <span class="hljs-type">int</span> new_one_min = <span class="hljs-built_in">min</span>&lt;ll&gt;(seq[i], one_min);<br>        <span class="hljs-built_in">swap</span>(seq[i], seq[index]);<br>        <span class="hljs-built_in">dfs</span>(seq, index + <span class="hljs-number">1</span>, new_one_min, two_min);  <span class="hljs-comment">// 更新1最小值</span><br>        <span class="hljs-built_in">swap</span>(seq[i], seq[index]);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">int</span> new_two_min = <span class="hljs-built_in">min</span>&lt;ll&gt;(seq[i], two_min);<br>      <span class="hljs-built_in">swap</span>(seq[i], seq[index]);<br>      <span class="hljs-built_in">dfs</span>(seq, index + <span class="hljs-number">1</span>, one_min, new_two_min);  <span class="hljs-comment">// 更新2最小值</span><br>      <span class="hljs-built_in">swap</span>(seq[i], seq[index]);<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; A[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; B[i];<br>  &#125;<br>  <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">seq</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-comment">// [1,n]序列</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    seq[i] = i + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">dfs</span>(seq, <span class="hljs-number">0</span>, kMax + <span class="hljs-number">1</span>, kMax + <span class="hljs-number">1</span>);<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">100 2 3 1 5 6</span><br><span class="hljs-comment">0 1 2 0 2 1</span><br><span class="hljs-comment">样例答案：104</span><br><span class="hljs-comment">我的答案：98</span><br><span class="hljs-comment">6 2 4 1 5 3</span><br><span class="hljs-comment">98</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="2023-03-28-百度笔试"><a href="#2023-03-28-百度笔试" class="headerlink" title="2023-03-28 百度笔试"></a>2023-03-28 百度笔试</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/470518592438652928?sourceSSR=search">3.28百度笔试复盘</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59656673">图解SQL的inner join、left &#x2F;right join、 outer join区别</a><br><img src="https://img-blog.csdnimg.cn/c476edea4cad4603a800e191024ab95a.png" srcset="/img/loading.gif" lazyload><br>编程题过了2.8道，第三题一直超时，只得了80分</p><h3 id="第一题-4"><a href="#第一题-4" class="headerlink" title="第一题"></a>第一题</h3><p>题目：<br><img src="https://img-blog.csdnimg.cn/eb95276b952640feb563d8423c774afc.png" srcset="/img/loading.gif" lazyload><br>签到题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; a[i];<br>  &#125;<br>  string str;<br>  cin &gt;&gt; str;<br>  ll red_sum = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 红色权值之和</span><br>  ll blue_sum = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 蓝色权值之和</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>      red_sum = (red_sum + a[i]) % kMod;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      blue_sum = (blue_sum + a[i]) % kMod;<br>    &#125;<br>  &#125;<br>  ll ans = (red_sum * blue_sum) % kMod;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题-4"><a href="#第二题-4" class="headerlink" title="第二题"></a>第二题</h3><p>题目：<br><img src="https://img-blog.csdnimg.cn/9701f70a49d34363bb131ea24291e1cc.png" srcset="/img/loading.gif" lazyload><br>标准解法是单调栈，不过我当时没想到，就用数组存从当前位置往右看最大value的索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  string str;<br>  cin &gt;&gt; str;<br>  <span class="hljs-type">int</span> length = str.<span class="hljs-built_in">length</span>();<br>  string ans = <span class="hljs-string">&quot;0.&quot;</span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">max_see</span><span class="hljs-params">(length)</span></span>;  <span class="hljs-comment">// 从当前位置往右看最大value的索引</span><br>  max_see[length - <span class="hljs-number">1</span>] = length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">2</span>; i--) &#123;<br>    <span class="hljs-type">char</span> next_max_value = str[max_see[i + <span class="hljs-number">1</span>]];<br>    <span class="hljs-keyword">if</span> (str[i] &gt;= next_max_value) &#123;  <span class="hljs-comment">// 当前位置比右边最大值大</span><br>      max_see[i] = i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 当前位置比右边最大值小</span><br>      max_see[i] = max_see[i + <span class="hljs-number">1</span>];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; length; i++) &#123;<br>    ans.<span class="hljs-built_in">push_back</span>(str[max_see[i]]);<br>    i = max_see[i];<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三题-4"><a href="#第三题-4" class="headerlink" title="第三题"></a>第三题</h3><p>题目：<br><img src="https://img-blog.csdnimg.cn/e4bb7d04e63e4257982f1d9e2e115fcc.png" srcset="/img/loading.gif" lazyload><br>只得了80分，要么时间超时，要么内存使用过多，可以优化的点在于输入x y时将信息暂存到某一个地方，而后在树遍历的过程中一次性计算所有，而不是每次都遍历x的所有子节点，并与info相加，不过最后没时间了，就没实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> NumberInfo = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;  <span class="hljs-comment">// 记录数字中2，5因数的个数</span><br><span class="hljs-function">NumberInfo <span class="hljs-title">GetInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;         <span class="hljs-comment">// 得到数字2，5因数的个数</span><br>  <span class="hljs-type">int</span> two = <span class="hljs-number">0</span>, five = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>    two++;<br>    x = x / <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>    five++;<br>    x = x / <span class="hljs-number">5</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;two, five&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddInfo</span><span class="hljs-params">(NumberInfo&amp; p1, NumberInfo p2)</span> </span>&#123;  <span class="hljs-comment">// 因数个数相加</span><br>  p1.first += p2.first;<br>  p1.second += p2.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, q;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 该节点是否出现</span><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;             <span class="hljs-comment">// 使用数组维护树结构</span><br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">child</span>(n + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 节点的子节点（包括自身）</span><br>  <span class="hljs-function">vector&lt;NumberInfo&gt; <span class="hljs-title">num</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;       <span class="hljs-comment">// 各节点2,5因数个数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-type">int</span> a;<br>    cin &gt;&gt; a;<br>    num[i] = <span class="hljs-built_in">GetInfo</span>(a);<br>    child[i].<span class="hljs-built_in">emplace_back</span>(i);<br>  &#125;<br>  <span class="hljs-comment">// 构建树结构，1为根节点</span><br>  visited[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>  tree[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    <span class="hljs-comment">// 确定哪个为父节点</span><br>    <span class="hljs-keyword">if</span> (visited[u]) &#123;<br>      tree[v] = u;<br>      visited[v] = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      tree[u] = v;<br>      visited[u] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  visited.<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-comment">// 计算各节点子节点信息</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-type">int</span> root = i;<br>    <span class="hljs-keyword">do</span> &#123;<br>      root = tree[root];<br>      child[root].<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125; <span class="hljs-keyword">while</span> (root != <span class="hljs-number">1</span>);<br>  &#125;<br>  cin &gt;&gt; q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    NumberInfo info = <span class="hljs-built_in">GetInfo</span>(y);<br>    <span class="hljs-comment">// 所有子节点信息加上info因数个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> node : child[x]) &#123;<br>      <span class="hljs-built_in">AddInfo</span>(num[node], info);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 计算各节点的最终值（因数2与因数5的个数）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-type">int</span> root = i;<br>    <span class="hljs-keyword">do</span> &#123;<br>      root = tree[root];<br>      <span class="hljs-built_in">AddInfo</span>(num[root], num[i]);<br>    &#125; <span class="hljs-keyword">while</span> (root != <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 计算各节点后缀0的个数（因数2与因数5个数的较小值）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(num[i].first, num[i].second) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h3><p>ali字符串，刚开始忽略了对开头字符是否为Aa的判断，只有3种状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  string str;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    cin &gt;&gt; str;<br>    <span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;      <span class="hljs-comment">//  状态机转换  0：初始状态 1：遇到Aa 2：遇到lL 3: 遇到iI</span><br>    <span class="hljs-type">bool</span> error = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 是否发生错误</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) &#123;<br>      <span class="hljs-keyword">if</span> (status == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;  <span class="hljs-comment">//  状态转换</span><br>          status = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 预期之外的值，发生错误</span><br>          error = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;l&#x27;</span> || c == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;  <span class="hljs-comment">//  状态转换</span><br>          status = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;A&#x27;</span>) &#123;  <span class="hljs-comment">// 预期之外的值，发生错误</span><br>          error = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;i&#x27;</span> || c == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;  <span class="hljs-comment">//  状态转换</span><br>          status = <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;l&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;L&#x27;</span>) &#123;  <span class="hljs-comment">// 预期之外的值，发生错误</span><br>          error = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;i&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;I&#x27;</span>) &#123;  <span class="hljs-comment">// 预期之外的值，发生错误</span><br>          error = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (error || status != <span class="hljs-number">3</span>) &#123;  <span class="hljs-comment">// 发生错误或未遇到i</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="01翻转"><a href="#01翻转" class="headerlink" title="01翻转"></a>01翻转</h3><p>使用dfs遍历各个翻转可能，加上一点剪枝策略，骗分<br><strong>正确思路</strong><br><img src="https://img-blog.csdnimg.cn/4442a84c995c4917b5f51c0c5d3e4964.png" srcset="/img/loading.gif" lazyload><br><img src="https://img-blog.csdnimg.cn/ec4e37e60a234116ba4b5a39d79de2ee.png" srcset="/img/loading.gif" lazyload></p><h3 id="dfs优化思路"><a href="#dfs优化思路" class="headerlink" title="dfs优化思路"></a>dfs优化思路</h3><p>可以使用备忘录的方式减少各个点最大获得价值的重复计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMax = <span class="hljs-number">10001</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kInf = <span class="hljs-number">-1</span> * (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>);<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">food</span><span class="hljs-params">(kMax)</span></span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">path</span>(kMax);<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">max_get</span><span class="hljs-params">(kMax, kInf)</span></span>;<br><br><span class="hljs-comment">// void dfs(int cur_id, int cur_value, int&amp; max_value) &#123;</span><br><span class="hljs-comment">//   cur_value += food[cur_id];</span><br><span class="hljs-comment">//   max_value = max(max_value, cur_value);</span><br><span class="hljs-comment">//   for (int dst_id : path[cur_id]) &#123;</span><br><span class="hljs-comment">//     dfs(dst_id, cur_value, max_value);</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur_id, <span class="hljs-type">int</span> cur_value)</span> </span>&#123;<br>  cur_value += food[cur_id];<br>  <span class="hljs-type">int</span> max_value = cur_value;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dst_id : path[cur_id]) &#123;<br>    <span class="hljs-keyword">if</span> (max_get[dst_id] == kInf) &#123;<br>      max_get[dst_id] = <span class="hljs-built_in">dfs</span>(dst_id, cur_value);<br>    &#125;<br>    max_value = <span class="hljs-built_in">max</span>(max_value, max_get[dst_id]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> max_value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-type">int</span> id, parent_id, value;<br>    cin &gt;&gt; id &gt;&gt; parent_id &gt;&gt; value;<br>    food[id] = value;<br>    <span class="hljs-keyword">if</span> (parent_id != <span class="hljs-number">-1</span>) &#123;<br>      path[parent_id].<span class="hljs-built_in">emplace_back</span>(id);<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>; id &lt; n; id++) &#123;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">dfs</span>(id, <span class="hljs-number">0</span>);<br>    ans = <span class="hljs-built_in">max</span>(ans, tmp);<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment">0 1 8</span><br><span class="hljs-comment">1 -1 -2</span><br><span class="hljs-comment">2 1 9</span><br><span class="hljs-comment">4 0 -2</span><br><span class="hljs-comment">5 4 3</span><br><span class="hljs-comment">3 0 -3</span><br><span class="hljs-comment">6 2 -3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a> </span><span class="category-chain"><a href="/categories/%E6%98%A5%E6%8B%9B%E7%A7%8B%E6%8B%9B/" class="category-chain-item">春招秋招</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%9C%BA%E8%AF%95%E4%BB%A3%E7%A0%81/" class="print-no-link">#实习记录 机试代码</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/continue/%E7%A7%8B%E6%8B%9B%E6%9C%BA%E8%AF%95%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95.html" title="秋招机试代码记录"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">秋招机试代码记录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/fio%E4%B8%8B%E5%8F%91%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%B0%8F%E4%B8%8D%E7%A1%AE%E5%AE%9A.html" title="fio下发的请求大小不确定"><span class="hidden-mobile">fio下发的请求大小不确定</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var e=Object.assign({appId:"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz",appKey:"0e2MMh7ddBCGGytOe9UEy5NP",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://uu0wegco.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>