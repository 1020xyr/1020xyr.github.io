<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/main.jpg"><link rel="icon" href="/img/main.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="xv6 book记录阅读xv6 book之前，简要看一下《深入了解linux内核》进程一章（不怎么看得懂），当然xv6 book也看的犯困。该实验比较简单，就看书花点时间。  First, xv6’s sleep and wakeup mechanism switches when a process waits for device or pipe I&#x2F;O to complete"><meta property="og:type" content="article"><meta property="og:title" content="MIT6.S081 Multithreading"><meta property="og:url" content="https://www.jiasun.top/blog/MIT6.S081%20Multithreading.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="xv6 book记录阅读xv6 book之前，简要看一下《深入了解linux内核》进程一章（不怎么看得懂），当然xv6 book也看的犯困。该实验比较简单，就看书花点时间。  First, xv6’s sleep and wakeup mechanism switches when a process waits for device or pipe I&#x2F;O to complete"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/986aec337e5847a38fc01ea48d10c8ca.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/387e65f9193c4dff848698de9bf0b3ac.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/fc3d79944d134e3581ca4254d21b9c04.jpeg"><meta property="og:image" content="https://img-blog.csdnimg.cn/5ced4658943e43b38752932ea9a5d5a3.png"><meta property="article:published_time" content="2022-08-28T15:05:29.000Z"><meta property="article:modified_time" content="2023-10-31T14:45:58.921Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="mit6.081 multithread"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/986aec337e5847a38fc01ea48d10c8ca.png"><title>MIT6.S081 Multithreading - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="MIT6.S081 Multithreading"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-28 23:05" pubdate>2022年8月28日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 70 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">MIT6.S081 Multithreading</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><h2 id="xv6-book记录"><a href="#xv6-book记录" class="headerlink" title="xv6 book记录"></a>xv6 book记录</h2><p>阅读xv6 book之前，简要看一下《深入了解linux内核》进程一章（不怎么看得懂），当然xv6 book也看的犯困。该实验比较简单，就看书花点时间。</p><blockquote><p>First, xv6’s sleep and wakeup mechanism switches when a process waits for device or pipe I&#x2F;O to complete,<br>or waits for a child to exit, or waits in the sleep system call. Second, xv6 periodically forces a switch to cope with processes that compute for long periods without sleeping.This multiplexing creates the illusion that each process has its own CPU, much as xv6 uses the memory allocator and hardware page tables to create the illusion that each process has its own memory.</p></blockquote><p>xv6或者通过sleep wakeup主动让出cpu，或者定时强制切换进程。这种分时共享的技术创建了每个进程都拥有自己独立的CPU的假象，就像内存分配器与独立页表制造了每个进程都有独立地址空间的假象。</p><p><img src="https://img-blog.csdnimg.cn/986aec337e5847a38fc01ea48d10c8ca.png" srcset="/img/loading.gif" lazyload><br>先切换到调度器线程，然后再切换到其他线程。swtch不保存pc寄存器，而保存ra寄存器，即从swtch函数返回的地址。为保证进程状态与上下文设置正确，swtch的调用者需持有p-&gt;lock。通过线程切换有意地将控制传递给彼此的过程有时被称为协程;在这个例子中，sched和scheduler是彼此的协程。</p><p>在上下文切换时进程需持有p-&gt;lock并且不释放，由调度器负责释放，流程如下：<br>进程p1切换到进程p2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">p1: acquire p1-&gt;lock<br>scheduler: release p1-&gt;lock acquire p2-&gt;lock<br>p2: release p2-&gt;lock<br><br><span class="hljs-comment">// yield	p1-&gt; scheduler</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>acquire(&amp;p-&gt;lock);<br>p-&gt;state = RUNNABLE;<br><span class="hljs-type">int</span> intena;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br><span class="hljs-keyword">if</span>(!holding(&amp;p-&gt;lock))<br>    panic(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br><span class="hljs-keyword">if</span>(mycpu()-&gt;noff != <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br><span class="hljs-keyword">if</span>(p-&gt;state == RUNNING)<br>    panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br><span class="hljs-keyword">if</span>(intr_get())<br>    panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>intena = mycpu()-&gt;intena;<br>swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br><span class="hljs-comment">// scheduler</span><br>c-&gt;proc = <span class="hljs-number">0</span>;<br>&#125;<br>release(&amp;p-&gt;lock);<br><br><br><span class="hljs-comment">// scheduler -&gt; p2</span><br>acquire(&amp;p-&gt;lock);<br><span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;<br>    <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>    <span class="hljs-comment">// to release its lock and then reacquire it</span><br>    <span class="hljs-comment">// before jumping back to us.</span><br>    p-&gt;state = RUNNING;<br>    c-&gt;proc = p;<br>    swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br> <span class="hljs-comment">// sched p2</span><br>mycpu()-&gt;intena = intena;<br> <span class="hljs-comment">// yield</span><br> release(&amp;p-&gt;lock);<br></code></pre></td></tr></table></figure><p>为了能获取到当前运行进程的proc结构体，每个CPU保存一系列数据记录相关信息<br>丢失唤醒问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(s-&gt;count==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 中间可能丢失唤醒</span><br>    sleep(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>解决：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire(&amp;s-&gt;lock);<br><span class="hljs-keyword">while</span>(s-&gt;count == <span class="hljs-number">0</span>)<br>    sleep(s, &amp;s-&gt;lock);<br></code></pre></td></tr></table></figure><p>父进程wait与子进程exit的竞争，或者父进程exit与子进程exit的竞争<br>通过同样顺序申请wait_lock和p-&gt;lock避免死锁<br>kill系统调用只是修改killed和进程状态，在有些不重要的时候sleep所在循环会额外检查p-&gt;killed</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="hljs-comment">//DOC: pipe-empty</span><br>  <span class="hljs-keyword">if</span>(pr-&gt;killed)&#123;<br>    release(&amp;pi-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="hljs-comment">//DOC: piperead-sleep</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但在一些重要操作的时候，sleep循环并不检查killed，保证操作的原子性或IO正确性</p><p>proc结构体各锁保护对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br><span class="hljs-type">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br><span class="hljs-type">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br><span class="hljs-type">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br><span class="hljs-type">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br><span class="hljs-comment">// wait_lock must be held when using this:</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br></code></pre></td></tr></table></figure><p>signal只唤醒等待队列中的一个进程，而broadcast唤醒所有等待队列的进程<br>sleep与kill也存在竞态：在killed检查与sleep语句之间</p><h2 id="Uthread"><a href="#Uthread" class="headerlink" title="Uthread"></a>Uthread</h2><blockquote><p>Your job is to come up with a plan to create threads and save&#x2F;restore registers to switch between threads, and implement that plan. When you’re done, make grade should say that your solution passes the uthread test.</p></blockquote><p>这部分只需要简单抄一下allocproc函数和swtch.S就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// allocproc</span><br> <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br> <span class="hljs-comment">// which returns to user space.</span><br> <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br> p-&gt;context.ra = (uint64)forkret;<br> p-&gt;context.sp = p-&gt;kstack + PGSIZE;<br></code></pre></td></tr></table></figure><p>实验代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Saved registers for kernel context switches.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br>  uint64 ra;<br>  uint64 sp;<br><br>  <span class="hljs-comment">// callee-saved</span><br>  uint64 s0;<br>  uint64 s1;<br>  uint64 s2;<br>  uint64 s3;<br>  uint64 s4;<br>  uint64 s5;<br>  uint64 s6;<br>  uint64 s7;<br>  uint64 s8;<br>  uint64 s9;<br>  uint64 s10;<br>  uint64 s11;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> &#123;</span><br>  <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STACK_SIZE]; <span class="hljs-comment">/* the thread&#x27;s stack */</span><br>  <span class="hljs-type">int</span> state;              <span class="hljs-comment">/* FREE, RUNNING, RUNNABLE */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span><br>&#125;;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> context *, <span class="hljs-keyword">struct</span> context *)</span>;<br><span class="hljs-comment">// thread_create</span><br><span class="hljs-comment">// YOUR CODE HERE</span><br><span class="hljs-built_in">memset</span>(&amp;t-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(t-&gt;context));<br>t-&gt;context.ra = (uint64)func;<br>t-&gt;context.sp = (uint64)(t-&gt;<span class="hljs-built_in">stack</span> + STACK_SIZE - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// thread_schedule</span><br><span class="hljs-comment">/* YOUR CODE HERE</span><br><span class="hljs-comment"> * Invoke thread_switch to switch from t to next_thread:</span><br><span class="hljs-comment"> * thread_switch(??, ??);</span><br><span class="hljs-comment"> */</span><br>thread_switch(&amp;t-&gt;context, &amp;current_thread-&gt;context);<br><br><span class="hljs-comment">// uthread_switch.S</span><br>	.globl thread_switch<br>thread_switch:<br>	sd ra, <span class="hljs-number">0</span>(a0)<br>	sd sp, <span class="hljs-number">8</span>(a0)<br>	sd s0, <span class="hljs-number">16</span>(a0)<br>	sd s1, <span class="hljs-number">24</span>(a0)<br>	sd s2, <span class="hljs-number">32</span>(a0)<br>	sd s3, <span class="hljs-number">40</span>(a0)<br>	sd s4, <span class="hljs-number">48</span>(a0)<br>	sd s5, <span class="hljs-number">56</span>(a0)<br>	sd s6, <span class="hljs-number">64</span>(a0)<br>	sd s7, <span class="hljs-number">72</span>(a0)<br>	sd s8, <span class="hljs-number">80</span>(a0)<br>	sd s9, <span class="hljs-number">88</span>(a0)<br>	sd s10, <span class="hljs-number">96</span>(a0)<br>	sd s11, <span class="hljs-number">104</span>(a0)<br><br>	ld ra, <span class="hljs-number">0</span>(a1)<br>	ld sp, <span class="hljs-number">8</span>(a1)<br>	ld s0, <span class="hljs-number">16</span>(a1)<br>	ld s1, <span class="hljs-number">24</span>(a1)<br>	ld s2, <span class="hljs-number">32</span>(a1)<br>	ld s3, <span class="hljs-number">40</span>(a1)<br>	ld s4, <span class="hljs-number">48</span>(a1)<br>	ld s5, <span class="hljs-number">56</span>(a1)<br>	ld s6, <span class="hljs-number">64</span>(a1)<br>	ld s7, <span class="hljs-number">72</span>(a1)<br>	ld s8, <span class="hljs-number">80</span>(a1)<br>	ld s9, <span class="hljs-number">88</span>(a1)<br>	ld s10, <span class="hljs-number">96</span>(a1)<br>	ld s11, <span class="hljs-number">104</span>(a1)<br>    <br>	ret    <span class="hljs-comment">/* return to ra */</span><br></code></pre></td></tr></table></figure><p>刚开始一直想着怎么让调度完后跳转到thread_x函数中调用thread_yield();后面的语句，后面才想到只需要跳转thread_schedule最后一条语句后面并且设置好各寄存器，就可以一直函数返回到预期的指令地址了。</p><p>开始写代码时把其他代码都抄了，却没注意p-&gt;context.sp &#x3D; p-&gt;kstack + PGSIZE;语句，导致一直在执行c函数，其他进程的state都很奇怪。后面才想到要设置栈（sp）。<br><img src="https://img-blog.csdnimg.cn/387e65f9193c4dff848698de9bf0b3ac.png" srcset="/img/loading.gif" lazyload></p><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><blockquote><p>To avoid this sequence of events, insert lock and unlock statements in put and get in notxv6&#x2F;ph.c so that the number of keys missing is always 0 with two threads. The relevant pthread calls are:<br>pthread_mutex_t lock; &#x2F;&#x2F; declare a lock<br>pthread_mutex_init(&amp;lock, NULL); &#x2F;&#x2F; initialize the lock<br>pthread_mutex_lock(&amp;lock); &#x2F;&#x2F; acquire lock<br>pthread_mutex_unlock(&amp;lock); &#x2F;&#x2F; release lock<br>You’re done when make grade says that your code passes the ph_safe test, which requires zero missing keys with two threads. It’s OK at this point to fail the ph_fast test.</p></blockquote><p>丢失键值的原因只需要看两行语句就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// p : &amp;table[i] n : table[i]</span><br>e-&gt;next = n;<br>*p = e;<br></code></pre></td></tr></table></figure><p>多个线程同时修改table的值，假设以如下顺序执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 线程1为e1，线程2为e2</span><br> e1-&gt;next = n;<br> e2-&gt;next = n;<br> *p = e2;<br> *p = e1;<br></code></pre></td></tr></table></figure><p>则e2丢失<br><img src="https://img-blog.csdnimg.cn/fc3d79944d134e3581ca4254d21b9c04.jpeg" srcset="/img/loading.gif" lazyload><br>代码部分：<br>首先增大NBUCKET，降低各线程冲突概率</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBUCKET 100</span><br></code></pre></td></tr></table></figure><p>声明并初始化互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> &#123;</span><br>  <span class="hljs-type">int</span> key;<br>  <span class="hljs-type">int</span> value;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">table</span>[<span class="hljs-title">NBUCKET</span>];</span><br><span class="hljs-type">pthread_mutex_t</span> lock[NBUCKET];  <span class="hljs-comment">// declare a lock</span><br><span class="hljs-type">int</span> keys[NKEYS];<br><span class="hljs-type">int</span> nthread = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">pthread_t</span> *tha;<br>  <span class="hljs-type">void</span> *value;<br>  <span class="hljs-type">double</span> t1, t0;<br><br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  nthread = atoi(argv[<span class="hljs-number">1</span>]);<br>  tha = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * nthread);<br>  srandom(<span class="hljs-number">0</span>);<br>  assert(NKEYS % nthread == <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NKEYS; i++) &#123;<br>    keys[i] = random();<br>  &#125;<br><br>  <span class="hljs-comment">// 初始化互斥锁锁</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++) &#123;<br>    pthread_mutex_init(&amp;lock[i], <span class="hljs-literal">NULL</span>);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>put函数的模式为：<br>查询是否存在key<br>不存在：插入key，value<br>存在：更新value<br>故需对整段代码加锁，保证逻辑的正确性（不存在相同的key），如果不对查询段加锁则可能导致插入两个相同的key</p><p>get函数进行读操作，本来是需要加锁的，但程序的顺序保证此时只有读操作，故不需要加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// first the puts</span><br><span class="hljs-comment">//</span><br>t0 = now();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>  assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, put_thread, (<span class="hljs-type">void</span> *)(<span class="hljs-type">long</span>)i) == <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>  assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>&#125;<br>t1 = now();<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d puts, %.3f seconds, %.0f puts/second\n&quot;</span>, NKEYS, t1 - t0, NKEYS / (t1 - t0));<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// now the gets</span><br><span class="hljs-comment">//</span><br>t0 = now();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>  assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, get_thread, (<span class="hljs-type">void</span> *)(<span class="hljs-type">long</span>)i) == <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>  assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>&#125;<br>t1 = now();<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d gets, %.3f seconds, %.0f gets/second\n&quot;</span>, NKEYS * nthread, t1 - t0, (NKEYS * nthread) / (t1 - t0));<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br><br>  <span class="hljs-comment">// is the key already present?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  pthread_mutex_lock(&amp;lock[i]);<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (e) &#123;<br>    <span class="hljs-comment">// update the existing key.</span><br>    e-&gt;value = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// the new is new.</span><br>    insert(key, value, &amp;table[i], table[i]);<br>  &#125;<br>  pthread_mutex_unlock(&amp;lock[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><blockquote><p>Your goal is to achieve the desired barrier behavior. In addition to the lock primitives that you have seen in the ph assignment, you will need the following new pthread primitives; look here and here for details.<br>pthread_cond_wait(&amp;cond, &amp;mutex); &#x2F;&#x2F; go to sleep on cond, releasing lock mutex, acquiring upon wake up<br>pthread_cond_broadcast(&amp;cond); &#x2F;&#x2F; wake up every thread sleeping on cond<br>Make sure your solution passes make grade’s barrier test.</p></blockquote><p>非常简单，直接贴代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">barrier_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  assert(pthread_mutex_init(&amp;bstate.barrier_mutex, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>);<br>  assert(pthread_cond_init(&amp;bstate.barrier_cond, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">0</span>);<br>  bstate.nthread = <span class="hljs-number">0</span>;<br>  bstate.round = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">barrier</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>  <span class="hljs-comment">// then increment bstate.round.</span><br>  <span class="hljs-comment">//</span><br>  pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>  bstate.nthread++;<br>  <span class="hljs-keyword">if</span> (bstate.nthread == nthread) &#123;<br>    bstate.round++;<br>    pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>    bstate.nthread = <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>  &#125;<br>  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过截图</strong><br><img src="https://img-blog.csdnimg.cn/5ced4658943e43b38752932ea9a5d5a3.png" srcset="/img/loading.gif" lazyload></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%9B%BD%E5%A4%96%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/" class="category-chain-item">国外课程实验</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/mit6-081-multithread/" class="print-no-link">#mit6.081 multithread</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/blog/MIT6.S081%202021%20locks.html" title="MIT6.S081 2021 locks"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MIT6.S081 2021 locks</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/MIT6.S081%202021%20mmap.html" title="MIT6.S081 2021 mmap"><span class="hidden-mobile">MIT6.S081 2021 mmap</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var e=Object.assign({appId:"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz",appKey:"0e2MMh7ddBCGGytOe9UEy5NP",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://uu0wegco.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>