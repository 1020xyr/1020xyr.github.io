<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/main.jpg"><link rel="icon" href="/img/main.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="赛题简单介绍比赛地址：第四届全球数据库大赛赛道1：云原生共享内存数据库性能优化 赛题大致内容：本地读写速度快，但空间小，远端读写速度慢，但空间大（通过eRDMA读写远端数据）初赛时实现一个简化、高效的KV存储引擎，支持Write、Read接口，此时key-value皆为定值复赛额外实现一个Delete接口和重建（rebuild）功能，此时value为变长值。评测程序分为2个阶段：1）程序正确"><meta property="og:type" content="article"><meta property="og:title" content="天池比赛记录"><meta property="og:url" content="https://www.jiasun.top/blog/%E5%A4%A9%E6%B1%A0%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="赛题简单介绍比赛地址：第四届全球数据库大赛赛道1：云原生共享内存数据库性能优化 赛题大致内容：本地读写速度快，但空间小，远端读写速度慢，但空间大（通过eRDMA读写远端数据）初赛时实现一个简化、高效的KV存储引擎，支持Write、Read接口，此时key-value皆为定值复赛额外实现一个Delete接口和重建（rebuild）功能，此时value为变长值。评测程序分为2个阶段：1）程序正确"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/e2e54b032f9f4072a3b9152b522e2dff.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/f2bec1f861e744b3b8054158b110f097.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/fd1e0c108e0246deb52157211fd8acb1.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/491fcc474b6a4c4e83f190a936218ccd.png"><meta property="article:published_time" content="2022-11-09T01:03:39.000Z"><meta property="article:modified_time" content="2023-10-31T14:45:59.465Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="天池 c++ 数据库 存储引擎"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/e2e54b032f9f4072a3b9152b522e2dff.png"><title>天池比赛记录 - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="天池比赛记录"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-11-09 09:03" pubdate>2022年11月9日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 51k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 425 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">天池比赛记录</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><h2 id="赛题简单介绍"><a href="#赛题简单介绍" class="headerlink" title="赛题简单介绍"></a>赛题简单介绍</h2><p>比赛地址：<a target="_blank" rel="noopener" href="https://tianchi.aliyun.com/competition/entrance/531979/introduction">第四届全球数据库大赛赛道1：云原生共享内存数据库性能优化</a></p><p>赛题大致内容：<br>本地读写速度快，但空间小，远端读写速度慢，但空间大（通过eRDMA读写远端数据）<br>初赛时实现一个简化、高效的KV存储引擎，支持Write、Read接口，此时key-value皆为定值<br>复赛额外实现一个Delete接口和重建（rebuild）功能，此时value为变长值。<br>评测程序分为2个阶段：<br>1）程序正确性验证<br>验证KV操作的正确性（包括加密&#x2F;解密过程），这部分的耗时不计入运行时间的统计。如果正确性测试不通过，则终止，评测失败。<br>2）性能评测<br>引擎使用的本地内存和远端内存限制在 8 GB 和 32 GB。 阶段1. 每个线程分别写入约 12 M个Key大小为 16 Bytes，Value大小为 80-1024 Bytes 的 KV对象，并选择性读取验证；阶段2. 每个线程会进行并发删除，每个线程删除 10 M个Key，删除操作耗时将计入运行时间；阶段3. 每个线程分别再次写入约 10 M个Key大小为 16 Bytes，Value大小为 80-256 Bytes 的 KV对象；接着会进行读写混合测试，开启16个线程以75%：25%的读写比例调用64M次。其中75%的读访问具有热点的特征，大部分的读访问集中在少量的Key上面。最后的分数为以上操作耗时的总和。</p><p>数据安排如下：本阶段保证任意时刻数据的value部分长度和不超过30G。纯写入的12M次操作中大约70%的操作Value长度在80-128Bytes之间；大约20%的操作Value长度在129-256Bytes之间；大约10%的操作Value长度在257-1024Bytes之间。读写混合的64M操作中，所有Set操作的Value长度均不超过128Bytes。<br><img src="https://img-blog.csdnimg.cn/e2e54b032f9f4072a3b9152b522e2dff.png" srcset="/img/loading.gif" lazyload><br>评测程序输出大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">Start <span class="hljs-built_in">local</span> encryption evaluation...Start evaluation.<br>Generating the ZipFian PDF......<br>Generate PDF Done.<br>Do new LocalEngine.<br>Start LocalEngine using start interface.<br>LocalEngine::start finsh<br><br>Starting Write-Read Testing.<br><span class="hljs-comment">##################### Start Write from index: 0</span><br>...<br><span class="hljs-comment">##################### End The Write-Read Test ##############################</span><br>Time <span class="hljs-keyword">for</span> Write-Read Test 32.000000 seconds<br>LocalEngine::stop finsh<br><span class="hljs-comment">##################### Evaluation Success ##############################</span><br>Start <span class="hljs-built_in">local</span> perf evaluation...Start evaluation.<br>Generating the ZipFian PDF......<br>Generate PDF Done.<br>Do new LocalEngine.<br>Start LocalEngine using start interface.<br>LocalEngine::start finsh<br><br>Starting Write-Read Testing.<br><span class="hljs-comment">##################### Start Write from index: 0</span><br>...<br><span class="hljs-comment">##################### End The Write-Read Test ##############################</span><br>Time <span class="hljs-keyword">for</span> Write-Read Test 158.000000 seconds<br><br>Starting Deleting Testing.<br><span class="hljs-comment">##################### Start Delete from index: 0</span><br>...<br><span class="hljs-comment">##################### End The Delete Test ##############################</span><br>Time <span class="hljs-keyword">for</span> Delete Test 47.000000 seconds<br><br>Starting HOT Data Testing.<br><span class="hljs-comment">##################### Start test from index: 0</span><br>...<br><span class="hljs-comment">##################### End The Hot Data Test ##############################</span><br>Time <span class="hljs-keyword">for</span> Hot Data Test 46.000000 seconds<br>Hot:46<br>LocalEngine::stop finsh<br>Total:253<br><span class="hljs-comment">##################### Evaluation Success ##############################</span><br>Success evaluation, update score...37.2979146325685141834147<br></code></pre></td></tr></table></figure><p>复赛排名第20名，正好是极客奖最后一名，嘻嘻。</p><h2 id="比赛经历"><a href="#比赛经历" class="headerlink" title="比赛经历"></a>比赛经历</h2><p>在初赛时官方提供了一个简单的demo，将key和远端地址存于本地，value全部存于远端，初赛结束时我们的代码大致架构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">key-value数据以页面的方式存储起来，本地存储key的元数据（key，（页号，索引））（<span class="hljs-number">5</span>G），缓存少量页（<span class="hljs-number">2</span>G），远端页的远端地址，远端存储大部分页数据（<span class="hljs-number">30</span>G）。<br>写入时：<br>	插入：将数据插入新申请的页中，写入元数据（key，（页号，页索引））<br>	更新：若对应页面当前存于远端，则视作插入操作处理，并更新key元数据，<br>		 若对应页面存于本地，则直接更新value<br>	更新LRU列表<br>读取时：<br>	若页面存于远端，则读取远端数据，将该页加入本地缓存<br>	若页面存于本地，则直接读取数据<br>	更新LRU列表<br>淘汰：<br>	开启一个后台线程，当本地缓存页大于阈值时，将最久未被访问的页写入远端，记录远端地址<br><br>哈希：<br>	为减小锁争用，我们构建了许多个执行请求的实体，并通过对key进行哈希将请求分发至某一实体<br>	（LocalEngine-&gt;LocalEngineEntity）,而后对key进行第二次哈希，写入/读取key的元数据。<br>	由于STL的map占用空间较大，官方提供了哈希表的简单实现，直接刚开始就申请足够的空间，然后使<br>	用拉链法连接哈希值相同的数据，不需要动态扩容。<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f2bec1f861e744b3b8054158b110f097.png" srcset="/img/loading.gif" lazyload><br>初赛结束时，我们只得了9分，最大的原因在于第一次哈希与第二次哈希使用同样的哈希函数（std::hash），导致LocalEngineEntity里的自定义哈希表中很大的一部分空间永远不会被访问（哈希值皆为LocalEngineEntity下标的整数），增大了哈希冲突的概率。<br>在初赛的基础上编写复赛代码，主要实现三个功能：value的加密，删除操作，重构操作（删除被标记为无效的数据，整理有效数据使其排列更紧凑）。<br><strong>加密</strong>：value的加密根据IPP-Crypto的接口简单实现一个加密算法即可，没有几行代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::set_aes</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Current algorithm is not supported, just for demonstration.</span><br>  m_aes_.algo = CBC;<br>  m_aes_.key_len = <span class="hljs-number">16</span>;<br>  m_aes_.key = <span class="hljs-keyword">new</span> Ipp8u[<span class="hljs-number">16</span>]&#123;<span class="hljs-number">0x60</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0xca</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0xae</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x7d</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x81</span>&#125;;<br>  <span class="hljs-keyword">if</span> (m_aes_.key == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  m_aes_.blk_size = <span class="hljs-number">16</span>;<br>  m_aes_.piv_len = <span class="hljs-number">16</span>;<br>  m_aes_.piv = <span class="hljs-keyword">new</span> Ipp8u[<span class="hljs-number">16</span>]&#123;<span class="hljs-number">0x0f</span>, <span class="hljs-number">0x0e</span>, <span class="hljs-number">0x0d</span>, <span class="hljs-number">0x0c</span>, <span class="hljs-number">0x0b</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>&#125;;<br>  <span class="hljs-keyword">if</span> (m_aes_.piv == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-type">int</span> ctxSize;               <span class="hljs-comment">// AES context size</span><br>  <span class="hljs-built_in">ippsAESGetSize</span>(&amp;ctxSize);  <span class="hljs-comment">// evaluating AES context size</span><br>  <span class="hljs-comment">// allocatting memory for AES context</span><br>  m_aes_.ctx = (IppsAESSpec *)(<span class="hljs-keyword">new</span> Ipp8u[ctxSize]);<br>  <span class="hljs-comment">// AES context initialization</span><br>  <span class="hljs-built_in">ippsAESInit</span>(m_aes_.key, m_aes_.key_len, m_aes_.ctx, ctxSize);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 参考pdf实现简单加密算法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::encrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;value, std::string &amp;encrypt_value)</span> </span>&#123;<br>  Ipp8u ciph[(value.<span class="hljs-built_in">size</span>() + m_aes_.blk_size - <span class="hljs-number">1</span>) &amp; ~(m_aes_.blk_size - <span class="hljs-number">1</span>)];<br>  <span class="hljs-comment">// encrypting plaintext</span><br>  <span class="hljs-built_in">ippsAESEncryptCBC</span>((Ipp8u *)value.<span class="hljs-built_in">c_str</span>(), ciph, value.<span class="hljs-built_in">size</span>(), m_aes_.ctx, m_aes_.piv);<br>  <span class="hljs-function">std::string <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(ciph), value.size())</span></span>;<br>  encrypt_value = std::<span class="hljs-built_in">move</span>(tmp);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除：</strong> 代码的数据通路为：key——(page, index) ——本地缓存m_data_map——远端地址m_addr_map。故实现删除操作首先需要将key—&gt;(page, index)的映射删除，这个只需要增加自定义哈希表的删除功能，注意将删除后的slot插入另一个链表中，以便复用该slot</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">data_info_t</span> <span class="hljs-title">hash_map_t::remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>  hash_map_slot *cur = m_bucket_[index];<br>  hash_map_slot *parent = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> kNullInfo;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(cur-&gt;key, key.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 在bucket中删除该slot</span><br>      <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_bucket_[index] = cur-&gt;next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        parent-&gt;next = cur-&gt;next;<br>      &#125;<br>      <span class="hljs-comment">// 加入后备链表</span><br>      cur-&gt;next = m_slot_head_-&gt;next;<br>      m_slot_head_-&gt;next = cur;<br>      <span class="hljs-keyword">return</span> cur-&gt;info;<br>    &#125;<br>    parent = cur;<br>    cur = cur-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> kNullInfo;<br>&#125;<br></code></pre></td></tr></table></figure><p>将该映射删除后，无法通过key访问相应的value，但value仍然占据存储空间，故需要标记该位置，表示该value已经被删除，在重构操作时不需要迁移该位置的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::bitset&lt;kMaxIndex&gt; m_bitmap_[kBitmapSize];  <span class="hljs-comment">// 删除为1，正常为0</span><br></code></pre></td></tr></table></figure><p>每一页增加一个位图，标记页中记录是否有效。其中kMaxIndex表示页中最大记录数，kBitmapSize表示运行过程中的最大页号。<br>与位图相关的另一个操作是更新操作，如果更新操作对应的数据当前在远端，若此时读取远端数据再进行本地更新效率太低；故将这个操作拆分为删除远端数据+插入新数据；这时也需要将远端数据标记为无效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngineEntity::deleteK</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span> </span>&#123;<br>  m_delete_envent_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-type">int</span> hash_index = std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(key) &amp; (kBucketNum - <span class="hljs-number">1</span>);<br>  m_mutex_.<span class="hljs-built_in">lock</span>();<br>  <span class="hljs-type">data_info_t</span> info = m_page_map_.<span class="hljs-built_in">remove</span>(key, hash_index);  <span class="hljs-comment">// 删除对应key的元数据</span><br>  m_mutex_.<span class="hljs-built_in">unlock</span>();<br>  m_bitmap_[info.page_id].<span class="hljs-built_in">set</span>(info.index, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 将对应记录标记为删除</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 数据在远端的更新操作</span><br>m_bitmap_[slot-&gt;info.page_id].<span class="hljs-built_in">set</span>(slot-&gt;info.index, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 将之前数据标记为删除</span><br>slot-&gt;info = info;                                          <span class="hljs-comment">// 更新元数据信息</span><br></code></pre></td></tr></table></figure><p><strong>重构：</strong><br>本地缓存与远端数据交互的基本单位是页，程序运行过程中，无效记录会越来越多，故需定时读取所有页，将有效记录写入到新页中，删除旧页，类似于一种垃圾回收。<br>在读取远端页时，先读取其头部元数据，再依次读取有效记录，而不是读取整个页数据，这是因为rebuild时远端页有效记录占比较小，这样的读取方式可以减小读取量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LocalEngineEntity::rebuild_index</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_mutex_)</span></span>;<br>  std::string key;<br>  std::string value;<br>  <span class="hljs-type">data_info_t</span> data_info;<br>  std::shared_ptr&lt;Page&gt; page;<br>  std::unordered_map&lt;<span class="hljs-type">page_id_t</span>, <span class="hljs-type">remote_info_t</span>&gt; tmp_addr_map;  <span class="hljs-comment">// 暂时存储页号与远端地址映射</span><br>  <span class="hljs-type">uint32_t</span> new_cache_size = <span class="hljs-number">1</span>;<br>  std::vector&lt;<span class="hljs-type">page_id_t</span>&gt; local_id = m_lru_list_.<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">auto</span> new_page = m_cur_page_;<br>  <span class="hljs-type">page_id_t</span> new_page_id = m_cur_page_id_;<br>  <span class="hljs-comment">// 处理本地缓存页</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;page_id : local_id) &#123;<br>    <span class="hljs-keyword">auto</span> &amp;bitmap = m_bitmap_[page_id];<br>    <span class="hljs-keyword">if</span> (bitmap.<span class="hljs-built_in">none</span>()) &#123;  <span class="hljs-comment">// 不存在删除的记录，不进行操作</span><br>      m_lru_list_.<span class="hljs-built_in">insert</span>(page_id);<br>      new_cache_size++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!bitmap.<span class="hljs-built_in">all</span>()) &#123;  <span class="hljs-comment">//存在有效记录</span><br>      <span class="hljs-keyword">auto</span> page = m_data_map_[page_id];<br>      <span class="hljs-type">int</span> record_num = page-&gt;<span class="hljs-built_in">record_number</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; record_num; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!bitmap.<span class="hljs-built_in">test</span>(i)) &#123;        <span class="hljs-comment">// 该记录未被删除</span><br>          <span class="hljs-keyword">if</span> (new_page-&gt;<span class="hljs-built_in">is_full</span>()) &#123;  <span class="hljs-comment">// 页满，写入本地</span><br>            m_data_map_[new_page_id] = new_page;<br>            new_cache_size++;<br>            m_lru_list_.<span class="hljs-built_in">insert</span>(new_page_id);<br>            new_page = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;();<br>            new_page_id++;<br>          &#125;<br>          <span class="hljs-comment">// 读出数据插入新页并更新元数据映射</span><br>          key = page-&gt;<span class="hljs-built_in">read_key</span>(i);<br>          data_info.index = new_page-&gt;<span class="hljs-built_in">insert</span>(key, page-&gt;<span class="hljs-built_in">read_value</span>(i));<br>          data_info.page_id = new_page_id;<br>          m_page_map_.<span class="hljs-built_in">update</span>(key, data_info);<br>        &#125;<br>      &#125;<br>      m_data_map_[page_id] = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 删除原先页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      m_data_map_[page_id] = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 删除原先页</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-type">page_id_t</span> page_id;<br>  <span class="hljs-type">remote_info_t</span> info;<br>  <span class="hljs-type">char</span> head_data[kMaxIndex * <span class="hljs-number">10</span>];<br>  <span class="hljs-type">char</span> kv_data[<span class="hljs-number">2</span> * kMaxValueSize];<br>  <span class="hljs-type">uint16_t</span> *u16_pointer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint16_t</span> *&gt;(&amp;head_data);<br>  <span class="hljs-type">uint16_t</span> head_length;<br>  <span class="hljs-type">uint16_t</span> offset, length;<br><br>  <span class="hljs-comment">// 处理远端内存页</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;kv : m_addr_map_) &#123;<br>    page_id = kv.first;<br>    info = kv.second;<br>    <span class="hljs-keyword">auto</span> &amp;bitmap = m_bitmap_[page_id];<br>    <span class="hljs-keyword">if</span> (bitmap.<span class="hljs-built_in">none</span>()) &#123;  <span class="hljs-comment">// 不存在删除的记录，不进行操作</span><br>      tmp_addr_map.<span class="hljs-built_in">insert</span>(&#123;page_id, info&#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bitmap.<span class="hljs-built_in">all</span>()) &#123;  <span class="hljs-comment">// 不存在有效记录，将后端地址加入地址列表</span><br>      m_addr_list_.<span class="hljs-built_in">emplace</span>(info);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">bool</span> avai_info = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 是否将该远端地址加入地址列表</span><br>      head_length = (m_max_index_[page_id] + <span class="hljs-number">5</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint16_t</span>);<br>      <span class="hljs-comment">// 读取页头部数据</span><br>      m_rdma_conn_-&gt;<span class="hljs-built_in">remote_read</span>(head_data, head_length, info.remote_addr, info.rkey);<br>      <span class="hljs-type">int</span> record_num = m_max_index_[page_id];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; record_num; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!bitmap.<span class="hljs-built_in">test</span>(i)) &#123;<br>          <span class="hljs-keyword">if</span> (new_page-&gt;<span class="hljs-built_in">is_full</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (new_cache_size &gt; kPageThreshold) &#123;  <span class="hljs-comment">// 本地页满，写入远程</span><br>              std::string &amp;&amp;page_data = new_page-&gt;<span class="hljs-built_in">to_string</span>();<br>              <span class="hljs-type">uint32_t</span> len = page_data.<span class="hljs-built_in">length</span>();<br>              m_rdma_conn_-&gt;<span class="hljs-built_in">remote_write</span>((<span class="hljs-type">void</span> *)page_data.<span class="hljs-built_in">c_str</span>(), len, info.remote_addr, info.rkey);<br>              tmp_addr_map.<span class="hljs-built_in">insert</span>(&#123;new_page_id, info&#125;);  <span class="hljs-comment">// 暂时记录页号与远程地址映射</span><br>              avai_info = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 写入本地缓存</span><br>              m_data_map_[new_page_id] = new_page;<br>              new_cache_size++;<br>              m_lru_list_.<span class="hljs-built_in">insert</span>(new_page_id);<br>            &#125;<br>            new_page = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;();<br>            new_page_id++;<br>          &#125;<br>          <span class="hljs-comment">// 读出数据插入新页并更新元数据映射</span><br>          offset = u16_pointer[i + <span class="hljs-number">2</span>];<br>          length = u16_pointer[i + <span class="hljs-number">3</span>] - u16_pointer[i + <span class="hljs-number">2</span>];<br>          m_rdma_conn_-&gt;<span class="hljs-built_in">remote_read</span>(kv_data, length, info.remote_addr + offset, info.rkey);<br>          key = std::<span class="hljs-built_in">string</span>(kv_data, kv_data + <span class="hljs-number">16</span>);<br>          value = std::<span class="hljs-built_in">string</span>(kv_data + <span class="hljs-number">16</span>, kv_data + length);<br>          data_info.index = new_page-&gt;<span class="hljs-built_in">insert</span>(key, std::<span class="hljs-built_in">move</span>(value));<br>          data_info.page_id = new_page_id;<br>          m_page_map_.<span class="hljs-built_in">update</span>(key, data_info);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (avai_info) &#123;<br>        m_addr_list_.<span class="hljs-built_in">emplace</span>(info);<br>      &#125;<br>    &#125;<br>  &#125;<br>  m_addr_map_ = std::<span class="hljs-built_in">move</span>(tmp_addr_map);<br>  m_cur_page_id_ = new_page_id;<br>  m_cur_page_ = new_page;<br>  m_vicitm_id_ = kNullPage;<br>  m_vicitm_page_ = <span class="hljs-literal">nullptr</span>;<br>  m_cache_size_ = new_cache_size;<br>  m_last_update_id_ = kNullPage;<br>  m_data_map_[new_page_id] = new_page;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="变长字符编码方式演化"><a href="#变长字符编码方式演化" class="headerlink" title="变长字符编码方式演化"></a>变长字符编码方式演化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> &amp;&amp;vicitm_page_data = victim_page-&gt;<span class="hljs-built_in">to_string</span>();  <span class="hljs-comment">// 记录淘汰页数据，开始写入远端内存</span><br>m_rdma_conn_-&gt;<span class="hljs-built_in">remote_write</span>((<span class="hljs-type">void</span> *)vicitm_page_data.<span class="hljs-built_in">c_str</span>(), len, remote_info.remote_addr,<br>                                           remote_info.rkey);  <br></code></pre></td></tr></table></figure><p>kv数据在本地缓存是以string数组（Page类）的形式存储的，当本地缓存达到阈值时，需将很久未访问的页写入到远端，此时是写一个大字符串；故需要将string数组转换为一个大字符串。由于之后有可能再访问该页，需要把各记录的大小也编码进字符串中。刚开始我将每个记录编码成记录大小 +’\0’ +记录内容的形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">页数据字符串形式的排列格式为：</span><br><span class="hljs-comment">页索引数（记录数）&#x27;\0&#x27;</span><br><span class="hljs-comment">页容量（字节数）&#x27;\0&#x27;</span><br><span class="hljs-comment">记录大小 &#x27;\0&#x27; 记录内容</span><br><span class="hljs-comment">记录大小 &#x27;\0&#x27; 记录内容</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">&#x27;\0&#x27;(页结束标志)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Page</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Page</span>(std::string &amp;data);  <span class="hljs-comment">// 以字符串填充页</span><br>  <span class="hljs-function">std::string <span class="hljs-title">to_string</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 页数据转换成字符串</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;data, <span class="hljs-type">int</span> &amp;start)</span></span>;  <span class="hljs-comment">// 字符串转数字</span><br>  <span class="hljs-function">std::string <span class="hljs-title">get_string</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;                   <span class="hljs-comment">// 数字转字符串</span><br><br>  std::vector&lt;std::string&gt; m_value_;  <span class="hljs-comment">// 以vector存储记录</span><br>  std::vector&lt;std::string&gt; m_key_;    <span class="hljs-comment">// 以vector存储记录</span><br>  <span class="hljs-type">uint32_t</span> m_cur_size_;               <span class="hljs-comment">// 当前页数据大小</span><br>  <span class="hljs-type">uint32_t</span> m_cur_index_;              <span class="hljs-comment">// 当前索引</span><br>&#125;;<br><br><span class="hljs-comment">// 将start为起点的字符串转换成数字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Page::get_size</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;data, <span class="hljs-type">int</span> &amp;start)</span> </span>&#123;<br>  std::string size_str = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-type">int</span> value_size = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (data[start] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;  <span class="hljs-comment">// 未遇到结束标志，加入字符串</span><br>      size_str.<span class="hljs-built_in">push_back</span>(data[start]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (!size_str.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 字符串不为空，转换成数字</span><br>        value_size = std::<span class="hljs-built_in">stoi</span>(size_str);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    start++;<br>  &#125;<br>  start++;            <span class="hljs-comment">// 跳过当前的结束字符</span><br>  <span class="hljs-keyword">return</span> value_size;  <span class="hljs-comment">// 页末尾结束字符返回0</span><br>&#125;<br><br><span class="hljs-comment">// 将数字转换成字符串并在其后填充结束字符</span><br><span class="hljs-function">std::string <span class="hljs-title">Page::get_string</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">to_string</span>(size);<br>  res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>Page::<span class="hljs-built_in">Page</span>(std::string &amp;data) &#123;<br>  <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> value_num = <span class="hljs-built_in">get_size</span>(data, start);  <span class="hljs-comment">// 读取记录数</span><br>  <span class="hljs-type">int</span> page_size = <span class="hljs-built_in">get_size</span>(data, start);  <span class="hljs-comment">// 读取页大小</span><br>  m_key_.<span class="hljs-built_in">reserve</span>(value_num);<br>  m_value_.<span class="hljs-built_in">reserve</span>(value_num);<br><br>  m_cur_index_ = value_num;<br>  m_cur_size_ = page_size;<br>  std::string kv;<br>  <span class="hljs-type">int</span> value_size;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <span class="hljs-comment">// 循环读取记录</span><br>    value_size = <span class="hljs-built_in">get_size</span>(data, start);<br>    <span class="hljs-keyword">if</span> (value_size &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 遇到页末尾结束字符则返回</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    kv = data.<span class="hljs-built_in">substr</span>(start, value_size);<br>    start += value_size;<br>    m_key_.<span class="hljs-built_in">emplace_back</span>(kv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span>));<br>    m_value_.<span class="hljs-built_in">emplace_back</span>(kv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">16</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">Page::to_string</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span> != <span class="hljs-literal">nullptr</span>);<br>  std::string data;<br>  data.<span class="hljs-built_in">reserve</span>(m_cur_size_ + m_cur_index_ * <span class="hljs-number">6</span>);  <span class="hljs-comment">// 提前预订字符串空间</span><br>  data.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">get_string</span>(m_cur_index_));         <span class="hljs-comment">// 加入记录数</span><br>  data.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">get_string</span>(m_cur_size_));          <span class="hljs-comment">// 加入页大小</span><br>  <span class="hljs-built_in">assert</span>(m_cur_index_ == m_key_.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-built_in">assert</span>(m_key_.<span class="hljs-built_in">size</span>() == m_value_.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    data.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">get_string</span>(<span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">length</span>()));  <span class="hljs-comment">// 加入记录大小</span><br>    data.<span class="hljs-built_in">append</span>(m_key_[i]);                              <span class="hljs-comment">// 加入记录数据</span><br>    data.<span class="hljs-built_in">append</span>(m_value_[i]);<br>  &#125;<br>  data.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);  <span class="hljs-comment">// 页末尾填充结束字符</span><br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p>而后稍微改变一下编码方式，将记录大小全部放在头部，记录数据放在尾部。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">页数据字符串形式的排列格式为：</span><br><span class="hljs-comment">页索引数（记录数）&#x27;\0&#x27;</span><br><span class="hljs-comment">页容量（字节数）&#x27;\0&#x27;</span><br><span class="hljs-comment">记录大小&#x27;\0&#x27;</span><br><span class="hljs-comment">记录大小&#x27;\0&#x27;</span><br><span class="hljs-comment">记录内容(key value)</span><br><span class="hljs-comment">记录内容(key value)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">保存key值以便在rebuild时能够更改元数据信息</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Page</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Page</span>();<br>  <span class="hljs-built_in">Page</span>(std::string &amp;data);            <span class="hljs-comment">// 以字符串填充页</span><br>  <span class="hljs-function">std::string <span class="hljs-title">to_string</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 页数据转换成字符串</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function">std::string <span class="hljs-title">get_string</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;  <span class="hljs-comment">// 数字转字符串</span><br><br>  std::string m_key_[kMaxIndex];<br>  std::string m_value_[kMaxIndex];<br>  <span class="hljs-type">uint32_t</span> m_cur_size_;   <span class="hljs-comment">// 当前页数据大小</span><br>  <span class="hljs-type">uint32_t</span> m_cur_index_;  <span class="hljs-comment">// 当前索引</span><br><br>  <span class="hljs-comment">// std::vector&lt;std::string&gt; m_value_;  // 以vector存储key值，方便rebuild时更新元数据</span><br>  <span class="hljs-comment">// std::vector&lt;std::string&gt; m_key_;    // 以vector存储记录</span><br>&#125;;<br><br><span class="hljs-function">std::string <span class="hljs-title">Page::to_string</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string data;<br>  data.<span class="hljs-built_in">reserve</span>(m_cur_size_ + m_cur_index_ * <span class="hljs-number">4</span>);  <span class="hljs-comment">// 提前预订字符串空间</span><br>  data.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">get_string</span>(m_cur_index_));         <span class="hljs-comment">// 加入记录数</span><br>  data.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">get_string</span>(m_cur_size_));          <span class="hljs-comment">// 加入页大小</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;  <span class="hljs-comment">// 加入各个记录大小</span><br>    data.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">get_string</span>(<span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">size</span>()));<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    data.<span class="hljs-built_in">append</span>(m_key_[i]);  <span class="hljs-comment">// 加入记录数据</span><br>    data.<span class="hljs-built_in">append</span>(m_value_[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br>Page::<span class="hljs-built_in">Page</span>(std::string &amp;str) &#123;<br>  std::string::size_type pos;<br>  std::string::size_type size = str.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-comment">// 获取页大小与最大记录数</span><br>  <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>  pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;\0&#x27;</span>, start);<br>  m_cur_index_ = std::<span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(start, pos - start));<br>  start = pos + <span class="hljs-number">1</span>;<br>  pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;\0&#x27;</span>, start);<br>  m_cur_size_ = std::<span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(start, pos - start));<br>  start = pos + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 获取各个记录长度</span><br>  <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">record_lengths</span><span class="hljs-params">(m_cur_index_)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;\0&#x27;</span>, start);<br>    record_lengths[i] = std::<span class="hljs-built_in">stoi</span>(str.<span class="hljs-built_in">substr</span>(start, pos - start));<br>    start = pos + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 获取各个记录内容</span><br>  <span class="hljs-type">int</span> record_num = record_lengths.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; record_num; i++) &#123;<br>    m_key_[i] = str.<span class="hljs-built_in">substr</span>(start, <span class="hljs-number">16</span>);<br>    m_value_[i] = str.<span class="hljs-built_in">substr</span>(start + <span class="hljs-number">16</span>, record_lengths[i] - <span class="hljs-number">16</span>);<br>    start += record_lengths[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候编码解码比之前稍微简单一点（去掉了get_size函数），但将长度编码进字符串的方式还是觉得有点低效。后面一想，为什么不直接把大字符串视作一个整数数组，对数组元素赋值就可以了，也就是说 <strong>123没必要转换成’1’ ‘2’ ‘3’后存入数组（3个字节），而是直接对一个short类型（2字节）的数赋值。</strong> 这样就不再需要编码额外的结束字符作为标记了。</p><p>字符数组的头部存储各种元数据，尾部存储实际key-value数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">u16存储</span><br><span class="hljs-comment">记录数</span><br><span class="hljs-comment">页大小</span><br><span class="hljs-comment">各记录大小</span><br><span class="hljs-comment">char存储</span><br><span class="hljs-comment">各个记录（kv）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">std::string <span class="hljs-title">Page::to_string</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string data;<br>  data.<span class="hljs-built_in">resize</span>(kAllocSize);<br>  <span class="hljs-type">uint16_t</span> data_start = (m_cur_index_ + <span class="hljs-number">5</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint16_t</span>);         <span class="hljs-comment">// 从该偏移开始存储实际的数据</span><br>  <span class="hljs-type">char</span> *char_pointer = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(data.<span class="hljs-built_in">c_str</span>());               <span class="hljs-comment">// 移除常量性</span><br>  <span class="hljs-type">uint16_t</span> *u16_pointer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint16_t</span> *&gt;(char_pointer);  <span class="hljs-comment">// 解释为u32指针</span><br><br>  u16_pointer[<span class="hljs-number">0</span>] = m_cur_index_;<br>  u16_pointer[<span class="hljs-number">1</span>] = m_cur_size_;<br>  <span class="hljs-type">uint16_t</span> offset = data_start;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;  <span class="hljs-comment">// 加入各个记录起始地址</span><br>    u16_pointer[i + <span class="hljs-number">2</span>] = offset;<br>    offset += <span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">size</span>();<br>  &#125;<br>  u16_pointer[m_cur_index_ + <span class="hljs-number">2</span>] = offset;  <span class="hljs-comment">// 实际数据最终偏移</span><br>  <span class="hljs-type">char</span> *p = char_pointer + data_start;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    <span class="hljs-built_in">memcpy</span>(p, m_key_[i].<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">memcpy</span>(p + <span class="hljs-number">16</span>, m_value_[i].<span class="hljs-built_in">c_str</span>(), m_value_[i].<span class="hljs-built_in">size</span>());<br>    p += <span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">size</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br>Page::<span class="hljs-built_in">Page</span>(std::string &amp;data) &#123;<br>  <span class="hljs-type">char</span> *char_pointer = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(data.<span class="hljs-built_in">c_str</span>());               <span class="hljs-comment">// 移除常量性</span><br>  <span class="hljs-type">uint16_t</span> *u16_pointer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint16_t</span> *&gt;(char_pointer);  <span class="hljs-comment">// 解释为u32指针</span><br>  m_cur_index_ = u16_pointer[<span class="hljs-number">0</span>];<br>  m_cur_size_ = u16_pointer[<span class="hljs-number">1</span>];<br>  <span class="hljs-type">uint16_t</span> offset, length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    offset = u16_pointer[i + <span class="hljs-number">2</span>];<br>    length = u16_pointer[i + <span class="hljs-number">3</span>] - u16_pointer[i + <span class="hljs-number">2</span>];<br>    m_key_[i] = data.<span class="hljs-built_in">substr</span>(offset, <span class="hljs-number">16</span>);<br>    m_value_[i] = data.<span class="hljs-built_in">substr</span>(offset + <span class="hljs-number">16</span>, length - <span class="hljs-number">16</span>);<br>  &#125;<br>  m_is_dirty_ = <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>后面发现leveldb中用了以下这种编码形式<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84250836">详解varint编码原理</a></p><h3 id="pragma-pack使用错误"><a href="#pragma-pack使用错误" class="headerlink" title="#pragma pack使用错误"></a>#pragma pack使用错误</h3><p>本地缓存总共8G空间，有5G是存储key的元数据。其结构体定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-type">page_id_t</span> = <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-type">index_t</span> = <span class="hljs-type">uint16_t</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data_info_t</span> &#123;  <span class="hljs-comment">// 数据信息</span><br>  <span class="hljs-type">page_id_t</span> page_id;  <span class="hljs-comment">// 页号</span><br>  <span class="hljs-type">index_t</span> index;      <span class="hljs-comment">// 索引</span><br>&#125;;<br><br><span class="hljs-comment">/* One slot stores the key and the meta info of the value which</span><br><span class="hljs-comment">   describles the remote addr, size, remote-key on remote end. */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map_slot</span> &#123;<br>  <span class="hljs-type">char</span> key[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">data_info_t</span> info;<br>  hash_map_slot *next;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map_slot_test</span> &#123;<br>  <span class="hljs-type">char</span> key[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">data_info_t</span> info;<br>  hash_map_slot *next;<br>&#125;;<br><span class="hljs-comment">// 没有#pragma pack()</span><br></code></pre></td></tr></table></figure><p>可以看到struct data_info_t占4字节，但struct hash_map_slot因为对齐的原因占32字节。自然而然的，为了节省空间，可以强制结构体4字节对齐，这样就能节省4字节的空间，也就节省了1&#x2F;8的空间。但由于不熟悉#pragma pack，#pragma pack(4)并没有以#pragma pack()结束。然后一运行程序就段错误，gdb调试时bt显示调用栈，f3时传递参数为32位，f2突然截断，参数变成了16位。我觉得这个错误过于诡异，因为就修改了字节对齐，故到比赛结束我都没再用#pragma pack，一般也不建议使用#pragma pack。<br>示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-type">page_id_t</span> = <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-type">index_t</span> = <span class="hljs-type">uint16_t</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data_info_t</span> &#123;  <span class="hljs-comment">// 数据信息</span><br>  <span class="hljs-type">page_id_t</span> page_id;  <span class="hljs-comment">// 页号</span><br>  <span class="hljs-type">index_t</span> index;      <span class="hljs-comment">// 索引</span><br>&#125;;<br><br><span class="hljs-comment">/* One slot stores the key and the meta info of the value which</span><br><span class="hljs-comment">   describles the remote addr, size, remote-key on remote end. */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map_slot</span> &#123;<br>  <span class="hljs-type">char</span> key[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">data_info_t</span> info;<br>  hash_map_slot *next;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map_slot_test</span> &#123;<br>  <span class="hljs-type">char</span> key[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">data_info_t</span> info;<br>  hash_map_slot_test *next;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(hash_map_slot) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(hash_map_slot_test) &lt;&lt; endl;<br>  hash_map_slot slot1;<br>  hash_map_slot_test slot2;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hash_map_slot layout:\n%p  \n%p  \n%p\n&quot;</span>, &amp;(slot1.key), &amp;(slot1.info), &amp;(slot1.next));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hash_map_slot test layout:\n%p  \n%p  \n%p\n&quot;</span>, &amp;(slot2.key), &amp;(slot2.info), &amp;(slot2.next));<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">32</span><br><span class="hljs-comment">28</span><br><span class="hljs-comment">hash_map_slot layout:</span><br><span class="hljs-comment">0x7ffef416d1f0  </span><br><span class="hljs-comment">0x7ffef416d200  </span><br><span class="hljs-comment">0x7ffef416d208</span><br><span class="hljs-comment">hash_map_slot test layout:</span><br><span class="hljs-comment">0x7ffef416d1d0  </span><br><span class="hljs-comment">0x7ffef416d1e0  </span><br><span class="hljs-comment">0x7ffef416d1e4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>相关博客：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangzhengzheng95/article/details/122529751">C&#x2F;C++中结构体内存对齐（边界对齐），#pragma pack设置</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/allenlinrui/article/details/77858058">关于#pragma pack(n)引发的一系列问题</a></p><h3 id="右值引用本身是左值"><a href="#右值引用本身是左值" class="headerlink" title="右值引用本身是左值"></a>右值引用本身是左值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Test&amp;&amp; t)</span></span>;<br><span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Test&amp; t)</span></span>;<br><br>Test t1<br>Test&amp;&amp; t2 = std::<span class="hljs-built_in">move</span>(t1);<br><span class="hljs-built_in">func</span>(t2);<br></code></pre></td></tr></table></figure><p>对于右值引用我一直有一个误区，认为右值引用是右值，例如以上代码片段，实参类型为Test&amp;&amp;，很容易认为此时调用的函数为第二个，但实际上此时调用的却是第一个。这是因为右值引用本身是左值，更为具体来说，<strong>右值引用类型既可以被当作左值也可以被当作右值，判断的标准是，如果它有名字，那就是左值，否则就是右值</strong>。</p><p>示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test &amp;test) : <span class="hljs-built_in">str</span>(test.str) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter copy construction\n&quot;</span>); &#125;<br>  <span class="hljs-built_in">Test</span>(Test &amp;&amp;test) : <span class="hljs-built_in">str</span>(std::<span class="hljs-built_in">move</span>(test.str)) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter move construction\n&quot;</span>); &#125;<br><br>  Test &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test &amp;test) &#123;<br>    str = test.str;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter copy assign\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  Test &amp;<span class="hljs-keyword">operator</span>=(Test &amp;&amp;test) &#123;<br>    str = std::<span class="hljs-built_in">move</span>(test.str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter move assign\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  string str;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Test p1, p2, p3;<br>  Test &amp;&amp;p4 = std::<span class="hljs-built_in">move</span>(p3);<br><br>  <span class="hljs-function">Test <span class="hljs-title">p5</span><span class="hljs-params">(p1)</span></span>;             <span class="hljs-comment">// 调用复制构造</span><br>  <span class="hljs-function">Test <span class="hljs-title">p6</span><span class="hljs-params">(std::move(p2))</span></span>;  <span class="hljs-comment">// 调用移动构造</span><br>  <span class="hljs-function">Test <span class="hljs-title">p7</span><span class="hljs-params">(p4)</span></span>;             <span class="hljs-comment">// 调用复制构造</span><br><br>  Test t1, t2, t3, t4;<br>  Test &amp;&amp;t5 = std::<span class="hljs-built_in">move</span>(t4);<br>  t1 = t2;             <span class="hljs-comment">// 调用复制赋值</span><br>  t1 = std::<span class="hljs-built_in">move</span>(t3);  <span class="hljs-comment">// 调用移动赋值</span><br>  t1 = t5;             <span class="hljs-comment">// 调用复制赋值（误区）</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">enter copy construction</span><br><span class="hljs-comment">enter move construction</span><br><span class="hljs-comment">enter copy construction</span><br><span class="hljs-comment">enter copy assign</span><br><span class="hljs-comment">enter move assign</span><br><span class="hljs-comment">enter copy assign</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>实际上使用vscode将鼠标点到函数调用的地方就能看到所调用的函数<br><img src="https://img-blog.csdnimg.cn/fd1e0c108e0246deb52157211fd8acb1.png" srcset="/img/loading.gif" lazyload><br><img src="https://img-blog.csdnimg.cn/491fcc474b6a4c4e83f190a936218ccd.png" srcset="/img/loading.gif" lazyload><br><mark>注意move后不应该再使用变量值</mark><br>我有一次错误就在于调用move函数后仍然使用对象的size方法，导致未定义的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(std::move(a))</span></span>;<br>  a = std::<span class="hljs-built_in">move</span>(b);<br>  b = std::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br><br>X a, b;<br><span class="hljs-built_in">swap</span>(a, b);<br></code></pre></td></tr></table></figure><p>参考博客：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiu0821/p/7920837.html">详解C++右值引用</a></p><h3 id="其余优化"><a href="#其余优化" class="headerlink" title="其余优化"></a>其余优化</h3><p><strong>读者互斥锁</strong><br>当读请求未命中时，程序需读取远端的字符串数据，并将其解码成string数组（Page类），插入本地缓存后再读取value；该操作耗时较长，且没必要持有锁；但如果多个请求同时请求该远端页，如果让每一个请求都读取远端页，既浪费IO资源，也没啥实际用处；故增加一个读者互斥锁，保证每一页只有一个读者正在请求远端页，其余请求同一远端页的读者会阻塞互斥锁前；待读取远端页的读者读取页数据完成并将该页插入本地缓存中，其余读者发现本地缓存已存在该页，就不会重复读取远端页了。<br>相关代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (m_data_map_[info.page_id] == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 数据在远端内存</span><br>  m_mutex_.<span class="hljs-built_in">unlock</span>();<br>  m_same_reader_mutex_[info.page_id].<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">// 读者互斥</span><br>  <span class="hljs-keyword">if</span> (m_data_map_[info.page_id] == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 双重检查</span><br>    <span class="hljs-keyword">auto</span> remote_info = m_addr_map_[info.page_id];<br>    std::string &amp;&amp;page_data = std::<span class="hljs-built_in">string</span>(remote_info.size, <span class="hljs-string">&#x27;0&#x27;</span>);<br>    m_rdma_conn_-&gt;<span class="hljs-built_in">remote_read</span>((<span class="hljs-type">void</span> *)page_data.<span class="hljs-built_in">c_str</span>(), remote_info.size, remote_info.remote_addr, remote_info.rkey);<br>    <span class="hljs-keyword">auto</span> new_page = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;(page_data);  <span class="hljs-comment">// 构建缓存页</span><br>    m_mutex_.<span class="hljs-built_in">lock</span>();<br>    m_data_map_[info.page_id] = new_page;<br>    m_cache_size_++;<br>    m_lru_list_.<span class="hljs-built_in">insert</span>(info.page_id);<br>    need_update_lru = <span class="hljs-literal">false</span>;<br>    m_addr_map_.<span class="hljs-built_in">erase</span>(info.page_id);    <span class="hljs-comment">// 在远端地址映射中删除该项</span><br>    m_addr_list_.<span class="hljs-built_in">emplace</span>(remote_info);  <span class="hljs-comment">// 将该页加入地址列表</span><br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-comment">// 尝试唤醒后台进程</span><br>    <span class="hljs-keyword">if</span> (m_cache_size_ &gt; kPageThreshold) &#123;<br>      m_cv_.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>  &#125;<br>  m_same_reader_mutex_[info.page_id].<span class="hljs-built_in">unlock</span>();<br>  m_mutex_.<span class="hljs-built_in">lock</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>时不时用sizeof看看占用空间，增加一个读者互斥锁相当于每页多了40字节，占比不大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;mutex:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(std::mutex) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot;shared_ptr:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(std::shared_ptr&lt;<span class="hljs-type">int</span>&gt;) &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">mutex:40</span><br><span class="hljs-comment">shared_ptr:16</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>LRU优化</strong><br>不论是读操作还是写操作，末尾都需要更新LRU列表；为了减小冲突，LRU采用独立的锁，不在m_mutex_锁内更新；当前页（新申请的页）并不加入LRU列表，也不会被淘汰，待当前页写满后再插入到LRU列表中；上次LRU更新的页本次也不再更新（已在队首）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (info.page_id != m_last_update_id_ &amp;&amp; info.page_id != m_cur_page_id_ &amp;&amp; need_update_lru) &#123;<br>  m_lru_list_.<span class="hljs-built_in">update</span>(info.page_id);<br>  m_last_update_id_ = info.page_id;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>map改成数组 vector改数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">由于最大页号确定，map&lt;page_id,page&gt;改成了page[max_page_id];<br>由于页最大记录数确定，std::vector&lt;std::string&gt; m_value_变成了std::string m_value_[kMaxIndex]; <br>通过使用固定的数据结构，减少了扩容带来的开销。<br></code></pre></td></tr></table></figure><h3 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h3><blockquote><p>程序正确性预设<br>1：运行中页号不得超过kBitmapSize，页中记录数不得超过kMaxIndex，页导出字符串长度不得超过kAllocSize<br>2：程序经历连续的删除操作后才进入读写操作，使得rebuild最大化。在删除之前远端内存足容纳所有数据<br>3：即使每次插入时会检查当前页是否已满，但仍然无法阻止程序通过更新value值来增大页大小，所以页数据大小大于kAllocSize便会出现问题<br>4：kAllocSize小于65536，页成员就可以使用uint16存储,大于则需要使用uint32存储<br>5：mutex之外的操作耗时极短，可以在rebuild处理前完成</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>: debug时系统高效充分打印所需的信息<br><span class="hljs-number">2</span>：架构越简洁。越不容易出错<br><span class="hljs-number">3</span>: 可编写简单的测试用例检验模块的正确性<br><span class="hljs-number">4</span>: 利用<span class="hljs-keyword">sizeof</span>和system_clock简单估计内存占用与执行速度<br><span class="hljs-number">5</span>  右值引用变量在用于表达式时是左值，move后不应该再使用变量值<br><span class="hljs-type">int</span> &amp;&amp;x = <span class="hljs-number">1</span>;<br>f(x);             <span class="hljs-comment">// 调用 f(int&amp; x)</span><br>f(<span class="hljs-built_in">std</span>::move(x));  <span class="hljs-comment">// 调用 f(int&amp;&amp; x)</span><br><span class="hljs-number">6</span> 编写代码时明确锁所维持的不变量是什么，而不是仅仅确保操作的原子性<br>m_mutex_：确保保护成员操作的原子性，并保证页数据仅存在本地（m_data_map_）与远端（m_addr_map_）中的一个位置<br>m_remote_read_lock_：淘汰时在数据真正写入前阻塞对应页的请求<br></code></pre></td></tr></table></figure><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p><strong>Engine</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// kv_engine.h</span><br><span class="hljs-keyword">namespace</span> kv &#123;<br><br><span class="hljs-comment">/* Encryption algorithm competitor can choose. */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">aes_algorithm</span> &#123; CTR = <span class="hljs-number">0</span>, CBC, CBC_CS1, CBC_CS2, CBC_CS3, CFB, OFB &#125;;<br><br><span class="hljs-comment">/* Algorithm relate message. */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">crypto_message_t</span> &#123;<br>  aes_algorithm algo;<br>  Ipp8u *key;<br>  Ipp32u key_len;<br>  Ipp8u *counter;<br>  Ipp32u counter_len;<br>  Ipp8u *piv;<br>  Ipp32u piv_len;<br>  Ipp32u blk_size;<br>  Ipp32u counter_bit;<br><br>  IppsAESSpec *ctx;<br>&#125; <span class="hljs-type">crypto_message_t</span>;<br><br><span class="hljs-comment">/* Abstract base engine */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Engine</span>()&#123;&#125;;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string addr, <span class="hljs-type">const</span> std::string port)</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">alive</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalEngineEntity</span>;  <span class="hljs-comment">// 前置声明</span><br><span class="hljs-comment">/* Local-side engine */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalEngine</span> : <span class="hljs-keyword">public</span> Engine &#123;<br> <span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">LocalEngine</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string addr, <span class="hljs-type">const</span> std::string port)</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">alive</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br>  <span class="hljs-comment">/* Init aes context message. */</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">set_aes</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">encrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;value, std::string &amp;encrypt_value)</span></span>;<br><br>  <span class="hljs-comment">/* Evaluation problem will call this function. */</span><br>  <span class="hljs-function"><span class="hljs-type">crypto_message_t</span> *<span class="hljs-title">get_aes</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;m_aes_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> std::string &amp;value, <span class="hljs-type">bool</span> use_aes = <span class="hljs-literal">false</span>)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, std::string &amp;value)</span></span>;<br>  <span class="hljs-comment">/** The delete interface */</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deleteK</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span></span>;<br><br>  <span class="hljs-comment">/** Rebuild the hash index to recycle the unsed memory */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild_index</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// static inline int get_index(const std::string &amp;key) &#123; return std::hash&lt;std::string&gt;()(key) &amp; (kSharedNumber - 1); &#125;</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get_index</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">CityHash16</span>(key.<span class="hljs-built_in">c_str</span>()) &amp; (kSharedNumber - <span class="hljs-number">1</span>); &#125;<br>  kv::ConnectionManager *m_rdma_conn_;<br>  <span class="hljs-comment">// /* <span class="hljs-doctag">NOTE:</span> should use some concurrent data structure, and also should take the</span><br>  <span class="hljs-comment">//  * extra memory overhead into consideration */</span><br>  <span class="hljs-comment">// RDMAMemPool *m_rdma_mem_pool_;</span><br><br>  <span class="hljs-type">crypto_message_t</span> m_aes_;<br><br>  LocalEngineEntity *m_entity_[kSharedNumber];  <span class="hljs-comment">// 执行请求的实体</span><br>&#125;;<br><br><span class="hljs-comment">/* Remote-side engine */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteEngine</span> : <span class="hljs-keyword">public</span> Engine &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">WorkerInfo</span> &#123;<br>    CmdMsgBlock *cmd_msg;<br>    CmdMsgRespBlock *cmd_resp_msg;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ibv_mr</span> *msg_mr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ibv_mr</span> *resp_mr;<br>    rdma_cm_id *cm_id;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ibv_cq</span> *cq;<br>  &#125;;<br><br>  ~<span class="hljs-built_in">RemoteEngine</span>()&#123;&#125;;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string addr, <span class="hljs-type">const</span> std::string port)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">alive</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_connection</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_connection</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rdma_cm_id *cm_id)</span></span>;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ibv_mr</span> *<span class="hljs-built_in">rdma_register_memory</span>(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">uint64_t</span> size);<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">remote_write</span><span class="hljs-params">(WorkerInfo *work_info, <span class="hljs-type">uint64_t</span> local_addr, <span class="hljs-type">uint32_t</span> lkey, <span class="hljs-type">uint32_t</span> length, <span class="hljs-type">uint64_t</span> remote_addr, <span class="hljs-type">uint32_t</span> rkey)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">allocate_and_register_memory</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> &amp;addr, <span class="hljs-type">uint32_t</span> &amp;rkey, <span class="hljs-type">uint64_t</span> size)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(WorkerInfo *work_info, <span class="hljs-type">uint32_t</span> num)</span></span>;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rdma_event_channel</span> *m_cm_channel_;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rdma_cm_id</span> *m_listen_id_;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ibv_pd</span> *m_pd_;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ibv_context</span> *m_context_;<br>  <span class="hljs-type">bool</span> m_stop_;<br>  std::thread *m_conn_handler_;<br>  WorkerInfo **m_worker_info_;<br>  <span class="hljs-type">uint32_t</span> m_worker_num_;<br>  std::thread **m_worker_threads_;<br>&#125;;<br><br>&#125;  <span class="hljs-comment">// namespace kv</span><br><br><br><span class="hljs-comment">// local_engine.cc</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;assert.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;atomic&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kv_engine.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;local_engine_entity.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> kv &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: start local engine service</span><br><span class="hljs-comment"> * @param &#123;string&#125; addr    the address string of RemoteEngine to connect</span><br><span class="hljs-comment"> * @param &#123;string&#125; port   the port of RemoteEngine to connect</span><br><span class="hljs-comment"> * @return &#123;bool&#125; true for success</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::start</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string addr, <span class="hljs-type">const</span> std::string port)</span> </span>&#123;<br>  m_rdma_conn_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConnectionManager</span>();<br>  <span class="hljs-keyword">if</span> (m_rdma_conn_ == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (m_rdma_conn_-&gt;<span class="hljs-built_in">init</span>(addr, port, <span class="hljs-number">4</span>, <span class="hljs-number">72</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kSharedNumber; i++) &#123;<br>    m_entity_[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LocalEngineEntity</span>(<span class="hljs-keyword">this</span>, m_rdma_conn_);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LocalEngine::start finsh\n&quot;</span>);<br>  <span class="hljs-keyword">auto</span> watcher = std::<span class="hljs-built_in">thread</span>([]() &#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">60</span> * <span class="hljs-number">9</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout\n&quot;</span>);<br>    <span class="hljs-built_in">fflush</span>(stdout);<br>    <span class="hljs-built_in">abort</span>();<br>  &#125;);<br>  watcher.<span class="hljs-built_in">detach</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: stop local engine service</span><br><span class="hljs-comment"> * @return &#123;void&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LocalEngine::stop</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kSharedNumber; i++) &#123;<br>    <span class="hljs-keyword">delete</span> m_entity_[i];<br>  &#125;<br>  <span class="hljs-keyword">delete</span> m_rdma_conn_;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LocalEngine::stop finsh\n&quot;</span>);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: get engine alive state</span><br><span class="hljs-comment"> * @return &#123;bool&#125;  true for alive</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::alive</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: provide message about the aes_ecb mode</span><br><span class="hljs-comment"> * @return &#123;bool&#125;  true for success</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::set_aes</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Current algorithm is not supported, just for demonstration.</span><br>  m_aes_.algo = CBC;<br>  m_aes_.key_len = <span class="hljs-number">16</span>;<br>  m_aes_.key = <span class="hljs-keyword">new</span> Ipp8u[<span class="hljs-number">16</span>]&#123;<span class="hljs-number">0x60</span>, <span class="hljs-number">0x3d</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0xca</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0x2b</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0xae</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x7d</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x81</span>&#125;;<br>  <span class="hljs-keyword">if</span> (m_aes_.key == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  m_aes_.blk_size = <span class="hljs-number">16</span>;<br>  m_aes_.piv_len = <span class="hljs-number">16</span>;<br>  m_aes_.piv = <span class="hljs-keyword">new</span> Ipp8u[<span class="hljs-number">16</span>]&#123;<span class="hljs-number">0x0f</span>, <span class="hljs-number">0x0e</span>, <span class="hljs-number">0x0d</span>, <span class="hljs-number">0x0c</span>, <span class="hljs-number">0x0b</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x09</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>&#125;;<br>  <span class="hljs-keyword">if</span> (m_aes_.piv == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-type">int</span> ctxSize;               <span class="hljs-comment">// AES context size</span><br>  <span class="hljs-built_in">ippsAESGetSize</span>(&amp;ctxSize);  <span class="hljs-comment">// evaluating AES context size</span><br>  <span class="hljs-comment">// allocatting memory for AES context</span><br>  m_aes_.ctx = (IppsAESSpec *)(<span class="hljs-keyword">new</span> Ipp8u[ctxSize]);<br>  <span class="hljs-comment">// AES context initialization</span><br>  <span class="hljs-built_in">ippsAESInit</span>(m_aes_.key, m_aes_.key_len, m_aes_.ctx, ctxSize);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 参考pdf实现简单加密算法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::encrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;value, std::string &amp;encrypt_value)</span> </span>&#123;<br>  Ipp8u ciph[(value.<span class="hljs-built_in">size</span>() + m_aes_.blk_size - <span class="hljs-number">1</span>) &amp; ~(m_aes_.blk_size - <span class="hljs-number">1</span>)];<br>  <span class="hljs-comment">// encrypting plaintext</span><br>  <span class="hljs-built_in">ippsAESEncryptCBC</span>((Ipp8u *)value.<span class="hljs-built_in">c_str</span>(), ciph, value.<span class="hljs-built_in">size</span>(), m_aes_.ctx, m_aes_.piv);<br>  <span class="hljs-function">std::string <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(ciph), value.size())</span></span>;<br>  encrypt_value = std::<span class="hljs-built_in">move</span>(tmp);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> std::string &amp;value, <span class="hljs-type">bool</span> use_aes)</span> </span>&#123;<br>  <span class="hljs-type">int</span> index = <span class="hljs-built_in">get_index</span>(key);<br>  <span class="hljs-keyword">return</span> m_entity_[index]-&gt;<span class="hljs-built_in">write</span>(key, value, use_aes);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: read value from engine via key</span><br><span class="hljs-comment"> * @param &#123;string&#125; key</span><br><span class="hljs-comment"> * @param &#123;string&#125; &amp;value</span><br><span class="hljs-comment"> * @return &#123;bool&#125;  true for success</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::read</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, std::string &amp;value)</span> </span>&#123;<br>  <span class="hljs-type">int</span> index = <span class="hljs-built_in">get_index</span>(key);<br>  <span class="hljs-keyword">return</span> m_entity_[index]-&gt;<span class="hljs-built_in">read</span>(key, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngine::deleteK</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span> </span>&#123;<br>  <span class="hljs-type">int</span> index = <span class="hljs-built_in">get_index</span>(key);<br>  <span class="hljs-keyword">return</span> m_entity_[index]-&gt;<span class="hljs-built_in">deleteK</span>(key);<br>&#125;<br><span class="hljs-comment">/* When we delete a number of KV pairs, we should rebuild the index to</span><br><span class="hljs-comment"> * reallocate remote addr for each KV to recycle fragments. This will block</span><br><span class="hljs-comment"> * front request processing. This solution should be optimized. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LocalEngine::rebuild_index</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">/** rebuild all the index to recycle the fragment */</span><br>  <span class="hljs-comment">/** step-1: block the database and not allowe any writes</span><br><span class="hljs-comment">   *  step-2: transverse the index to read each value</span><br><span class="hljs-comment">   *  step-3: read the value from the remote and write it to a new remote addr</span><br><span class="hljs-comment">   *  step-4: free all old addr</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*********rebuild_index*********\n&quot;</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kSharedNumber; i++) &#123;<br>    m_entity_[i]-&gt;<span class="hljs-built_in">rebuild_index</span>();<br>  &#125;<br>&#125;<br><br>LocalEngine::~<span class="hljs-built_in">LocalEngine</span>() &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> != m_aes_.key) <span class="hljs-keyword">delete</span>[] m_aes_.key;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> != m_aes_.counter) <span class="hljs-keyword">delete</span>[] m_aes_.counter;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> != m_aes_.piv) <span class="hljs-keyword">delete</span>[] m_aes_.piv;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> != m_aes_.ctx) <span class="hljs-built_in">delete</span> (Ipp8u *)m_aes_.ctx;<br>  m_aes_.key = <span class="hljs-literal">nullptr</span>;<br>  m_aes_.counter = <span class="hljs-literal">nullptr</span>;<br>  m_aes_.piv = <span class="hljs-literal">nullptr</span>;<br>  m_aes_.ctx = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;  <span class="hljs-comment">// namespace kv</span><br><br></code></pre></td></tr></table></figure><p><strong>type</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// type.h</span><br><span class="hljs-keyword">namespace</span> kv &#123;<br><span class="hljs-keyword">using</span> <span class="hljs-type">page_id_t</span> = <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-type">index_t</span> = <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remote_info_t</span> &#123;  <span class="hljs-comment">// 远端内存信息</span><br>  <span class="hljs-type">uint64_t</span> remote_addr;<br>  <span class="hljs-type">uint32_t</span> rkey;<br>  <span class="hljs-type">uint32_t</span> size;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data_info_t</span> &#123;  <span class="hljs-comment">// 数据信息</span><br>  <span class="hljs-type">page_id_t</span> page_id;  <span class="hljs-comment">// 页号</span><br>  <span class="hljs-type">index_t</span> index;      <span class="hljs-comment">// 索引</span><br>&#125;;<br><br><span class="hljs-comment">/* One slot stores the key and the meta info of the value which</span><br><span class="hljs-comment">   describles the remote addr, size, remote-key on remote end. */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash_map_slot</span> &#123;<br>  <span class="hljs-type">char</span> key[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">data_info_t</span> info;<br>  hash_map_slot *next;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">page_id_t</span> kNullPage = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">data_info_t</span> kNullInfo = &#123;<span class="hljs-number">0xffff</span>, <span class="hljs-number">0xffff</span>&#125;;  <span class="hljs-comment">// 无效的信息</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kSharedNumber = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>;                                             <span class="hljs-comment">// 缓存实体数目</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kBucketNum = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>;                                          <span class="hljs-comment">// hash中bucket数</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kSlotSize = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">22</span>) * <span class="hljs-number">1.2</span> * <span class="hljs-number">32</span> / kSharedNumber;              <span class="hljs-comment">// hash中slot数</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> kMaxDataSize = (<span class="hljs-type">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">36</span>;                              <span class="hljs-comment">// 测试数据大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kPageSize = <span class="hljs-number">60</span> * <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>;                                      <span class="hljs-comment">// 页容量</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kMaxValueSize = <span class="hljs-number">1024</span>;                                          <span class="hljs-comment">// value最大值</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kMinValueSize = <span class="hljs-number">80</span>;                                            <span class="hljs-comment">// value最小值</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kMaxIndex = kPageSize / <span class="hljs-number">96</span>;                                    <span class="hljs-comment">// 页中最大记录数，96=80+16</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> kBitmapSize = <span class="hljs-number">1.4</span> * kMaxDataSize / kSharedNumber / kPageSize;  <span class="hljs-comment">// 运行过程中最大页号</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kAllocSize = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>;                                          <span class="hljs-comment">// 分配的远端内存大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kPageThreshold = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;                                       <span class="hljs-comment">// 本地存储页的阈值</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kEvictNumber = kPageThreshold * <span class="hljs-number">0.05</span>;                          <span class="hljs-comment">// 一次淘汰的页数</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kPrintFreq = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">24</span>;                                          <span class="hljs-comment">// 输出信息频率</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> kRebuildThreshold = (<span class="hljs-type">uint64_t</span>)(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) * <span class="hljs-number">36</span> / kSharedNumber;  <span class="hljs-comment">// 重建阈值</span><br><span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> kEralyRegisterNumber = (<span class="hljs-type">uint64_t</span>)(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) * <span class="hljs-number">30</span> / kSharedNumber / kAllocSize;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hash_map_t</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/* Initialize all the pointers to nullptr. */</span><br>  <span class="hljs-built_in">hash_map_t</span>();<br>  <span class="hljs-comment">// index为key对应hash值</span><br>  <span class="hljs-comment">/* Find the corresponding key. */</span><br>  <span class="hljs-function">hash_map_slot *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">int</span> index)</span></span>;<br><br>  <span class="hljs-comment">/* Insert into the head of the list. */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> <span class="hljs-type">data_info_t</span> &amp;info, <span class="hljs-type">int</span> index)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">data_info_t</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">int</span> index)</span></span>;<br>  <span class="hljs-comment">// 只在rebuild时用到</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> <span class="hljs-type">data_info_t</span> &amp;info)</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  hash_map_slot *m_bucket_[kBucketNum];<br>  hash_map_slot *m_slot_head_;                  <span class="hljs-comment">// 可用的slot链表头部，用于连接被删除元素的slot</span><br>  hash_map_slot m_hash_slot_array_[kSlotSize];  <span class="hljs-comment">// 哈希数组</span><br>  <span class="hljs-type">uint32_t</span> m_slot_cnt_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Page</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Page</span>(std::string &amp;data);  <span class="hljs-comment">// 以字符串填充页</span><br><br>  <span class="hljs-function">std::string <span class="hljs-title">to_string</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 页数据转换成字符串</span><br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">char</span> *ptr)</span></span>;<br>  <span class="hljs-built_in">Page</span>() : m_cur_size_&#123;<span class="hljs-number">0</span>&#125;, m_cur_index_&#123;<span class="hljs-number">0</span>&#125;, m_is_dirty_&#123;<span class="hljs-literal">true</span>&#125; &#123;&#125;;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_full</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_cur_size_ &gt; kPageSize; &#125;  <span class="hljs-comment">// 页是否满</span><br><br>  <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">page_size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_cur_size_; &#125;  <span class="hljs-comment">// 返回当前页大小</span><br><br>  <span class="hljs-function"><span class="hljs-type">index_t</span> <span class="hljs-title">record_number</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_cur_index_; &#125;  <span class="hljs-comment">// 返回记录数</span><br><br>  <span class="hljs-function"><span class="hljs-type">index_t</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> std::string &amp;value)</span> </span>&#123;<br>    m_cur_size_ += <span class="hljs-number">16</span> + value.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 加上key的长度</span><br>    m_key_[m_cur_index_] = key;<br>    m_value_[m_cur_index_] = value;<br>    <span class="hljs-keyword">return</span> m_cur_index_++;  <span class="hljs-comment">// 返回当前索引并加一</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">index_t</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, std::string &amp;&amp;value)</span> </span>&#123;<br>    m_cur_size_ += <span class="hljs-number">16</span> + value.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 加上key的长度</span><br>    m_key_[m_cur_index_] = key;<br>    m_value_[m_cur_index_] = std::<span class="hljs-built_in">move</span>(value);<br>    <span class="hljs-keyword">return</span> m_cur_index_++;  <span class="hljs-comment">// 返回当前索引并加一</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">index_t</span> index, <span class="hljs-type">const</span> std::string &amp;value)</span> </span>&#123;<br>    m_is_dirty_ = <span class="hljs-literal">true</span>;<br>    m_cur_size_ -= m_value_[index].<span class="hljs-built_in">size</span>();<br>    m_cur_size_ += value.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 更新页当前大小</span><br>    m_value_[index] = value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">index_t</span> index, std::string &amp;&amp;value)</span> </span>&#123;<br>    m_is_dirty_ = <span class="hljs-literal">true</span>;<br>    m_cur_size_ -= m_value_[index].<span class="hljs-built_in">size</span>();<br>    m_cur_size_ += value.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 更新页当前大小</span><br>    m_value_[index] = std::<span class="hljs-built_in">move</span>(value);<br>  &#125;<br><br>  <span class="hljs-function">std::string <span class="hljs-title">read_value</span><span class="hljs-params">(<span class="hljs-type">index_t</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> m_value_[index]; &#125;<br><br>  <span class="hljs-function">std::string <span class="hljs-title">read_key</span><span class="hljs-params">(<span class="hljs-type">index_t</span> index)</span> </span>&#123; <span class="hljs-keyword">return</span> m_key_[index]; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_dirty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_is_dirty_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::string m_key_[kMaxIndex];<br>  std::string m_value_[kMaxIndex];<br>  <span class="hljs-type">uint16_t</span> m_cur_size_;  <span class="hljs-comment">// 当前页数据大小</span><br>  <span class="hljs-type">index_t</span> m_cur_index_;  <span class="hljs-comment">// 当前索引</span><br>  <span class="hljs-type">bool</span> m_is_dirty_;<br><br>  <span class="hljs-comment">// std::vector&lt;std::string&gt; m_value_;  // 以vector存储key值，方便rebuild时更新元数据</span><br>  <span class="hljs-comment">// std::vector&lt;std::string&gt; m_key_;    // 以vector存储记录</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUList</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LRUList</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> hit_id)</span> </span>&#123;<br>    m_mutex_.<span class="hljs-built_in">lock</span>();<br>    m_list_.<span class="hljs-built_in">emplace_front</span>(hit_id);<br>    m_speed_map_.<span class="hljs-built_in">insert</span>(&#123;hit_id, m_list_.<span class="hljs-built_in">begin</span>()&#125;);<br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> hit_id)</span> </span>&#123;<br>    m_mutex_.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">auto</span> iter = m_speed_map_[hit_id];<br>    <span class="hljs-keyword">if</span> (iter != m_list_.<span class="hljs-built_in">begin</span>()) &#123;  <span class="hljs-comment">// 将该页移至队首</span><br>      m_list_.<span class="hljs-built_in">erase</span>(iter);<br>      m_list_.<span class="hljs-built_in">emplace_front</span>(hit_id);<br>      m_speed_map_[hit_id] = m_list_.<span class="hljs-built_in">begin</span>();<br>    &#125;<br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">page_id_t</span> <span class="hljs-title">evict</span><span class="hljs-params">()</span> </span>&#123;<br>    m_mutex_.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-type">page_id_t</span> vicitm_page_id = m_list_.<span class="hljs-built_in">back</span>();<br>    m_list_.<span class="hljs-built_in">pop_back</span>();<br>    m_speed_map_.<span class="hljs-built_in">erase</span>(vicitm_page_id);<br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> vicitm_page_id;<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-type">page_id_t</span>&gt; <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 清空LRU列表所有元素</span><br>    m_mutex_.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">page_id_t</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m_list_.begin(), m_list_.end())</span></span>;<br>    m_list_.<span class="hljs-built_in">clear</span>();<br>    m_speed_map_.<span class="hljs-built_in">clear</span>();<br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_list_.<span class="hljs-built_in">size</span>(); &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::mutex m_mutex_;<br>  std::list&lt;<span class="hljs-type">page_id_t</span>&gt; m_list_;                                                <span class="hljs-comment">// LRU列表</span><br>  std::unordered_map&lt;<span class="hljs-type">page_id_t</span>, std::list&lt;<span class="hljs-type">page_id_t</span>&gt;::iterator&gt; m_speed_map_;  <span class="hljs-comment">// 加速LRU列表访问</span><br>&#125;;<br><br>&#125;  <span class="hljs-comment">// namespace kv</span><br><br><span class="hljs-comment">// type.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type.h&quot;</span></span><br><span class="hljs-keyword">namespace</span> kv &#123;<br><span class="hljs-type">hash_map_t</span>::<span class="hljs-built_in">hash_map_t</span>() &#123;<br>  <span class="hljs-built_in">memset</span>(m_bucket_, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(m_bucket_));<br>  m_slot_head_ = &amp;m_hash_slot_array_[<span class="hljs-number">0</span>];<br>  m_slot_head_-&gt;next = <span class="hljs-literal">nullptr</span>;<br>  m_slot_cnt_ = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* Find the corresponding key. */</span><br><span class="hljs-function">hash_map_slot *<span class="hljs-title">hash_map_t::find</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>  hash_map_slot *cur = m_bucket_[index];<br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(cur-&gt;key, key.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    cur = cur-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">/* Insert into the head of the list. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hash_map_t::insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> <span class="hljs-type">data_info_t</span> &amp;info, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>  hash_map_slot *new_slot;<br>  <span class="hljs-comment">// 优先使用被删除数据的slot</span><br>  <span class="hljs-keyword">if</span> (m_slot_head_-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>    new_slot = &amp;m_hash_slot_array_[m_slot_cnt_++];<br>    <span class="hljs-built_in">assert</span>(m_slot_cnt_ &lt; kSlotSize);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    new_slot = m_slot_head_-&gt;next;<br>    m_slot_head_-&gt;next = new_slot-&gt;next;<br>  &#125;<br>  new_slot-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-built_in">memcpy</span>(new_slot-&gt;key, key.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>);<br>  new_slot-&gt;info = info;<br>  <span class="hljs-keyword">if</span> (!m_bucket_[index]) &#123;<br>    m_bucket_[index] = new_slot;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">/* Insert into the head. */</span><br>    hash_map_slot *tmp = m_bucket_[index];<br>    m_bucket_[index] = new_slot;<br>    new_slot-&gt;next = tmp;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 只在rebuild时调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hash_map_t::update</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> <span class="hljs-type">data_info_t</span> &amp;info)</span> </span>&#123;<br>  <span class="hljs-type">int</span> index = std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(key) &amp; (kBucketNum - <span class="hljs-number">1</span>);<br>  hash_map_slot *cur = m_bucket_[index];<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(cur-&gt;key, key.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>) == <span class="hljs-number">0</span>) &#123;<br>      cur-&gt;info = info;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cur = cur-&gt;next;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">data_info_t</span> <span class="hljs-title">hash_map_t::remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>  hash_map_slot *cur = m_bucket_[index];<br>  hash_map_slot *parent = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> kNullInfo;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(cur-&gt;key, key.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 在bucket中删除该slot</span><br>      <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">nullptr</span>) &#123;<br>        m_bucket_[index] = cur-&gt;next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        parent-&gt;next = cur-&gt;next;<br>      &#125;<br>      <span class="hljs-comment">// 加入后备链表</span><br>      cur-&gt;next = m_slot_head_-&gt;next;<br>      m_slot_head_-&gt;next = cur;<br>      <span class="hljs-keyword">return</span> cur-&gt;info;<br>    &#125;<br>    parent = cur;<br>    cur = cur-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> kNullInfo;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">u16存储</span><br><span class="hljs-comment">记录数</span><br><span class="hljs-comment">页大小</span><br><span class="hljs-comment">各记录大小</span><br><span class="hljs-comment">char存储</span><br><span class="hljs-comment">各个记录（kv）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">std::string <span class="hljs-title">Page::to_string</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string data;<br>  data.<span class="hljs-built_in">resize</span>(kAllocSize);<br>  <span class="hljs-type">uint16_t</span> data_start = (m_cur_index_ + <span class="hljs-number">5</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint16_t</span>);         <span class="hljs-comment">// 从该偏移开始存储实际的数据</span><br>  <span class="hljs-type">char</span> *char_pointer = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(data.<span class="hljs-built_in">c_str</span>());               <span class="hljs-comment">// 移除常量性</span><br>  <span class="hljs-type">uint16_t</span> *u16_pointer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint16_t</span> *&gt;(char_pointer);  <span class="hljs-comment">// 解释为u32指针</span><br><br>  u16_pointer[<span class="hljs-number">0</span>] = m_cur_index_;<br>  u16_pointer[<span class="hljs-number">1</span>] = m_cur_size_;<br>  <span class="hljs-type">uint16_t</span> offset = data_start;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;  <span class="hljs-comment">// 加入各个记录起始地址</span><br>    u16_pointer[i + <span class="hljs-number">2</span>] = offset;<br>    offset += <span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">size</span>();<br>  &#125;<br>  u16_pointer[m_cur_index_ + <span class="hljs-number">2</span>] = offset;  <span class="hljs-comment">// 实际数据最终偏移</span><br>  <span class="hljs-type">char</span> *p = char_pointer + data_start;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    <span class="hljs-built_in">memcpy</span>(p, m_key_[i].<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">memcpy</span>(p + <span class="hljs-number">16</span>, m_value_[i].<span class="hljs-built_in">c_str</span>(), m_value_[i].<span class="hljs-built_in">size</span>());<br>    p += <span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">size</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Page::to_string</span><span class="hljs-params">(<span class="hljs-type">char</span> *ptr)</span> </span>&#123;<br>  <span class="hljs-type">uint16_t</span> data_start = (m_cur_index_ + <span class="hljs-number">5</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint16_t</span>);  <span class="hljs-comment">// 从该偏移开始存储实际的数据</span><br>  <span class="hljs-type">uint16_t</span> *u16_pointer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint16_t</span> *&gt;(ptr);    <span class="hljs-comment">// 解释为u32指针</span><br><br>  u16_pointer[<span class="hljs-number">0</span>] = m_cur_index_;<br>  u16_pointer[<span class="hljs-number">1</span>] = m_cur_size_;<br>  <span class="hljs-type">uint16_t</span> offset = data_start;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;  <span class="hljs-comment">// 加入各个记录起始地址</span><br>    u16_pointer[i + <span class="hljs-number">2</span>] = offset;<br>    offset += <span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">size</span>();<br>  &#125;<br>  u16_pointer[m_cur_index_ + <span class="hljs-number">2</span>] = offset;  <span class="hljs-comment">// 实际数据最终偏移</span><br>  <span class="hljs-type">char</span> *p = ptr + data_start;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    <span class="hljs-built_in">memcpy</span>(p, m_key_[i].<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">memcpy</span>(p + <span class="hljs-number">16</span>, m_value_[i].<span class="hljs-built_in">c_str</span>(), m_value_[i].<span class="hljs-built_in">size</span>());<br>    p += <span class="hljs-number">16</span> + m_value_[i].<span class="hljs-built_in">size</span>();<br>  &#125;<br>&#125;<br>Page::<span class="hljs-built_in">Page</span>(std::string &amp;data) &#123;<br>  <span class="hljs-type">char</span> *char_pointer = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(data.<span class="hljs-built_in">c_str</span>());               <span class="hljs-comment">// 移除常量性</span><br>  <span class="hljs-type">uint16_t</span> *u16_pointer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint16_t</span> *&gt;(char_pointer);  <span class="hljs-comment">// 解释为u32指针</span><br>  m_cur_index_ = u16_pointer[<span class="hljs-number">0</span>];<br>  m_cur_size_ = u16_pointer[<span class="hljs-number">1</span>];<br>  <span class="hljs-type">uint16_t</span> offset, length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>; i &lt; m_cur_index_; i++) &#123;<br>    offset = u16_pointer[i + <span class="hljs-number">2</span>];<br>    length = u16_pointer[i + <span class="hljs-number">3</span>] - u16_pointer[i + <span class="hljs-number">2</span>];<br>    m_key_[i] = data.<span class="hljs-built_in">substr</span>(offset, <span class="hljs-number">16</span>);<br>    m_value_[i] = data.<span class="hljs-built_in">substr</span>(offset + <span class="hljs-number">16</span>, length - <span class="hljs-number">16</span>);<br>  &#125;<br>  m_is_dirty_ = <span class="hljs-literal">false</span>;<br>&#125;<br><br>&#125;  <span class="hljs-comment">// namespace kv</span><br></code></pre></td></tr></table></figure><p><strong>local_engine_entity</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// local_engine_entity.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;type.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rdma_conn_manager.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rdma_mem_pool.h&quot;</span></span><br><span class="hljs-keyword">namespace</span> kv &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalEngine</span>;  <span class="hljs-comment">// 前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalEngineEntity</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LocalEngineEntity</span>(LocalEngine *engine, ConnectionManager *rdma_conn);<br>  ~<span class="hljs-built_in">LocalEngineEntity</span>();<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> std::string &amp;value, <span class="hljs-type">bool</span> use_aes = <span class="hljs-literal">false</span>)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, std::string &amp;value)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deleteK</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild_index</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-type">uint64_t</span>&gt; <span class="hljs-title">print_memory</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 输出内存占用信息</span><br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_thread</span><span class="hljs-params">()</span></span>;                  <span class="hljs-comment">// 启动后台线程</span><br>  <span class="hljs-function"><span class="hljs-type">remote_info_t</span> <span class="hljs-title">request_signle_info</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 请求单个远端地址</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_remote_memory</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// 提前注册远端内存</span><br><br>  <span class="hljs-type">hash_map_t</span> m_page_map_;                                    <span class="hljs-comment">// 数据与元数据映射</span><br>  std::shared_ptr&lt;Page&gt; m_data_map_[kBitmapSize];            <span class="hljs-comment">// 页号与页映射（数据存于本地）</span><br>  <span class="hljs-type">uint32_t</span> m_cache_size_;                                    <span class="hljs-comment">// 本地缓存大小</span><br>  LRUList m_lru_list_;                                       <span class="hljs-comment">// LRU列表</span><br>  std::unordered_map&lt;<span class="hljs-type">page_id_t</span>, <span class="hljs-type">remote_info_t</span>&gt; m_addr_map_;  <span class="hljs-comment">// 页号与远端信息映射（数据存于远端）</span><br>  <span class="hljs-type">uint16_t</span> m_max_index_[kBitmapSize];                        <span class="hljs-comment">// 各个远端页最大索引</span><br>  std::queue&lt;<span class="hljs-type">remote_info_t</span>&gt; m_addr_list_;                    <span class="hljs-comment">// 未使用的远端内存</span><br>  std::mutex m_mutex_;                                       <span class="hljs-comment">// 保护以上成员</span><br><br>  <span class="hljs-comment">// 注意最大页号不要大于kBitmapSize!</span><br>  std::bitset&lt;kMaxIndex&gt; m_bitmap_[kBitmapSize];  <span class="hljs-comment">// 删除为1，正常为0</span><br>  std::mutex m_same_reader_mutex_[kBitmapSize];   <span class="hljs-comment">// 提供同一页远程读互斥访问</span><br><br>  <span class="hljs-type">page_id_t</span> m_cur_page_id_;           <span class="hljs-comment">// 当前使用页号，不存在于LRU列表</span><br>  std::shared_ptr&lt;Page&gt; m_cur_page_;  <span class="hljs-comment">// 当前使用页</span><br><br>  <span class="hljs-type">page_id_t</span> m_vicitm_id_;                <span class="hljs-comment">// 淘汰页号</span><br>  std::shared_ptr&lt;Page&gt; m_vicitm_page_;  <span class="hljs-comment">// 淘汰页号</span><br>  <span class="hljs-type">page_id_t</span> m_last_update_id_;           <span class="hljs-comment">// 上次lru更新的页号</span><br><br>  <span class="hljs-type">bool</span> m_alive_;                  <span class="hljs-comment">// 控制后台进程生命周期</span><br>  std::condition_variable m_cv_;  <span class="hljs-comment">// 用于唤醒后台进程</span><br>  std::thread *m_backup_thread_;  <span class="hljs-comment">// 后台进程</span><br>  std::mutex m_useless_mutex_;    <span class="hljs-comment">// 只是方便调用API,没啥实际意义</span><br><br>  LocalEngine *m_engine_;<br>  ConnectionManager *m_rdma_conn_;<br>  RDMAMemPool *m_rdma_mem_pool_;<br><br>  <span class="hljs-comment">// 统计数据</span><br>  <span class="hljs-type">uint64_t</span> m_alloc_memory_&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 申请远端内存大小</span><br><br>  <span class="hljs-type">bool</span> m_rebuild_allow_&#123;<span class="hljs-literal">true</span>&#125;;<br>  <span class="hljs-type">bool</span> m_delete_envent_&#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-type">bool</span> m_rw_envent_after_delete_&#123;<span class="hljs-literal">false</span>&#125;;<br>&#125;;<br>&#125;  <span class="hljs-comment">// namespace kv</span><br><br><span class="hljs-comment">// local_engine_entity.cc</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;local_engine_entity.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kv_engine.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> kv &#123;<br>LocalEngineEntity::<span class="hljs-built_in">LocalEngineEntity</span>(LocalEngine *engine, ConnectionManager *rdma_conn) : <span class="hljs-built_in">m_engine_</span>(engine), <span class="hljs-built_in">m_rdma_conn_</span>(rdma_conn) &#123;<br>  m_rdma_mem_pool_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RDMAMemPool</span>(m_rdma_conn_);<br>  <span class="hljs-keyword">if</span> (m_rdma_mem_pool_ == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc rdma_mem_pool failed&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">auto</span> page = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;();  <span class="hljs-comment">// 申请第一页</span><br>  m_cur_page_id_ = <span class="hljs-number">1</span>;<br>  m_cur_page_ = page;<br><br>  m_vicitm_id_ = kNullPage;<br>  m_vicitm_page_ = <span class="hljs-literal">nullptr</span>;<br>  m_last_update_id_ = kNullPage;<br><br>  m_data_map_[m_cur_page_id_] = page;<br>  m_cache_size_ = <span class="hljs-number">1</span>;<br><br>  m_alive_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 提前申请远端内存</span><br>  <span class="hljs-keyword">auto</span> requester = std::<span class="hljs-built_in">thread</span>([&amp;]() &#123; <span class="hljs-built_in">register_remote_memory</span>(); &#125;);<br>  requester.<span class="hljs-built_in">detach</span>();<br>  <span class="hljs-comment">// 启动后台线程</span><br>  <span class="hljs-built_in">start_thread</span>();<br>&#125;<br><span class="hljs-comment">// 申请kEralyRegisterNumber个kAllocSize大小的远端内存</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LocalEngineEntity::register_remote_memory</span><span class="hljs-params">()</span> </span>&#123;<br>  std::queue&lt;<span class="hljs-type">remote_info_t</span>&gt; list;<br>  <span class="hljs-type">remote_info_t</span> remote_info;<br>  remote_info.size = kAllocSize;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; kEralyRegisterNumber; i++) &#123;<br>    m_rdma_mem_pool_-&gt;<span class="hljs-built_in">get_mem</span>(remote_info.size, remote_info.remote_addr, remote_info.rkey);<br>    list.<span class="hljs-built_in">emplace</span>(remote_info);<br>  &#125;<br>  m_alloc_memory_ += kAllocSize * kEralyRegisterNumber;<br><br>  m_mutex_.<span class="hljs-built_in">lock</span>();<br>  <span class="hljs-keyword">while</span> (!m_addr_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    list.<span class="hljs-built_in">emplace</span>(m_addr_list_.<span class="hljs-built_in">front</span>());<br>    m_addr_list_.<span class="hljs-built_in">pop</span>();<br>  &#125;<br>  m_addr_list_ = std::<span class="hljs-built_in">move</span>(list);<br>  m_mutex_.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">remote_info_t</span> <span class="hljs-title">LocalEngineEntity::request_signle_info</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">remote_info_t</span> remote_info;<br>  <span class="hljs-comment">// 先从后备地址列表选择远端地址</span><br>  <span class="hljs-keyword">if</span> (!m_addr_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    remote_info = m_addr_list_.<span class="hljs-built_in">front</span>();<br>    m_addr_list_.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> remote_info;<br>  &#125;<br>  <span class="hljs-comment">// 申请远端内存</span><br>  remote_info.size = kAllocSize;<br>  m_rdma_mem_pool_-&gt;<span class="hljs-built_in">get_mem</span>(remote_info.size, remote_info.remote_addr, remote_info.rkey);<br>  m_alloc_memory_ += remote_info.size;<br>  <span class="hljs-keyword">return</span> remote_info;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LocalEngineEntity::start_thread</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> backup_func = [&amp;]() &#123;<br>    <span class="hljs-type">uint64_t</span> rebuild_threshold = kRebuildThreshold;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">useless_lock</span><span class="hljs-params">(m_useless_mutex_)</span></span>;  <span class="hljs-comment">// 持有无用锁</span><br>    <span class="hljs-keyword">while</span> (m_alive_) &#123;<br>      <span class="hljs-keyword">while</span> (m_cache_size_ &lt; kPageThreshold &amp;&amp; !(m_rebuild_allow_ &amp;&amp; m_delete_envent_ &amp;&amp; m_rw_envent_after_delete_)) &#123;  <span class="hljs-comment">// 若当前大小小于阈值并且不需要重构则休眠</span><br>        m_cv_.<span class="hljs-built_in">wait</span>(useless_lock);<br>        <span class="hljs-keyword">if</span> (!m_alive_) &#123;  <span class="hljs-comment">// 进程退出，该后台线程也应该退出</span><br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (m_rebuild_allow_ &amp;&amp; m_delete_envent_ &amp;&amp; m_rw_envent_after_delete_) &#123;<br>        <span class="hljs-built_in">rebuild_index</span>();<br>        m_rebuild_allow_ = <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (m_cache_size_ &gt; kPageThreshold) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; kEvictNumber; i++) &#123;<br>          m_mutex_.<span class="hljs-built_in">lock</span>();<br>          <span class="hljs-type">page_id_t</span> victim_id = m_lru_list_.<span class="hljs-built_in">evict</span>();<br>          std::shared_ptr&lt;Page&gt; victim_page = m_data_map_[victim_id];<br>          <span class="hljs-type">remote_info_t</span> info = <span class="hljs-built_in">request_signle_info</span>();<br><br>          <span class="hljs-comment">// 设置淘汰页信息</span><br>          m_data_map_[victim_id] = <span class="hljs-literal">nullptr</span>;<br>          m_cache_size_--;<br>          m_addr_map_[victim_id] = info;<br>          m_max_index_[victim_id] = victim_page-&gt;<span class="hljs-built_in">record_number</span>();<br>          m_mutex_.<span class="hljs-built_in">unlock</span>();<br><br>          std::string &amp;&amp;vicitm_page_data = victim_page-&gt;<span class="hljs-built_in">to_string</span>();  <span class="hljs-comment">// 记录淘汰页数据，开始写入远端内存</span><br>          <span class="hljs-comment">// 将本地数据写入远端内存</span><br>          m_rdma_conn_-&gt;<span class="hljs-built_in">remote_write</span>((<span class="hljs-type">void</span> *)vicitm_page_data.<span class="hljs-built_in">c_str</span>(), kAllocSize, info.remote_addr, info.rkey);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;;<br>  m_backup_thread_ = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">thread</span>(backup_func);<br>&#125;<br>LocalEngineEntity::~<span class="hljs-built_in">LocalEngineEntity</span>() &#123;<br>  m_alive_ = <span class="hljs-literal">false</span>;<br>  m_cv_.<span class="hljs-built_in">notify_one</span>();<br>  m_backup_thread_-&gt;<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">delete</span> m_backup_thread_;<br>  <span class="hljs-keyword">delete</span> m_rdma_mem_pool_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngineEntity::write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">const</span> std::string &amp;value, <span class="hljs-type">bool</span> use_aes)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (m_rebuild_allow_ &amp;&amp; m_delete_envent_) &#123;<br>    m_rw_envent_after_delete_ = <span class="hljs-literal">true</span>;<br>    m_cv_.<span class="hljs-built_in">notify_one</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 区分加密与非加密</span><br>  std::string encrypt_value;<br>  <span class="hljs-keyword">if</span> (use_aes) &#123;<br>    m_engine_-&gt;<span class="hljs-built_in">encrypted</span>(value, encrypt_value);<br>  &#125;<br>  <span class="hljs-type">int</span> hash_index = std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(key) &amp; (kBucketNum - <span class="hljs-number">1</span>);<br><br>  m_mutex_.<span class="hljs-built_in">lock</span>();<br>  <span class="hljs-keyword">auto</span> slot = m_page_map_.<span class="hljs-built_in">find</span>(key, hash_index);<br><br>  <span class="hljs-comment">// 第一次写入或该页正在写入远端或该页正在远端</span><br>  <span class="hljs-keyword">if</span> (slot == <span class="hljs-literal">nullptr</span> || m_data_map_[slot-&gt;info.page_id] == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (m_cur_page_-&gt;<span class="hljs-built_in">is_full</span>()) &#123;          <span class="hljs-comment">// 该页已满不可用</span><br>      m_lru_list_.<span class="hljs-built_in">insert</span>(m_cur_page_id_);  <span class="hljs-comment">// 直到页满才插入LRU列表</span><br>      m_cur_page_id_++;<br>      m_data_map_[m_cur_page_id_] = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;();<br>      m_cur_page_ = m_data_map_[m_cur_page_id_];<br>      m_cache_size_++;<br>      <span class="hljs-comment">// 尝试唤醒后台进程</span><br>      <span class="hljs-keyword">if</span> (m_cache_size_ &gt; kPageThreshold) &#123;<br>        m_cv_.<span class="hljs-built_in">notify_one</span>();<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">index_t</span> index;<br>    <span class="hljs-keyword">if</span> (use_aes) &#123;<br>      index = m_cur_page_-&gt;<span class="hljs-built_in">insert</span>(key, std::<span class="hljs-built_in">move</span>(encrypt_value));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      index = m_cur_page_-&gt;<span class="hljs-built_in">insert</span>(key, value);<br>    &#125;<br><br>    <span class="hljs-type">data_info_t</span> info = &#123;m_cur_page_id_, index&#125;;<br>    <span class="hljs-keyword">if</span> (slot == <span class="hljs-literal">nullptr</span>) &#123;                        <span class="hljs-comment">// 第一次写入，插入元数据</span><br>      m_page_map_.<span class="hljs-built_in">insert</span>(key, info, hash_index);  <span class="hljs-comment">// 插入key与元数据映射</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      m_bitmap_[slot-&gt;info.page_id].<span class="hljs-built_in">set</span>(slot-&gt;info.index, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 将之前数据标记为删除</span><br>      slot-&gt;info = info;                                          <span class="hljs-comment">// 更新元数据信息</span><br>    &#125;<br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 该页在本地且未被淘汰，更新页数据</span><br>    <span class="hljs-type">data_info_t</span> info = slot-&gt;info;<br>    <span class="hljs-keyword">if</span> (use_aes) &#123;<br>      m_data_map_[info.page_id]-&gt;<span class="hljs-built_in">update</span>(info.index, std::<span class="hljs-built_in">move</span>(encrypt_value));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      m_data_map_[info.page_id]-&gt;<span class="hljs-built_in">update</span>(info.index, value);<br>    &#125;<br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-comment">// 更新LRU列表</span><br>    <span class="hljs-keyword">if</span> (info.page_id != m_last_update_id_ &amp;&amp; info.page_id != m_cur_page_id_) &#123;<br>      m_lru_list_.<span class="hljs-built_in">update</span>(info.page_id);<br>      m_last_update_id_ = info.page_id;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngineEntity::read</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, std::string &amp;value)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (m_rebuild_allow_ &amp;&amp; m_delete_envent_) &#123;<br>    m_rw_envent_after_delete_ = <span class="hljs-literal">true</span>;<br>    m_cv_.<span class="hljs-built_in">notify_one</span>();<br>  &#125;<br>  <span class="hljs-type">int</span> hash_index = std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(key) &amp; (kBucketNum - <span class="hljs-number">1</span>);<br>  <span class="hljs-type">bool</span> need_update_lru = <span class="hljs-literal">true</span>;<br>  m_mutex_.<span class="hljs-built_in">lock</span>();<br><br>  <span class="hljs-keyword">auto</span> slot = m_page_map_.<span class="hljs-built_in">find</span>(key, hash_index);<br>  <span class="hljs-keyword">if</span> (slot == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 元数据不存在</span><br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-type">data_info_t</span> info = slot-&gt;info;<br>  <span class="hljs-keyword">if</span> (info.page_id == m_vicitm_id_) &#123;<br>    value = m_vicitm_page_-&gt;<span class="hljs-built_in">read_value</span>(info.index);<br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (m_data_map_[info.page_id] == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 数据在远端内存</span><br>    m_mutex_.<span class="hljs-built_in">unlock</span>();<br>    m_same_reader_mutex_[info.page_id].<span class="hljs-built_in">lock</span>();   <span class="hljs-comment">// 读者互斥</span><br>    <span class="hljs-keyword">if</span> (m_data_map_[info.page_id] == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 双重检查</span><br>      <span class="hljs-keyword">auto</span> remote_info = m_addr_map_[info.page_id];<br>      std::string &amp;&amp;page_data = std::<span class="hljs-built_in">string</span>(remote_info.size, <span class="hljs-string">&#x27;0&#x27;</span>);<br>      m_rdma_conn_-&gt;<span class="hljs-built_in">remote_read</span>((<span class="hljs-type">void</span> *)page_data.<span class="hljs-built_in">c_str</span>(), remote_info.size, remote_info.remote_addr, remote_info.rkey);<br>      <span class="hljs-keyword">auto</span> new_page = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;(page_data);  <span class="hljs-comment">// 构建缓存页</span><br>      m_mutex_.<span class="hljs-built_in">lock</span>();<br>      m_data_map_[info.page_id] = new_page;<br>      m_cache_size_++;<br>      m_lru_list_.<span class="hljs-built_in">insert</span>(info.page_id);<br>      need_update_lru = <span class="hljs-literal">false</span>;<br>      m_addr_map_.<span class="hljs-built_in">erase</span>(info.page_id);    <span class="hljs-comment">// 在远端地址映射中删除该项</span><br>      m_addr_list_.<span class="hljs-built_in">emplace</span>(remote_info);  <span class="hljs-comment">// 将该页加入地址列表</span><br>      m_mutex_.<span class="hljs-built_in">unlock</span>();<br>      <span class="hljs-comment">// 尝试唤醒后台进程</span><br>      <span class="hljs-keyword">if</span> (m_cache_size_ &gt; kPageThreshold) &#123;<br>        m_cv_.<span class="hljs-built_in">notify_one</span>();<br>      &#125;<br>    &#125;<br>    m_same_reader_mutex_[info.page_id].<span class="hljs-built_in">unlock</span>();<br>    m_mutex_.<span class="hljs-built_in">lock</span>();<br>  &#125;<br>  value = m_data_map_[info.page_id]-&gt;<span class="hljs-built_in">read_value</span>(info.index);<br>  m_mutex_.<span class="hljs-built_in">unlock</span>();<br>  <span class="hljs-keyword">if</span> (info.page_id != m_last_update_id_ &amp;&amp; info.page_id != m_cur_page_id_ &amp;&amp; need_update_lru) &#123;<br>    m_lru_list_.<span class="hljs-built_in">update</span>(info.page_id);<br>    m_last_update_id_ = info.page_id;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocalEngineEntity::deleteK</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span> </span>&#123;<br>  m_delete_envent_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-type">int</span> hash_index = std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(key) &amp; (kBucketNum - <span class="hljs-number">1</span>);<br>  m_mutex_.<span class="hljs-built_in">lock</span>();<br>  <span class="hljs-type">data_info_t</span> info = m_page_map_.<span class="hljs-built_in">remove</span>(key, hash_index);  <span class="hljs-comment">// 删除对应key的元数据</span><br>  m_mutex_.<span class="hljs-built_in">unlock</span>();<br>  m_bitmap_[info.page_id].<span class="hljs-built_in">set</span>(info.index, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 将对应记录标记为删除</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LocalEngineEntity::rebuild_index</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_mutex_)</span></span>;<br>  std::string key;<br>  std::string value;<br>  <span class="hljs-type">data_info_t</span> data_info;<br>  std::shared_ptr&lt;Page&gt; page;<br>  std::unordered_map&lt;<span class="hljs-type">page_id_t</span>, <span class="hljs-type">remote_info_t</span>&gt; tmp_addr_map;  <span class="hljs-comment">// 暂时存储页号与远端地址映射</span><br>  <span class="hljs-type">uint32_t</span> new_cache_size = <span class="hljs-number">1</span>;<br>  std::vector&lt;<span class="hljs-type">page_id_t</span>&gt; local_id = m_lru_list_.<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">auto</span> new_page = m_cur_page_;<br>  <span class="hljs-type">page_id_t</span> new_page_id = m_cur_page_id_;<br>  <span class="hljs-comment">// 处理本地缓存页</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;page_id : local_id) &#123;<br>    <span class="hljs-keyword">auto</span> &amp;bitmap = m_bitmap_[page_id];<br>    <span class="hljs-keyword">if</span> (bitmap.<span class="hljs-built_in">none</span>()) &#123;  <span class="hljs-comment">// 不存在删除的记录，不进行操作</span><br>      m_lru_list_.<span class="hljs-built_in">insert</span>(page_id);<br>      new_cache_size++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!bitmap.<span class="hljs-built_in">all</span>()) &#123;  <span class="hljs-comment">//存在有效记录</span><br>      <span class="hljs-keyword">auto</span> page = m_data_map_[page_id];<br>      <span class="hljs-type">int</span> record_num = page-&gt;<span class="hljs-built_in">record_number</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; record_num; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!bitmap.<span class="hljs-built_in">test</span>(i)) &#123;        <span class="hljs-comment">// 该记录未被删除</span><br>          <span class="hljs-keyword">if</span> (new_page-&gt;<span class="hljs-built_in">is_full</span>()) &#123;  <span class="hljs-comment">// 页满，写入本地</span><br>            m_data_map_[new_page_id] = new_page;<br>            new_cache_size++;<br>            m_lru_list_.<span class="hljs-built_in">insert</span>(new_page_id);<br>            new_page = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;();<br>            new_page_id++;<br>          &#125;<br>          <span class="hljs-comment">// 读出数据插入新页并更新元数据映射</span><br>          key = page-&gt;<span class="hljs-built_in">read_key</span>(i);<br>          data_info.index = new_page-&gt;<span class="hljs-built_in">insert</span>(key, page-&gt;<span class="hljs-built_in">read_value</span>(i));<br>          data_info.page_id = new_page_id;<br>          m_page_map_.<span class="hljs-built_in">update</span>(key, data_info);<br>        &#125;<br>      &#125;<br>      m_data_map_[page_id] = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 删除原先页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      m_data_map_[page_id] = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 删除原先页</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-type">page_id_t</span> page_id;<br>  <span class="hljs-type">remote_info_t</span> info;<br>  <span class="hljs-type">char</span> head_data[kMaxIndex * <span class="hljs-number">10</span>];<br>  <span class="hljs-type">char</span> kv_data[<span class="hljs-number">2</span> * kMaxValueSize];<br>  <span class="hljs-type">uint16_t</span> *u16_pointer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint16_t</span> *&gt;(&amp;head_data);<br>  <span class="hljs-type">uint16_t</span> head_length;<br>  <span class="hljs-type">uint16_t</span> offset, length;<br><br>  <span class="hljs-comment">// 处理远端内存页</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;kv : m_addr_map_) &#123;<br>    page_id = kv.first;<br>    info = kv.second;<br>    <span class="hljs-keyword">auto</span> &amp;bitmap = m_bitmap_[page_id];<br>    <span class="hljs-keyword">if</span> (bitmap.<span class="hljs-built_in">none</span>()) &#123;  <span class="hljs-comment">// 不存在删除的记录，不进行操作</span><br>      tmp_addr_map.<span class="hljs-built_in">insert</span>(&#123;page_id, info&#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bitmap.<span class="hljs-built_in">all</span>()) &#123;  <span class="hljs-comment">// 不存在有效记录，将后端地址加入地址列表</span><br>      m_addr_list_.<span class="hljs-built_in">emplace</span>(info);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">bool</span> avai_info = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 是否将该远端地址加入地址列表</span><br>      head_length = (m_max_index_[page_id] + <span class="hljs-number">5</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint16_t</span>);<br>      <span class="hljs-comment">// 读取页头部数据</span><br>      m_rdma_conn_-&gt;<span class="hljs-built_in">remote_read</span>(head_data, head_length, info.remote_addr, info.rkey);<br>      <span class="hljs-type">int</span> record_num = m_max_index_[page_id];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; record_num; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!bitmap.<span class="hljs-built_in">test</span>(i)) &#123;<br>          <span class="hljs-keyword">if</span> (new_page-&gt;<span class="hljs-built_in">is_full</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (new_cache_size &gt; kPageThreshold) &#123;  <span class="hljs-comment">// 本地页满，写入远程</span><br>              std::string &amp;&amp;page_data = new_page-&gt;<span class="hljs-built_in">to_string</span>();<br>              <span class="hljs-type">uint32_t</span> len = page_data.<span class="hljs-built_in">length</span>();<br>              m_rdma_conn_-&gt;<span class="hljs-built_in">remote_write</span>((<span class="hljs-type">void</span> *)page_data.<span class="hljs-built_in">c_str</span>(), len, info.remote_addr, info.rkey);<br>              tmp_addr_map.<span class="hljs-built_in">insert</span>(&#123;new_page_id, info&#125;);  <span class="hljs-comment">// 暂时记录页号与远程地址映射</span><br>              avai_info = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 写入本地缓存</span><br>              m_data_map_[new_page_id] = new_page;<br>              new_cache_size++;<br>              m_lru_list_.<span class="hljs-built_in">insert</span>(new_page_id);<br>            &#125;<br>            new_page = std::<span class="hljs-built_in">make_shared</span>&lt;Page&gt;();<br>            new_page_id++;<br>          &#125;<br>          <span class="hljs-comment">// 读出数据插入新页并更新元数据映射</span><br>          offset = u16_pointer[i + <span class="hljs-number">2</span>];<br>          length = u16_pointer[i + <span class="hljs-number">3</span>] - u16_pointer[i + <span class="hljs-number">2</span>];<br>          m_rdma_conn_-&gt;<span class="hljs-built_in">remote_read</span>(kv_data, length, info.remote_addr + offset, info.rkey);<br>          key = std::<span class="hljs-built_in">string</span>(kv_data, kv_data + <span class="hljs-number">16</span>);<br>          value = std::<span class="hljs-built_in">string</span>(kv_data + <span class="hljs-number">16</span>, kv_data + length);<br>          data_info.index = new_page-&gt;<span class="hljs-built_in">insert</span>(key, std::<span class="hljs-built_in">move</span>(value));<br>          data_info.page_id = new_page_id;<br>          m_page_map_.<span class="hljs-built_in">update</span>(key, data_info);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (avai_info) &#123;<br>        m_addr_list_.<span class="hljs-built_in">emplace</span>(info);<br>      &#125;<br>    &#125;<br>  &#125;<br>  m_addr_map_ = std::<span class="hljs-built_in">move</span>(tmp_addr_map);<br>  m_cur_page_id_ = new_page_id;<br>  m_cur_page_ = new_page;<br>  m_vicitm_id_ = kNullPage;<br>  m_vicitm_page_ = <span class="hljs-literal">nullptr</span>;<br>  m_cache_size_ = new_cache_size;<br>  m_last_update_id_ = kNullPage;<br>  m_data_map_[new_page_id] = new_page;<br>&#125;<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">uint64_t</span>&gt; <span class="hljs-title">LocalEngineEntity::print_memory</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 输出一系列统计数据</span><br>  <span class="hljs-type">uint64_t</span> key_metadata = kSlotSize * <span class="hljs-number">32</span> + kBucketNum * <span class="hljs-number">8</span>;<br>  <span class="hljs-type">uint64_t</span> page_id_size = m_cur_page_id_;<br>  <span class="hljs-type">uint64_t</span> page_metadata = page_id_size * <span class="hljs-number">48</span> + kBitmapSize * <span class="hljs-number">1.2</span> * kMaxIndex;<br>  <span class="hljs-type">uint64_t</span> page_size = m_cache_size_ * (kPageSize);<br>  <span class="hljs-keyword">return</span> &#123;key_metadata, page_id_size, page_metadata, page_size, m_alloc_memory_&#125;;<br>&#125;<br>&#125;  <span class="hljs-comment">// namespace kv</span><br><br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/" class="category-chain-item">踩坑日记</a> </span><span class="category-chain"><a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="category-chain-item">学习记录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%A4%A9%E6%B1%A0-c-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="print-no-link">#天池 c++ 数据库 存储引擎</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" title="计算机读书笔记"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">计算机读书笔记</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/mit6.824%202022.html" title="mit6.824 2022"><span class="hidden-mobile">mit6.824 2022</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz","appKey":"0e2MMh7ddBCGGytOe9UEy5NP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://uu0wegco.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>