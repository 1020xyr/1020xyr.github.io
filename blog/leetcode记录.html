

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/nano-1.jpg">
  <link rel="icon" href="/img/nano-1.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="最佳损友1020">
  <meta name="keywords" content="">
  
    <meta name="description" content="推荐博客五大常用算法：分治、动态规划、贪心、回溯和分支界定&#x3D;&#x3D;刷题时注意边界条件&#x2F;特殊条件的处理&#x3D;&#x3D; 代码复制粘贴太多了，编辑起来很卡，再开一个博客：leetcode记录2 合并 K 个升序链表给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 思路：简单的合并链表，刚开始的思路是每次循环找到最">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode记录">
<meta property="og:url" content="https://www.jiasun.top/blog/leetcode%E8%AE%B0%E5%BD%95.html">
<meta property="og:site_name" content="最佳损友1020’s Blog">
<meta property="og:description" content="推荐博客五大常用算法：分治、动态规划、贪心、回溯和分支界定&#x3D;&#x3D;刷题时注意边界条件&#x2F;特殊条件的处理&#x3D;&#x3D; 代码复制粘贴太多了，编辑起来很卡，再开一个博客：leetcode记录2 合并 K 个升序链表给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 思路：简单的合并链表，刚开始的思路是每次循环找到最">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1bd796a8b6b748fdb3b680efc72ae032.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2c03567a66884743805d8767b721c4d1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/85cd413dd651446d8ad9432f8910e7a7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a7cc5a3366c14c09929aa45272d91a44.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/46ee6725e6ef45be84006e0837692898.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d55a3bf62f2b46f99d0d4517bb84ee75.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3ade98606c98485b9f950993c738c647.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3f1349d61ba74195bc8bb1821b945e6b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/79644d4540714562b8ddce9ec2e80a63.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/dfa22e3caf4546838f9058d722317ad0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a1b3f762acd14d25a7c73db44c819d35.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b866bcf09b414b0ab3c09a81d57a5b3b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/00d1f66bc20345138c8de130da13d5bc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e473b5be7a074df7910914aab4e375e5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7895296ba13043dfbc967d30da26657b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/83f8683e97d441708e2db0e52d2f0ccf.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/97efd84354c840c29cdaae264007abd9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f6b2b75e9c134fb2bd617de5fc850b0d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0eec17dff99d490294f4c5bc5d6fe500.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0e8542dcc32747d28ebe54a7dc1e4062.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2f208e0d1f404fb19b47cb43c4efd704.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2c77b77c4a7e43ca8129cf1427e3e4f1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/26eb023fb31a4b2887884f0a27d4fa9e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/80ed7011aa71431698a3a9fcae0f655c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/16aa46d27bc24accabc81e6718834a93.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/359c7bb28c034055a6dacdd1d0be9d07.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ac8d40cd5db54874ab8b0c42c6760f62.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/502967515c3d4312bf60cba8011157fe.png">
<meta property="article:published_time" content="2022-06-16T14:18:05.000Z">
<meta property="article:modified_time" content="2023-10-31T14:45:59.180Z">
<meta property="article:author" content="最佳损友1020">
<meta property="article:tag" content="leetcode 算法 c++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/1bd796a8b6b748fdb3b680efc72ae032.png">
  
  
  
  <title>leetcode记录 - 最佳损友1020’s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/csdn.css">
<link rel="stylesheet" href="/css/top.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.jiasun.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz","app_key":"ljkRZDiTtVmjn5mpaQmpFqgv","server_url":"https://n227fxnj.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>最佳损友1020</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="leetcode记录"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-16 22:18" pubdate>
          2022年6月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          112k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          936 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">leetcode记录</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer" />


<p>推荐博客<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yake827/article/details/52119469">五大常用算法：分治、动态规划、贪心、回溯和分支界定</a><br>&#x3D;&#x3D;刷题时注意边界条件&#x2F;特殊条件的处理&#x3D;&#x3D;</p>
<p>代码复制粘贴太多了，编辑起来很卡，再开一个博客：<a href="https://www.jiasun.top/blog/leetcode%E8%AE%B0%E5%BD%952.html">leetcode记录2</a></p>
<h2 id="合并-K-个升序链表"><a href="#合并-K-个升序链表" class="headerlink" title="合并 K 个升序链表"></a>合并 K 个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>思路：简单的合并链表，刚开始的思路是每次循环找到最小的节点，后面看题解发现可以使用优先队列这种方式辅助找到最小值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br> public:<br>  <span class="hljs-type">bool</span> <span class="hljs-title function_">IterToEnd</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> &#123;  <span class="hljs-comment">// 所有链表均遍历至尾部</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; link_list : lists) &#123;<br>      <span class="hljs-keyword">if</span> (link_list != nullptr) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  ListNode* <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> &#123;<br>    ListNode virt_node;<br>    ListNode* p = &amp;virt_node;<br>    <span class="hljs-keyword">while</span> (!IterToEnd(lists)) &#123;<br>      <span class="hljs-comment">// 找到最小的链表节点与下标</span><br>      <span class="hljs-type">int</span> min_val = <span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">30</span>;<br>      <span class="hljs-type">int</span> min_index = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (lists[i] != nullptr) &#123;<br>          <span class="hljs-keyword">if</span> (min_val &gt; lists[i]-&gt;val) &#123;<br>            min_val = lists[i]-&gt;val;<br>            min_index = i;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 将该节点加入合并链表</span><br>      p-&gt;next = lists[min_index];<br>      p = lists[min_index];<br>      lists[min_index] = lists[min_index]-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> virt_node.next;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>使用优先队列找到最小值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br> public:<br>  ListNode* <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> &#123;<br>    ListNode virt_node;<br>    ListNode* p = &amp;virt_node;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; node_queue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.size(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (lists[i] != nullptr) &#123;<br>        node_queue.emplace(lists[i]-&gt;val, i);  <span class="hljs-comment">// 加入链表节点值与对应下标</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!node_queue.empty()) &#123;<br>      <span class="hljs-keyword">auto</span> [_, min_index] = node_queue.top();<br>      node_queue.pop();<br>      p-&gt;next = lists[min_index];<br>      p = lists[min_index];<br>      lists[min_index] = lists[min_index]-&gt;next;<br>      <span class="hljs-keyword">if</span> (lists[min_index] != nullptr) &#123;  <span class="hljs-comment">// 加入其后的链表节点</span><br>        node_queue.emplace(lists[min_index]-&gt;val, min_index);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> virt_node.next;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>记住约瑟夫环的递推公式即可<br><img src="https://img-blog.csdnimg.cn/1bd796a8b6b748fdb3b680efc72ae032.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-comment">// 递推公式 f(n,m) = (f(n-1,m)+m)%n;</span><br>    <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>      value = (value + m) % i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


<h2 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h2><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>按我之前的写法，我的代码会像这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string a, string b, <span class="hljs-type">int</span> radix)</span> </span>&#123;<br>  <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-built_in">reverse</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-type">int</span> len_a = a.<span class="hljs-built_in">length</span>();<br>  <span class="hljs-type">int</span> len_b = b.<span class="hljs-built_in">length</span>();<br>  a += <span class="hljs-built_in">string</span>((<span class="hljs-number">50</span> - len_a), <span class="hljs-string">&#x27;0&#x27;</span>);<br>  b += <span class="hljs-built_in">string</span>((<span class="hljs-number">50</span> - len_b), <span class="hljs-string">&#x27;0&#x27;</span>);<br>  <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>    <span class="hljs-type">int</span> sum = a[i] + b[i] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-string">&#x27;0&#x27;</span> + flag;<br>    flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sum &gt;= radix) &#123;<br>      sum = sum - radix;<br>      flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    a[i] = sum + <span class="hljs-string">&#x27;0&#x27;</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> len = len_a &gt; len_b ? len_a : len_b;<br>  <span class="hljs-keyword">while</span> (a[len] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>    len++;<br>  &#125;<br>  string ans = a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, len);<br>  <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看了字符串相乘的代码后，我写出来这样的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = num1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> len2 = num2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (len1 &lt; len2) &#123;  <span class="hljs-comment">// 保证len1&gt;=len2</span><br>      <span class="hljs-built_in">swap</span>(num1, num2);<br>      <span class="hljs-built_in">swap</span>(len1, len2);  <span class="hljs-comment">// 记得交换len</span><br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len1 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 多申请一位空间</span><br>    <span class="hljs-comment">// 从右往左计算</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++) &#123;<br>      ans[len1 - i] = num1[len1 - i - <span class="hljs-number">1</span>] + num2[len2 - i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> * <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len2; i &lt; len1; i++) &#123;<br>      ans[len1 - i] = num1[len1 - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len1; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>      ans[i - <span class="hljs-number">1</span>] += ans[i] / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 进位</span><br>      ans[i] = ans[i] % <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> start = (ans[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    string ans_str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= len1; i++) &#123;<br>      ans_str.<span class="hljs-built_in">push_back</span>(ans[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans_str;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而官方的题解仍然是最简洁的，一个循环解决问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = num1.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j = num2.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>    string ans;<br>    <span class="hljs-keyword">while</span> ((i &gt;= <span class="hljs-number">0</span>) || (j &gt;= <span class="hljs-number">0</span>) || (carry &gt; <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-type">int</span> x = (i &gt;= <span class="hljs-number">0</span>) ? num1[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> y = (j &gt;= <span class="hljs-number">0</span>) ? num2[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> sum = x + y + carry;<br>      ans.<span class="hljs-built_in">push_back</span>(sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>      carry = sum / <span class="hljs-number">10</span>;<br>      i--;<br>      j--;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>直接借助set实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    unordered_set&lt;ListNode *&gt; se;<br>    <span class="hljs-keyword">while</span> (headA != <span class="hljs-literal">nullptr</span>) &#123;<br>      se.<span class="hljs-built_in">emplace</span>(headA);<br>      headA = headA-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (headB != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">if</span> (se.<span class="hljs-built_in">count</span>(headB) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> headB;<br>      &#125;<br>      headB = headB-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然后便是官方题解的巧妙解法<br><img src="https://img-blog.csdnimg.cn/2c03567a66884743805d8767b721c4d1.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ListNode *pA = headA;<br>    ListNode *pB = headB;<br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>      pA = (pA == <span class="hljs-literal">nullptr</span>) ? headB : pA-&gt;next;<br>      pB = (pB == <span class="hljs-literal">nullptr</span>) ? headA : pB-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="环形链表与Floyd判圈算法"><a href="#环形链表与Floyd判圈算法" class="headerlink" title="环形链表与Floyd判圈算法"></a>环形链表与Floyd判圈算法</h2><p>141.环形链表<br>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p>142.环形链表 II<br>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>不允许修改 链表。</p>
<p>首先，使用最简单的思路，借助set实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* cur = head;<br>    set&lt;ListNode*&gt; se;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">if</span> (se.<span class="hljs-built_in">count</span>(cur) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      se.<span class="hljs-built_in">emplace</span>(cur);<br>      cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* cur = head;<br>    unordered_set&lt;ListNode*&gt; se;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">if</span> (se.<span class="hljs-built_in">count</span>(cur) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> cur;<br>      &#125;<br>      se.<span class="hljs-built_in">emplace</span>(cur);<br>      cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>利用Floyd算法，使用快慢指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 快慢指针</span><br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">// 使用do while，省去第一次判断</span><br>      <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;	<span class="hljs-comment">// 到达末尾，不存在环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      slow = slow-&gt;next;		<span class="hljs-comment">// 前进一步</span><br>      fast = fast-&gt;next-&gt;next;	<span class="hljs-comment">// 前进两步</span><br>    &#125; <span class="hljs-keyword">while</span> (slow != fast);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 快慢指针</span><br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>      &#125;<br>      slow = slow-&gt;next;<br>      fast = fast-&gt;next-&gt;next;<br>    &#125; <span class="hljs-keyword">while</span> (slow != fast);<br>    <span class="hljs-comment">// 从起点与快慢指针相遇点出发，直到在入口点相遇</span><br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span> (cur != slow) &#123;<br>      cur = cur-&gt;next;<br>      slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<p>分类讨论，是否从最开始进行反转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 只有一个节点</span><br>      <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* left_node_prev;<br>    ListNode* left_node;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 起始节点，则前置节点为空</span><br>      left_node_prev = <span class="hljs-literal">nullptr</span>;<br>      left_node = head;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left_node_prev = head;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>        left_node_prev = left_node_prev-&gt;next;<br>      &#125;<br>      left_node = left_node_prev-&gt;next;<br>    &#125;<br><br>    ListNode* prev = left_node;<br>    ListNode* curr = left_node-&gt;next;<br>    ListNode* next;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt; right; i++) &#123;<br>      next = curr-&gt;next;<br>      curr-&gt;next = prev;<br>      prev = curr;<br>      curr = next;<br>    &#125;<br>    <span class="hljs-comment">// 此时curr next为right node后继节点，prev为right node</span><br>    left_node-&gt;next = curr;<br>    <span class="hljs-keyword">if</span> (left_node_prev != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 此时链表头部并未改变</span><br>      left_node_prev-&gt;next = prev;<br>      <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 从头开始反转，头部改变</span><br>    <span class="hljs-keyword">return</span> prev;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用虚拟头结点，合并两种情况，统一处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 只有一个节点</span><br>      <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function">ListNode <span class="hljs-title">virt_head</span><span class="hljs-params">(<span class="hljs-number">-1</span>, head)</span></span>;  <span class="hljs-comment">// 虚拟头节点，便于统一处理</span><br>    <span class="hljs-comment">// 迭代至正确的左节点前置节点</span><br>    ListNode* left_node_prev = &amp;virt_head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; left; i++) &#123;<br>      left_node_prev = left_node_prev-&gt;next;<br>    &#125;<br>    ListNode* left_node = left_node_prev-&gt;next;<br>    ListNode* prev = left_node;<br>    ListNode* curr = left_node-&gt;next;  <span class="hljs-comment">// 处理左节点后继节点</span><br>    ListNode* next;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt; right; i++) &#123;<br>      next = curr-&gt;next;  <span class="hljs-comment">// 保存后继节点</span><br>      curr-&gt;next = prev;  <span class="hljs-comment">// 转向</span><br>      <span class="hljs-comment">// 向前移动</span><br>      prev = curr;<br>      curr = next;<br>    &#125;<br>    <span class="hljs-comment">// 此时curr next为right node后继节点，prev为right node</span><br>    <span class="hljs-comment">// 连接反转链表的头尾</span><br>    left_node-&gt;next = curr;<br>    left_node_prev-&gt;next = prev;<br>    <span class="hljs-keyword">return</span> virt_head.next;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>对题目有些误解，并不是一定旋转，将数组分为左半部右半部，若在不同分部，则一定向该方向前进，其他情况照常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> left_min = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> right_max = nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (right_max &lt; left_min) &#123;             <span class="hljs-comment">// 进行旋转</span><br>      <span class="hljs-type">bool</span> in_left = target &gt;= left_min;    <span class="hljs-comment">// 数字位于左半部</span><br>      <span class="hljs-type">bool</span> in_right = target &lt;= right_max;  <span class="hljs-comment">// 数字位于右半部</span><br>      <span class="hljs-keyword">if</span> (!in_left &amp;&amp; !in_right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;  <span class="hljs-comment">// 恰好相等，返回索引</span><br>          <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in_left &amp;&amp; nums[mid] &lt;= right_max) &#123;  <span class="hljs-comment">// 位置不一致，向左前进</span><br>          high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in_right &amp;&amp; nums[mid] &gt;= left_min) &#123;  <span class="hljs-comment">// 位置不一致，向右前进</span><br>          low = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;  <span class="hljs-comment">// 位置一致，向左前进</span><br>          high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;  <span class="hljs-comment">// 位置一致，向右前进</span><br>          low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 未进行旋转</span><br>      <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;  <span class="hljs-comment">// 恰好相等，返回索引</span><br>          <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;  <span class="hljs-comment">// 位置一致，向左前进</span><br>          high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;  <span class="hljs-comment">// 位置一致，向右前进</span><br>          low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用官方题解的方法，将数组分为有序部分与无序部分，利用有序部分特性与排除法锁定target所在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>      <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;  <span class="hljs-comment">// 找到目标值，返回下标</span><br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (nums[low] &lt;= nums[mid]) &#123;                       <span class="hljs-comment">// 前半部有序</span><br>        <span class="hljs-keyword">if</span> (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;  <span class="hljs-comment">// target是否存在前半部</span><br>          high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;                                             <span class="hljs-comment">// 后半部有序</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) &#123;  <span class="hljs-comment">// target是否存在后半部</span><br>          low = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[low] == target ? low : <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 判断最后一个元素是否为目标值</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h2><p>n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：<br>每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）<br>第一个整数是 0<br>一个整数在序列中出现 不超过一次<br>每对 相邻 整数的二进制表示 恰好一位不同 ，且<br>第一个 和 最后一个 整数的二进制表示 恰好一位不同<br>给你一个整数 n ，返回任一有效的 n 位格雷码序列 。<br><img src="https://img-blog.csdnimg.cn/85cd413dd651446d8ad9432f8910e7a7.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">grayCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;  <span class="hljs-comment">// 加入上半部的倒转，并将高位置一</span><br>        ans.<span class="hljs-built_in">emplace_back</span>(ans[j] | (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>)));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>我的解法是利用字符串相加+字符串乘整数实现字符串乘法，非常繁杂的算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(string&amp; num1, <span class="hljs-type">const</span> string&amp; num2)</span> </span>&#123;  <span class="hljs-comment">// num1 = num1 + num2，保证num1[i]永不越界</span><br>    <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-type">int</span> sum = num1[i] + num2[i] - <span class="hljs-number">2</span> * <span class="hljs-string">&#x27;0&#x27;</span> + carry;<br>      num1[i] = sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>      carry = sum / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (carry != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">int</span> sum = num1[i] - <span class="hljs-string">&#x27;0&#x27;</span> + carry;<br>      num1[i] = sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>      carry = sum / <span class="hljs-number">10</span>;<br>      i++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">string <span class="hljs-title">simpleMulti</span><span class="hljs-params">(string num1, <span class="hljs-type">int</span> x)</span> </span>&#123;  <span class="hljs-comment">// res = num1 * x,保证num1[i]永不越界，carry结束for循环后为0</span><br>    <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-type">int</span> sum = (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * x + carry;<br>      num1[i] = sum % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>      carry = sum / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num1;<br>  &#125;<br>  <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;  <span class="hljs-comment">// 没有前导零与后导零</span><br>    <span class="hljs-keyword">if</span> (num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>) &#123;          <span class="hljs-comment">// 排除结果为0的特殊情况</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">ans</span><span class="hljs-params">(num1.size() + num2.size() + <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;  <span class="hljs-comment">// 申请足够大的空间，避免溢出</span><br>    <span class="hljs-built_in">reverse</span>(num1.<span class="hljs-built_in">begin</span>(), num1.<span class="hljs-built_in">end</span>());               <span class="hljs-comment">// 反转num1</span><br>    num1.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span>);                             <span class="hljs-comment">// 加入一个前导零，简化乘法carry计算</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      string local_multi = <span class="hljs-built_in">simpleMulti</span>(num1, num2[i] - <span class="hljs-string">&#x27;0&#x27;</span>);  <span class="hljs-comment">// num1 * x</span><br>      <span class="hljs-function">string <span class="hljs-title">prefix</span><span class="hljs-params">(num2.size() - <span class="hljs-number">1</span> - i, <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;                <span class="hljs-comment">// 加入若干位0，移位运算</span><br>      <span class="hljs-built_in">add</span>(ans, prefix + local_multi);                         <span class="hljs-comment">// ans += num1 * x * 10^y</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> end = ans.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 从后往前数第一个不为&#x27;0&#x27;的坐标</span><br>    <span class="hljs-keyword">while</span> (ans[end] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>      end--;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">begin</span>() + end + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 反转，得到最终结果</span><br>    <span class="hljs-keyword">return</span> ans.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, end + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>官方题解使用vector从右往左向乘，结果位数要么为m+n-1,m+n<br><img src="https://img-blog.csdnimg.cn/a7cc5a3366c14c09929aa45272d91a44.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> len1 = num1.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> len2 = num2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans_arr</span><span class="hljs-params">(len1 + len2)</span></span>;  <span class="hljs-comment">// 用int存储每一位的数</span><br>    <span class="hljs-comment">// 从右往前乘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        ans_arr[i + j + <span class="hljs-number">1</span>] += (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len1 + len2 - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>      ans_arr[i - <span class="hljs-number">1</span>] += ans_arr[i] / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 向前进位</span><br>      ans_arr[i] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> start = (ans_arr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    string ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; len1 + len2; i++) &#123;<br>      ans.<span class="hljs-built_in">push_back</span>(ans_arr[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>我使用的方法是先遍历一遍，标记无效数字，然后再次遍历，将前面的无效数与后面的有效数交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kInvaild = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> last_number = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> invaild_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] == last_number) &#123;  <span class="hljs-comment">// 重复数字</span><br>        nums[i] = kInvaild;<br>        invaild_count++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        last_number = nums[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (invaild_count == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 数组没有重复数字</span><br>      <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-type">int</span> new_len = nums.<span class="hljs-built_in">size</span>() - invaild_count;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (start &lt; new_len) &#123;            <span class="hljs-comment">// 数字迁移完成后start==new_len</span><br>      <span class="hljs-keyword">while</span> (nums[start] != kInvaild) &#123;  <span class="hljs-comment">// 寻找第一个无效数（空位）</span><br>        start++;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (start == new_len) &#123;  <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      end = start;<br>      <span class="hljs-keyword">while</span> (nums[end] == kInvaild) &#123;  <span class="hljs-comment">// 寻找第一个有效数</span><br>        end++;<br>      &#125;<br>      <span class="hljs-built_in">swap</span>(nums[start], nums[end]);  <span class="hljs-comment">// 有效数无效数交换</span><br>      start++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> new_len;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而官方题解使用快慢指针的方法解决，非常简洁的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 快慢指针</span><br>    <span class="hljs-type">int</span> fast = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (fast = <span class="hljs-number">1</span>; fast &lt; nums.<span class="hljs-built_in">size</span>(); fast++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[fast] != nums[fast - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 不为重复数</span><br>        nums[slow] = nums[fast];<br>        slow++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>一：最简单的方法 dfs+set</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(set&lt;string&gt;&amp; result, string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;  <span class="hljs-comment">// 全排列+set去重</span><br>    <span class="hljs-keyword">if</span> (start == end) &#123;<br>      result.<span class="hljs-built_in">emplace</span>(s);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; end; i++) &#123;<br>      <span class="hljs-built_in">swap</span>(s[i], s[start]);<br>      <span class="hljs-built_in">dfs</span>(result, s, start + <span class="hljs-number">1</span>, end);<br>      <span class="hljs-built_in">swap</span>(s[i], s[start]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    set&lt;string&gt; ans;<br>    <span class="hljs-built_in">dfs</span>(ans, s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;string&gt;(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>二： 有条件的dfs，我自己实现的代码只保证了没有与start重复，要保证该位置没有任何重复字符需利用set</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt;&amp; result, string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start == end) &#123;<br>      result.<span class="hljs-built_in">emplace_back</span>(s);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    set&lt;<span class="hljs-type">char</span>&gt; se;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; end; i++) &#123;<br>      <span class="hljs-comment">// if (i != start &amp;&amp; s[i] == s[start]) &#123;  // 剪枝，只保证没有与s[start]重复</span><br>      <span class="hljs-comment">//   continue;</span><br>      <span class="hljs-comment">// &#125;</span><br>      <span class="hljs-keyword">if</span> (se.<span class="hljs-built_in">count</span>(s[i]) != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 保证该位置没有重复字符</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      se.<span class="hljs-built_in">emplace</span>(s[i]);<br>      <span class="hljs-built_in">swap</span>(s[i], s[start]);<br>      <span class="hljs-built_in">dfs</span>(result, s, start + <span class="hljs-number">1</span>, end);<br>      <span class="hljs-built_in">swap</span>(s[i], s[start]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-built_in">dfs</span>(ans, s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>三：巧妙利用下一个排列算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">next</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;  <span class="hljs-comment">// 求字符串下一个排列，注意参数为引用传递</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 寻找较小数</span><br>      <span class="hljs-keyword">if</span> (s[i] &lt; s[i + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;  <span class="hljs-comment">// 寻找较大数</span><br>      <span class="hljs-keyword">if</span> (s[j] &gt; s[i]) &#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[j]);  <span class="hljs-comment">// 交换</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, s.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 反转</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 升序排列</span><br>    <span class="hljs-keyword">do</span> &#123;<br>      ans.<span class="hljs-built_in">emplace_back</span>(s);<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next</span>(s));<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>简单题，但我的实现非常慢，因为我解决deleteHead的方法就是立即转移所有数据至另一个栈，没有想到部分数据迁移</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CQueue</span>() : in_normal_&#123;<span class="hljs-literal">true</span>&#125; &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!in_normal_) &#123;  <span class="hljs-comment">// 当前在反转栈，需转移数据</span><br>      <span class="hljs-keyword">while</span> (!reverse_.<span class="hljs-built_in">empty</span>()) &#123;<br>        normal_.<span class="hljs-built_in">emplace</span>(reverse_.<span class="hljs-built_in">top</span>());<br>        reverse_.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>      in_normal_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    normal_.<span class="hljs-built_in">emplace</span>(value);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (in_normal_) &#123;  <span class="hljs-comment">// 当前在正常栈，需转移数据</span><br>      <span class="hljs-keyword">while</span> (!normal_.<span class="hljs-built_in">empty</span>()) &#123;<br>        reverse_.<span class="hljs-built_in">emplace</span>(normal_.<span class="hljs-built_in">top</span>());<br>        normal_.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>      in_normal_ = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (reverse_.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = reverse_.<span class="hljs-built_in">top</span>();<br>    reverse_.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  stack&lt;<span class="hljs-type">int</span>&gt; normal_;   <span class="hljs-comment">// 在正常的栈</span><br>  stack&lt;<span class="hljs-type">int</span>&gt; reverse_;  <span class="hljs-comment">// 在反转的栈</span><br>  <span class="hljs-type">bool</span> in_normal_;      <span class="hljs-comment">// 记录数据位置</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>官方题解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CQueue</span>() &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; in_stack_.<span class="hljs-built_in">emplace</span>(value); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (out_stack_.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 若输出栈为空则转移元素</span><br>      <span class="hljs-keyword">if</span> (in_stack_.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      <span class="hljs-keyword">while</span> (!in_stack_.<span class="hljs-built_in">empty</span>()) &#123;<br>        out_stack_.<span class="hljs-built_in">emplace</span>(in_stack_.<span class="hljs-built_in">top</span>());<br>        in_stack_.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = out_stack_.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 输出栈栈顶元素</span><br>    out_stack_.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  stack&lt;<span class="hljs-type">int</span>&gt; in_stack_;   <span class="hljs-comment">// 输入栈</span><br>  stack&lt;<span class="hljs-type">int</span>&gt; out_stack_;  <span class="hljs-comment">// 输出栈</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h2><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<p>刚开始的时候我一直返回{}，而不是{nullptr}，有时候将空指针视作一个节点便于理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;TreeNode *&gt; <span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">nullptr</span>&#125;;  <span class="hljs-comment">// 关键点，没放入空指针</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (start == end) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(start)&#125;;<br>    &#125;<br>    vector&lt;TreeNode *&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;<br>      <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">generate</span>(start, i - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">generate</span>(i + <span class="hljs-number">1</span>, end);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> left_node : left) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> right_node : right) &#123;<br>          TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i);<br>          root-&gt;left = left_node;<br>          root-&gt;right = right_node;<br>          ans.<span class="hljs-built_in">emplace_back</span>(root);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  <span class="hljs-function">vector&lt;TreeNode *&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">generate</span>(<span class="hljs-number">1</span>, n); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="和至少为-K-的最短子数组"><a href="#和至少为-K-的最短子数组" class="headerlink" title="和至少为 K 的最短子数组"></a>和至少为 K 的最短子数组</h2><p>给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。</p>
<p>子数组 是数组中 连续 的一部分。</p>
<p>我的方法是简单的dp+枚举，但一直超出时间限制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;  <span class="hljs-comment">// 以nums[i]结尾的最大连续和</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      dp[i] = nums[i] + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, dp[i - <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 要么加上之前的连续和，要么重新开始</span><br>    &#125;<br>    <span class="hljs-type">int</span> min_len = nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 肯定不是最短子数组</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (dp[i] &gt;= k) &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (sum &lt; k) &#123;  <span class="hljs-comment">// 向前累加，直至总和大于k</span><br>          sum += nums[j];<br>          j--;<br>        &#125;<br>        min_len = <span class="hljs-built_in">min</span>(min_len, i - j);  <span class="hljs-comment">// 子数组长度</span><br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> min_len &lt;= nums.<span class="hljs-built_in">size</span>() ? min_len : <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而官方题解采用的是前缀和加双端递增序列的方式<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution/liang-zhang-tu-miao-dong-dan-diao-dui-li-9fvh/">两张图秒懂单调队列（Python&#x2F;Java&#x2F;C++&#x2F;Go）</a></p>
<blockquote>
<p>由于优化二保证了数据结构中的 s[i] 会形成一个递增的序列，因此优化一移除的是序列最左侧的若干元素，优化二移除的是序列最右侧的若干元素。我们需要一个数据结构，它支持移除最左端的元素和最右端的元素，以及在最右端添加元素，故选用双端队列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// p[i]-p[i-1] = s[0..i-1]</span><br>    prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      prefix[i] = prefix[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> min_len = nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>    deque&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">// 单调递增序列</span><br>    q.<span class="hljs-built_in">emplace_front</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; (prefix[i] - prefix[q.<span class="hljs-built_in">front</span>()] &gt;= k)) &#123;  <span class="hljs-comment">// 从左往右，寻找差值大于等于k的区间</span><br>        min_len = <span class="hljs-built_in">min</span>(min_len, i - q.<span class="hljs-built_in">front</span>());<br>        q.<span class="hljs-built_in">pop_front</span>();<br>      &#125;<br>      <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; prefix[i] &lt;= prefix[q.<span class="hljs-built_in">back</span>()]) &#123;  <span class="hljs-comment">// 维持单调递增关系</span><br>        q.<span class="hljs-built_in">pop_back</span>();<br>      &#125;<br>      q.<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> min_len &lt;= nums.<span class="hljs-built_in">size</span>() ? min_len : <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="下一个更大元素-III"><a href="#下一个更大元素-III" class="headerlink" title="下一个更大元素 III"></a>下一个更大元素 III</h2><p>给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。</p>
<p>注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1 。</p>
<p>下一个排列算法的应用<br>一：借助vector拆解数字n</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">10</span>) &#123;  <span class="hljs-comment">// 个位数，提前退出</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将每个位的数字压入数组</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>      nums.<span class="hljs-built_in">emplace_back</span>(n % <span class="hljs-number">10</span>);<br>      n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 寻找较小数</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 降序排列，最大值</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 寻找较大数并交换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>      <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>        <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对其后的数进行反转</span><br>    <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>      ans = ans * <span class="hljs-number">10</span> + num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans &gt; INT_MAX ? <span class="hljs-number">-1</span> : ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>二：借助string拆解数字n</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">10</span>) &#123;  <span class="hljs-comment">// 个位数，提前退出</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> nums = <span class="hljs-built_in">to_string</span>(n);<br>    <span class="hljs-comment">// 寻找较小数</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 降序排列，最大值</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 寻找较大数并交换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>      <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>        <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对其后的数进行反转</span><br>    <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-built_in">stol</span>(nums);<br>    <span class="hljs-keyword">return</span> ans &gt; INT_MAX ? <span class="hljs-number">-1</span> : ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。<br><strong>相关算法</strong><br><img src="https://img-blog.csdnimg.cn/46ee6725e6ef45be84006e0837692898.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 找到第一个s[i]&lt;s[i+1] 较小数</span><br>      <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">for</span> (j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;  <span class="hljs-comment">// 若找到i，则从后往前找到第一个比它大的数s[j] 较大数</span><br>        <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-built_in">swap</span>(nums[i], nums[j]);  <span class="hljs-comment">// 交换两数</span><br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 一：若找到i，则将i后所有数反转 二：若未找到i，直接整体降序变升序</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="分割回文串-II"><a href="#分割回文串-II" class="headerlink" title="分割回文串 II"></a>分割回文串 II</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 最少分割次数 。</p>
<p>同样是之前没写出来的题目，同样现在也没想出来，动态规划总是看之前啥也想不出来，看之后恍然大悟，代码几行写完。<br><img src="https://img-blog.csdnimg.cn/d55a3bf62f2b46f99d0d4517bb84ee75.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">g</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">true</span>));  <span class="hljs-comment">// g[i][j]表示s[i...j]是否为字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        g[i][j] = g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i] == s[j]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, n)</span></span>;  <span class="hljs-comment">// f[i]为s[0...i]的最少分割次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>][i]) &#123;  <span class="hljs-comment">// 本身即为回文串，不用分割</span><br>        f[i] = <span class="hljs-number">0</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>          <span class="hljs-keyword">if</span> (g[j + <span class="hljs-number">1</span>][i]) &#123;  <span class="hljs-comment">// s[j+1...i]为回文字符串</span><br>            f[i] = <span class="hljs-built_in">min</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>我发现动态规划的解要不然就是聚合所有子问题的解（f[0…i-1]），要么就是聚合满足特定条件子问题的解（s[j+1…i]为回文字符串，f[i] &#x3D; min(f[i], f[j] + 1)）</p>
<h2 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h2><p>给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。</p>
<p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的 商 。</p>
<p>注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。</p>
<p>同样是2019年没写出来的题目，现在同样也没写出来。官方题解使用快速乘+二分查找解决<br><img src="https://img-blog.csdnimg.cn/3ade98606c98485b9f950993c738c647.png" srcset="/img/loading.gif" lazyload><br>当时我一直想的是将负数映射到正数有可能会溢出，分类讨论又太麻烦，却忘了可以将正数映射到负数，<strong>函数实现时最好首先把特殊情况排除</strong>，然后再实现通用功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;  <span class="hljs-comment">// z * y &gt;= x 是否成立</span><br>    <span class="hljs-type">int</span> cum = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 奇数y乘积累加值</span><br>    <span class="hljs-type">int</span> add = y;                     <span class="hljs-comment">// y的乘积</span><br>    <span class="hljs-keyword">while</span> (z) &#123;<br>      <span class="hljs-keyword">if</span> (z &amp; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 需要保证 result + add &gt;= x</span><br>        <span class="hljs-keyword">if</span> (cum &lt; x - add) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        cum += add;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (z != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 需要保证 add + add &gt;= x</span><br>        <span class="hljs-keyword">if</span> (add &lt; x - add) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        add += add;<br>      &#125;<br>      <span class="hljs-comment">// 不能使用除法</span><br>      z &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> </span>&#123;<br>    <span class="hljs-comment">// 排除一系列的特殊情况</span><br>    <span class="hljs-keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> INT_MIN;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">return</span> INT_MAX;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (divisor == INT_MIN) &#123;<br>      <span class="hljs-keyword">return</span> dividend == INT_MIN ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dividend == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 全部变成负数</span><br>    <span class="hljs-type">bool</span> rev = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 结果是否乘以-1</span><br>    <span class="hljs-keyword">if</span> (dividend &gt; <span class="hljs-number">0</span>) &#123;<br>      dividend = -dividend;<br>      rev = !rev;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (divisor &gt; <span class="hljs-number">0</span>) &#123;<br>      divisor = -divisor;<br>      rev = !rev;<br>    &#125;<br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right = INT_MAX;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>      <span class="hljs-type">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>      <span class="hljs-type">bool</span> ret = <span class="hljs-built_in">check</span>(dividend, divisor, mid);  <span class="hljs-comment">// mid(+) * divisor(-) &gt;= dividend(-)</span><br>      <span class="hljs-keyword">if</span> (ret) &#123;<br>        ans = mid;<br>        <span class="hljs-keyword">if</span> (mid == INT_MAX) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左边界增大</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 右边界减小</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rev ? -ans : ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="K-站中转内最便宜的航班"><a href="#K-站中转内最便宜的航班" class="headerlink" title="K 站中转内最便宜的航班"></a>K 站中转内最便宜的航班</h2><p>有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] &#x3D; [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。</p>
<p>现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。</p>
<p>这个题我2019年一直没做出来，我隐隐约约觉得是用BFS什么的做的，可我写了半天，越写越复杂，我就知道这一次我又做不出来了。看了看题解，动态规划，几行代码搞定，蚌！</p>
<p>当代码越来越复杂的时候，就可以想想是不是思路不正确了，而且这个时候大概率要用动态规划了。当题目中这种最多经过K个这种条件出现时，如果很容易放入最短路径的放缩条件，则照常使用最短路径算法，否则将其依次拆分为恰好为[0-k]时到达dst的路径长度，最终结果取其最值，很多的状态转移方程都是这种拆分+最值的思想。</p>
<p><img src="https://img-blog.csdnimg.cn/3f1349d61ba74195bc8bb1821b945e6b.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> kMaxLen = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>);<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用滚动数组存储f  f[t][j] 表示通过恰好t次航班，从出发城市src到达城市j需要的最小花费</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, kMaxLen));<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>    f[<span class="hljs-number">0</span>][src] = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">1</span>][src] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = kMaxLen;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= k + <span class="hljs-number">1</span>; t++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; flight : flights) &#123; <span class="hljs-comment">// (i,j,cost)</span><br>        f[cur][flight[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">min</span>(f[cur][flight[<span class="hljs-number">1</span>]], f[pre][flight[<span class="hljs-number">0</span>]] + flight[<span class="hljs-number">2</span>]); <span class="hljs-comment">// f[t][j] = min(f[t][j] , f[t−1][i]+cost(i,j))</span><br>      &#125;<br>      ans = <span class="hljs-built_in">min</span>(ans, f[cur][dst]);<br>      pre = (pre + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>      cur = (cur + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans == kMaxLen ? <span class="hljs-number">-1</span> : ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>定义无穷值时最好不要定义为INT_MAX，这样就无法进行相加操作</p>
<h2 id="N-字形变换"><a href="#N-字形变换" class="headerlink" title="N 字形变换"></a>N 字形变换</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">P   A   H   N<br>A P L S I I G<br>Y   I   R<br></code></pre></td></tr></table></figure>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>我的解法就是简单的分成两端，向下的序列和向上的序列，而后用两个for循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">zigstr</span><span class="hljs-params">(numRows, <span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (index &lt; s.<span class="hljs-built_in">length</span>()) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows &amp;&amp; index &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;  <span class="hljs-comment">// 向下</span><br>        zigstr[i].<span class="hljs-built_in">push_back</span>(s[index]);<br>        index++;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = numRows - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span> &amp;&amp; index &lt; s.<span class="hljs-built_in">length</span>(); i--) &#123;  <span class="hljs-comment">// 向上</span><br>        zigstr[i].<span class="hljs-built_in">push_back</span>(s[index]);<br>        index++;<br>      &#125;<br>    &#125;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (string&amp; str : zigstr) &#123;<br>      ans.<span class="hljs-built_in">append</span>(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>官方则简洁一点，将两个for循环合并在一起，且以index为下标递增，注意numRows &#x3D; 1的特殊情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span> || numRows &gt;= s.<span class="hljs-built_in">length</span>()) &#123;  <span class="hljs-comment">// 特殊情况，保证period大于0</span><br>      <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">zigstr</span><span class="hljs-params">(numRows, <span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>    <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> period = <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>      zigstr[row].<span class="hljs-built_in">push_back</span>(s[i]);<br>      <span class="hljs-keyword">if</span> (i % period &lt; numRows - <span class="hljs-number">1</span>) &#123;<br>        row++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        row--;<br>      &#125;<br>    &#125;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (string&amp; str : zigstr) &#123;<br>      ans.<span class="hljs-built_in">append</span>(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>刚开始我想的方法也是官方题解一样的使用set然后加入删除，但觉得这有点费劲，而且是字符，最大才255，就使用数组来存储，并分别记录每个位置的前一个相同字符位置和后一个相同字符，这样就能快速移动左右指针。<strong>右指针移动失败一定因为遇到相同字符或字符串末尾，而左指针可以直接跳转至该失败位置的前一个相同字符位置后+1</strong>，因为在其前面的位置都会在右指针位置失败，而长度均小于该次长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">last_occur_index</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">-1</span>)</span></span>;                <span class="hljs-comment">// 该字符上次出现的索引</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next_same_index</span><span class="hljs-params">(s.length(), s.length())</span></span>;  <span class="hljs-comment">// 下一个相同字符索引</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre_same_index</span><span class="hljs-params">(s.length(), s.length())</span></span>;   <span class="hljs-comment">// 上一个相同字符索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (last_occur_index[s[i]] != <span class="hljs-number">-1</span>) &#123;<br>        next_same_index[last_occur_index[s[i]]] = i;<br>      &#125;<br>      pre_same_index[i] = last_occur_index[s[i]];<br>      last_occur_index[s[i]] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max_substr_len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (start &lt; s.<span class="hljs-built_in">length</span>()) &#123;<br>      <span class="hljs-type">int</span> possible_bound = s.<span class="hljs-built_in">length</span>();<br>      <span class="hljs-type">int</span> end = start;<br>      <span class="hljs-keyword">while</span> (end &lt; possible_bound) &#123;                                 <span class="hljs-comment">// 小于可能的边界（下一个相同字符/字符串长度）</span><br>        possible_bound = <span class="hljs-built_in">min</span>(possible_bound, next_same_index[end]);  <span class="hljs-comment">// 下一个重复字符位置</span><br>        end++;<br>      &#125;<br>      max_substr_len = <span class="hljs-built_in">max</span>(max_substr_len, end - start);<br>      <span class="hljs-keyword">if</span> (end &gt;= s.<span class="hljs-built_in">length</span>()) &#123;<br>        <span class="hljs-keyword">return</span> max_substr_len;<br>      &#125;<br>      <span class="hljs-comment">// 直接移动至失败位置的前一个相同字符位置后，在其前面的位置都会在end处失败</span><br>      start = pre_same_index[end] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_substr_len;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h2><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<p>我的思路比较简单，把一个数固定，解决最接近的两数之和，但在枚举时我采用的方法是将固定数置为无效，两数之和函数中还需对无效坐标进行特殊处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">twoSumClosest</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> invaild_index, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 求两数之和最接近target，invaild_index为无效下标</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> closest_sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> min_abs = INT32_MAX;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>      <span class="hljs-keyword">if</span> (i == invaild_index) &#123;<br>        i++;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == invaild_index) &#123;<br>        j--;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (i &gt;= j) &#123;  <span class="hljs-comment">// 此时有可能违反条件</span><br>        <span class="hljs-keyword">return</span> closest_sum;<br>      &#125;<br>      <br>      <span class="hljs-type">int</span> sum = nums[i] + nums[j];<br>      <span class="hljs-type">int</span> abs_val = <span class="hljs-built_in">abs</span>(sum - target);<br>      <span class="hljs-keyword">if</span> (abs_val &lt; min_abs) &#123;<br>        min_abs = abs_val;<br>        closest_sum = sum;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>        j--;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>        i++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> target;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> closest_sum;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> three_closest_sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> min_abs = INT32_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-type">int</span> two_closest_sum = <span class="hljs-built_in">twoSumClosest</span>(nums, i, target - nums[i]);<br>      <span class="hljs-type">int</span> abs_val = <span class="hljs-built_in">abs</span>(two_closest_sum + nums[i] - target);<br>      <span class="hljs-keyword">if</span> (abs_val &lt; min_abs) &#123;<br>        min_abs = abs_val;<br>        three_closest_sum = two_closest_sum + nums[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> three_closest_sum;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而官方题解比我的代码改进的点就在于每次只需枚举固定数后面的数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">twoSumClosest</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start_index, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 求两数之和最接近target，start_index为起始下标</span><br>    <span class="hljs-type">int</span> i = start_index;<br>    <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> closest_sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> min_abs = INT32_MAX;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>      <span class="hljs-type">int</span> sum = nums[i] + nums[j];<br>      <span class="hljs-type">int</span> abs_val = <span class="hljs-built_in">abs</span>(sum - target);<br>      <span class="hljs-keyword">if</span> (abs_val &lt; min_abs) &#123;<br>        min_abs = abs_val;<br>        closest_sum = sum;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>        j--;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>        i++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> target;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> closest_sum;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> three_closest_sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> min_abs = INT32_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>      <span class="hljs-type">int</span> two_closest_sum = <span class="hljs-built_in">twoSumClosest</span>(nums, i + <span class="hljs-number">1</span>, target - nums[i]);  <span class="hljs-comment">// [i+1,n-1]</span><br>      <span class="hljs-type">int</span> abs_val = <span class="hljs-built_in">abs</span>(two_closest_sum + nums[i] - target);<br>      <span class="hljs-keyword">if</span> (abs_val &lt; min_abs) &#123;<br>        min_abs = abs_val;<br>        three_closest_sum = two_closest_sum + nums[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> three_closest_sum;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>我的解法，经典的双指针合并，用了额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums1_copy</span><span class="hljs-params">(nums1.begin(), nums1.begin() + m)</span></span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>      <span class="hljs-keyword">if</span> (nums1_copy[i] &lt; nums2[j]) &#123;<br>        nums1[k] = nums1_copy[i];<br>        i++;<br>        k++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        nums1[k] = nums2[j];<br>        j++;<br>        k++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; m) &#123;<br>      nums1[k] = nums1_copy[i];<br>      i++;<br>      k++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>      nums1[k] = nums2[j];<br>      j++;<br>      k++;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>官方题解，同样使用双指针，但是逆向遍历<br><img src="https://img-blog.csdnimg.cn/79644d4540714562b8ddce9ec2e80a63.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = m + n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;<br>        nums1[k] = nums1[i];<br>        i--;<br>        k--;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        nums1[k] = nums2[j];<br>        j--;<br>        k--;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>      nums1[k] = nums1[i];<br>      i--;<br>      k--;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>      nums1[k] = nums2[j];<br>      j--;<br>      k--;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p>我的解法，朴素的dfs</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *node, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> *max_level)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>      *max_level = <span class="hljs-built_in">max</span>(*max_level, level);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">dfs</span>(node-&gt;left, level + <span class="hljs-number">1</span>, max_level);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">dfs</span>(node-&gt;right, level + <span class="hljs-number">1</span>, max_level);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>, &amp;ans);<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>简洁的官方题解，两行实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。</p>
<p>看到是简单题，就没想啥高深的方法，遍历一遍数组，维护局部最大连续和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max_val = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 连续和</span><br>    <span class="hljs-type">bool</span> vaild = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 连续和是否有效，边界情况即为全部负数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>      <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 连续和开始减小，需在之前保存状态</span><br>        <span class="hljs-keyword">if</span> (vaild) &#123;<br>          max_val = <span class="hljs-built_in">max</span>(max_val, sum);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          max_val = <span class="hljs-built_in">max</span>(max_val, num);<br>        &#125;<br>      &#125;<br>      sum += num;<br>      vaild = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 重置连续和</span><br>        sum = <span class="hljs-number">0</span>;<br>        vaild = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vaild) &#123;  <span class="hljs-comment">// 结束前进行一次判断</span><br>      max_val = <span class="hljs-built_in">max</span>(max_val, sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_val;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>没想到官方题解竟然用到了动态规划的思想，虽然代码非常简单<br><img src="https://img-blog.csdnimg.cn/dfa22e3caf4546838f9058d722317ad0.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max_val = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>      pre = <span class="hljs-built_in">max</span>(pre + num, num);<br>      max_val = <span class="hljs-built_in">max</span>(max_val, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_val;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="二叉树中的最长交错路径"><a href="#二叉树中的最长交错路径" class="headerlink" title="二叉树中的最长交错路径"></a>二叉树中的最长交错路径</h2><p>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</p>
<p>选择二叉树中 任意 节点和一个方向（左或者右）。<br>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。<br>改变前进方向：左变右或者右变左。<br>重复第二步和第三步，直到你在树中无法继续移动。 </p>
<p>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。<br>请你返回给定树中最长 交错路径 的长度。</p>
<p>没写出来，没理解题意，交错路径的末尾不一定是叶子节点，自己写的dfs超时了，抄的官方题解<br><img src="https://img-blog.csdnimg.cn/a1b3f762acd14d25a7c73db44c819d35.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *node, <span class="hljs-type">int</span> dir, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    max_len_ = <span class="hljs-built_in">max</span>(max_len_, len);  <span class="hljs-comment">// 记录当前最长交错路径</span><br>    <span class="hljs-keyword">if</span> (dir == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 向左子树前进，继续当前路径</span><br>        <span class="hljs-built_in">dfs</span>(node-&gt;left, <span class="hljs-number">1</span>, len + <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 另开一个路径</span><br>        <span class="hljs-built_in">dfs</span>(node-&gt;right, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dir == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 另开一个路径</span><br>        <span class="hljs-built_in">dfs</span>(node-&gt;left, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 向右子树前进，继续当前路径</span><br>        <span class="hljs-built_in">dfs</span>(node-&gt;right, <span class="hljs-number">0</span>, len + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestZigZag</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    max_len_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> max_len_;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> max_len_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="验证二叉树的前序序列化"><a href="#验证二叉树的前序序列化" class="headerlink" title="验证二叉树的前序序列化"></a>验证二叉树的前序序列化</h2><p>序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。<br>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>利用前序遍历的特点，叶子节点的两个空节点一定紧紧挨着该叶子节点，所以可以将x # #格式的数据等价为#，即该叶子节点为空的序列，逆序遍历序列并一直利用这种方法消除节点，最终合法的前序遍历序列会归约到一个空节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(string preorder)</span> </span>&#123;<br>    <span class="hljs-type">int</span> empty_node_cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 空节点个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = preorder.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">if</span> (preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>        empty_node_cnt++;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (empty_node_cnt &lt; <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 没有足够的空节点</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        empty_node_cnt--;                       <span class="hljs-comment">// 合并节点，将x # #变为#</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span>) &#123;  <span class="hljs-comment">// 移动至前面的逗号处</span><br>          i--;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> empty_node_cnt == <span class="hljs-number">1</span>;  <span class="hljs-comment">// 最终合并结果为一个空节点</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="两句话中的不常见单词"><a href="#两句话中的不常见单词" class="headerlink" title="两句话中的不常见单词"></a>两句话中的不常见单词</h2><p>句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。<br>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。<br>给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。</p>
<p>简单题，明显是分割字符串后加入哈希表，我采用的方法是使用find substr分割出单词，而官方题解利用<strong>stringstream</strong>来分割句子中的单词</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">uncommonFromSentences</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    s1.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);  <span class="hljs-comment">// 末尾加入空格，便于统一处理</span><br>    s2.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-function">string_view <span class="hljs-title">view1</span><span class="hljs-params">(s1)</span></span>;<br>    <span class="hljs-function">string_view <span class="hljs-title">view2</span><span class="hljs-params">(s2)</span></span>;<br>    unordered_map&lt;string_view, <span class="hljs-type">int</span>&gt; count;  <span class="hljs-comment">// 单词与出现次数映射</span><br>    <span class="hljs-type">int</span> last_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> pos;<br>    <span class="hljs-keyword">while</span> ((pos = view1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>, last_pos)) != string::npos) &#123;  <span class="hljs-comment">// 切割字符串</span><br>      count[view1.<span class="hljs-built_in">substr</span>(last_pos, pos - last_pos)]++;<br>      last_pos = pos + <span class="hljs-number">1</span>;<br>    &#125;<br>    last_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((pos = view2.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>, last_pos)) != string::npos) &#123;  <span class="hljs-comment">// 切割字符串</span><br>      count[view2.<span class="hljs-built_in">substr</span>(last_pos, pos - last_pos)]++;<br>      last_pos = pos + <span class="hljs-number">1</span>;<br>    &#125;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; kv : count) &#123;<br>      <span class="hljs-keyword">if</span> (kv.second == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 将出现次数为1的单词加入结果集合</span><br>        res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">string</span>(kv.first));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">uncommonFromSentences</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; freq;<br>        <br>        <span class="hljs-keyword">auto</span> insert = [&amp;](<span class="hljs-type">const</span> string&amp; s) &#123;<br>            stringstream <span class="hljs-built_in">ss</span>(s);<br>            string word;<br>            <span class="hljs-keyword">while</span> (ss &gt;&gt; word) &#123;<br>                ++freq[<span class="hljs-built_in">move</span>(word)];<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-built_in">insert</span>(s1);<br>        <span class="hljs-built_in">insert</span>(s2);<br><br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [word, occ]: freq) &#123;<br>            <span class="hljs-keyword">if</span> (occ == <span class="hljs-number">1</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(word);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="二叉树最底层最左边的值"><a href="#二叉树最底层最左边的值" class="headerlink" title="二叉树最底层最左边的值"></a>二叉树最底层最左边的值</h2><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。</p>
<p>这个题很容易想到使用BFS或DFS，不过感觉BFS适合一点，实现时我将层级信息一并存储，并保证左子节点先加入队列，后通过比较当前层级信息来得到该层的第一个叶子节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    queue&lt;pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt;&gt; q;  <span class="hljs-comment">// 存储节点指针与相应层数</span><br>    q.<span class="hljs-built_in">emplace</span>(root, <span class="hljs-number">1</span>);              <span class="hljs-comment">// 放入根节点</span><br>    <span class="hljs-type">int</span> max_level = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left_value = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [node, level] = q.<span class="hljs-built_in">front</span>();<br>      q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">if</span> (level &gt; max_level &amp;&amp; node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 叶子节点</span><br>        max_level = level;<br>        left_value = node-&gt;val;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;         <span class="hljs-comment">// 保证左子节点更早被访问</span><br>        q.<span class="hljs-built_in">emplace</span>(node-&gt;left, level + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 层数加一</span><br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>        q.<span class="hljs-built_in">emplace</span>(node-&gt;right, level + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left_value;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而官方题解则直接让<strong>右边的子节点先加入队列</strong>，省去大段的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> p = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (p-&gt;right) &#123;<br>                q.<span class="hljs-built_in">push</span>(p-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p-&gt;left) &#123;<br>                q.<span class="hljs-built_in">push</span>(p-&gt;left);<br>            &#125;<br>            ret = p-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="删除子文件夹"><a href="#删除子文件夹" class="headerlink" title="删除子文件夹"></a>删除子文件夹</h2><p>你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。<br>如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。<br>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。<br>例如，”&#x2F;leetcode” 和 “&#x2F;leetcode&#x2F;problems” 都是有效的路径，而空字符串和 “&#x2F;“ 不是。</p>
<p>没想到啥高深的方法，就直接对数组进行排序，而后依次判断各个文件夹是否为前面最后一个独立文件夹（即不是其他文件夹的子文件夹）的子文件夹。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubFolder</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s1, <span class="hljs-type">const</span> string&amp; s2)</span> </span>&#123;  <span class="hljs-comment">// s2是否为s1的子文件夹</span><br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">length</span>() &gt;= s2.<span class="hljs-built_in">length</span>()) &#123;                     <span class="hljs-comment">// 长度不符合要求</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> s1_len = s1.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s1_len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (s1[i] != s2[i]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s2[s1_len] == <span class="hljs-string">&#x27;/&#x27;</span>;  <span class="hljs-comment">// 前缀完全相同，还需下一个字符为分隔符，避免 /c  /ca的情况</span><br>  &#125;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-type">int</span> folder_size = folder.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">sort</span>(folder.<span class="hljs-built_in">begin</span>(), folder.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 按ascii码排序，父文件夹一定在其子文件夹前面</span><br>    res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(folder[<span class="hljs-number">0</span>]));   <span class="hljs-comment">// 第一个文件夹一定不是其他文件夹的子文件夹</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; folder_size; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isSubFolder</span>(res.<span class="hljs-built_in">back</span>(), folder[i])) &#123;  <span class="hljs-comment">// 不是前面独立文件夹的子文件夹</span><br>        res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(folder[i]));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>官方题解给出了一种字典树的解法<br><img src="https://img-blog.csdnimg.cn/b866bcf09b414b0ab3c09a81d57a5b3b.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="字符串的好分割数目"><a href="#字符串的好分割数目" class="headerlink" title="字符串的好分割数目"></a>字符串的好分割数目</h2><p><strong>题目简要</strong><br>给你一个字符串 s ，一个分割被称为 「好分割」 当它满足：将 s 分割成 2 个字符串 p 和 q ，它们连接起来等于 s 且 p 和 q 中不同字符的数目相同。<br>请你返回 s 中好分割的数目。</p>
<p>看到是求数目，就排除了动态规划（一般是最优解问题），一时间没想到啥好方法，就直接顺序逆序两次遍历，然后利用集合的特性，得到不同字符的数目，最后进行一次比较</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSplits</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(len)</span></span>;<br>    unordered_set&lt;<span class="hljs-type">char</span>&gt; left_set;<br>    unordered_set&lt;<span class="hljs-type">char</span>&gt; right_set;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 不包括当前字符</span><br>      left[i] = left_set.<span class="hljs-built_in">size</span>();<br>      left_set.<span class="hljs-built_in">emplace</span>(s[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-comment">// 包括当前字符</span><br>      right_set.<span class="hljs-built_in">emplace</span>(s[i]);<br>      right[i] = right_set.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (left[i] &gt; right[i]) &#123;<br>        <span class="hljs-keyword">return</span> num;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[i] == right[i]) &#123;<br>        num++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而官方题解则使用递推公式，利用了上一次的信息<br><img src="https://img-blog.csdnimg.cn/00d1f66bc20345138c8de130da13d5bc.png" srcset="/img/loading.gif" lazyload><br>类似的代码如下（没有使用官方题解的bitset）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSplits</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">left_occur</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">right_occur</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    left[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 第一个字符</span><br>    left_occur[s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;  <span class="hljs-comment">// 从第二个字符开始</span><br>      <span class="hljs-keyword">if</span> (left_occur[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">true</span>) &#123;<br>        left[i] = left[i - <span class="hljs-number">1</span>];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        left_occur[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>        left[i] = left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    right[len - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 倒数第一个字符</span><br>    right_occur[s[len - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 从倒数第二个字符开始</span><br>      <span class="hljs-keyword">if</span> (right_occur[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">true</span>) &#123;<br>        right[i] = right[i + <span class="hljs-number">1</span>];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        right_occur[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-literal">true</span>;<br>        right[i] = right[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (left[i] &gt; right[i + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> num;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[i] == right[i + <span class="hljs-number">1</span>]) &#123;<br>        num++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="最接近目标价格的甜点成本"><a href="#最接近目标价格的甜点成本" class="headerlink" title="最接近目标价格的甜点成本"></a>最接近目标价格的甜点成本</h2><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/closest-dessert-cost/">最接近目标价格的甜点成本</a><br><strong>题目简要：</strong> 你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p>
<ol>
<li>必须选择 一种 冰激凌基料。 </li>
<li>可以添加 一种或多种 配料，也可以不添加任何配料。 </li>
<li>每种类型的配料 最多两份 。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">comparePrice</span><span class="hljs-params">(<span class="hljs-type">int</span> cost)</span> </span>&#123;  <span class="hljs-comment">// 比较得到绝对差值最小，同时成本最小的成本</span><br>    <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(cost - target_price);<br>    <span class="hljs-keyword">if</span> (diff &lt; min_target_diff || (diff == min_target_diff &amp;&amp; cost &lt; suit_price)) &#123;<br>      min_target_diff = diff;<br>      suit_price = cost;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findCloseCost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; toppingCosts, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> cur_cost)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur_cost &gt; target_price || start &gt; end) &#123;  <span class="hljs-comment">// 停止遍历条件</span><br>      <span class="hljs-built_in">comparePrice</span>(cur_cost);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (target_price - cur_cost &lt; toppingCosts[start]) &#123;             <span class="hljs-comment">// 未加该配料与加一次配料位于目标价格两端</span><br>      <span class="hljs-built_in">comparePrice</span>(cur_cost);                                        <span class="hljs-comment">// 比较左端价格</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target_price - cur_cost &lt; toppingCosts[start] * <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 加一次配料与加两次配料位于目标价格两端</span><br>      <span class="hljs-built_in">comparePrice</span>(cur_cost + toppingCosts[start]);                  <span class="hljs-comment">// 比较左端价格</span><br>    &#125;<br>    <span class="hljs-built_in">findCloseCost</span>(toppingCosts, start + <span class="hljs-number">1</span>, end, cur_cost);                            <span class="hljs-comment">// 不选择该配料</span><br>    <span class="hljs-built_in">findCloseCost</span>(toppingCosts, start + <span class="hljs-number">1</span>, end, cur_cost + toppingCosts[start]);      <span class="hljs-comment">// 选择一次配料</span><br>    <span class="hljs-built_in">findCloseCost</span>(toppingCosts, start + <span class="hljs-number">1</span>, end, cur_cost + toppingCosts[start] * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 选择两次配料</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closestCost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; baseCosts, vector&lt;<span class="hljs-type">int</span>&gt;&amp; toppingCosts, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    min_target_diff = <span class="hljs-built_in">abs</span>(baseCosts[<span class="hljs-number">0</span>] - target);  <span class="hljs-comment">// 选择第一个基料作为初始值</span><br>    suit_price = baseCosts[<span class="hljs-number">0</span>];<br>    target_price = target;<br>    <span class="hljs-type">int</span> top_size = toppingCosts.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> base : baseCosts) &#123;<br>      <span class="hljs-built_in">findCloseCost</span>(toppingCosts, <span class="hljs-number">0</span>, top_size - <span class="hljs-number">1</span>, base);  <span class="hljs-comment">// 深度搜索，找到最小差值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> suit_price;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> min_target_diff;  <span class="hljs-comment">// 绝对差值</span><br>  <span class="hljs-type">int</span> suit_price;       <span class="hljs-comment">// 最终成本</span><br>  <span class="hljs-type">int</span> target_price;     <span class="hljs-comment">// 目标成本</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ol>
<li>不是所有的深度搜索都需要for循环</li>
<li>考虑边界条件，都大于或都小于</li>
</ol>
<h2 id="字符串中不同整数的数目"><a href="#字符串中不同整数的数目" class="headerlink" title="字符串中不同整数的数目"></a>字符串中不同整数的数目</h2><p>给你一个字符串 word ，该字符串由数字和小写英文字母组成。<br>请你用空格替换每个不是数字的字符。例如，”a123bc34d8ef34” 将会变成 “ 123  34 8  34” 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：”123”、”34”、”8” 和 “34” 。<br>返回对 word 完成替换后形成的 不同 整数的数目。<br>只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDifferentIntegers</span><span class="hljs-params">(string word)</span> </span>&#123;<br>     unordered_set&lt;string&gt; numbers;  <span class="hljs-comment">// 字符串中的数字</span><br>    <span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 0 字母 1 数字</span><br>    <span class="hljs-type">int</span> number_start;<br>    <span class="hljs-type">int</span> number_end;<br>    <span class="hljs-type">char</span> c;<br>    word.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>);  <span class="hljs-comment">// 保证最后一位一定为字符，简化处理流程</span><br>    <span class="hljs-type">int</span> len = word.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      c = word[i];<br>      <span class="hljs-keyword">if</span> (status == <span class="hljs-number">0</span> &amp;&amp; (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)) &#123;  <span class="hljs-comment">// 遇到第一位数字，状态转换</span><br>        status = <span class="hljs-number">1</span>;<br>        number_start = i;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status == <span class="hljs-number">1</span> &amp;&amp; !(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)) &#123;  <span class="hljs-comment">// 遇到字母，计算数字字符串，状态转换</span><br>        number_end = i - <span class="hljs-number">1</span>;<br>        status = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (number_start &lt;= number_end &amp;&amp; word[number_start] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;  <span class="hljs-comment">// 去除前导0</span><br>          number_start++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (number_start &gt; number_end) &#123;  <span class="hljs-comment">// 如果全为0</span><br>          numbers.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 将数字字符串加入结果集合</span><br>          numbers.<span class="hljs-built_in">emplace</span>(word.<span class="hljs-built_in">substr</span>(number_start, number_end - number_start + <span class="hljs-number">1</span>));<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numbers.<span class="hljs-built_in">size</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意整数溢出</p>
<h2 id="通过最少操作次数使数组的和相等"><a href="#通过最少操作次数使数组的和相等" class="headerlink" title="通过最少操作次数使数组的和相等"></a>通过最少操作次数使数组的和相等</h2><p><strong>题目简要</strong><br>给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。<br>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。<br>请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p>
<p>我的解法（不咋行）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kInf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size1 = nums1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> size2 = nums2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> max_size = <span class="hljs-built_in">max</span>(size1, size2);<br>    <span class="hljs-type">int</span> min_size = <span class="hljs-built_in">min</span>(size1, size2);<br>    <span class="hljs-type">int</span> possible_value_start = max_size;<br>    <span class="hljs-type">int</span> possible_value_end = min_size * <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">if</span> (possible_value_start &gt; possible_value_end) &#123;  <span class="hljs-comment">// 两数组取值范围不交叉</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算两数组之和</span><br>    <span class="hljs-type">int</span> sum1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;<br>      sum1 += num;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>      sum2 += num;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum1 == sum2) &#123;  <span class="hljs-comment">// 所有数之和已相等，直接发挥</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 所有数之和可能范围</span><br>    possible_value_start = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(sum1, sum2), possible_value_start);<br>    possible_value_end = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(sum1, sum2), possible_value_end);<br>    <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 到某个数的操作次数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist1</span><span class="hljs-params">(size1 * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist2</span><span class="hljs-params">(size2 * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>)</span></span>;<br>    dist1[sum1] = <span class="hljs-number">0</span>;<br>    dist2[sum2] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> index, next_index;<br>    <span class="hljs-keyword">if</span> (sum1 &lt;= possible_value_start) &#123;  <span class="hljs-comment">// 数组1逐渐增大，数组2逐渐减小</span><br>      index = sum1 + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size1; i++) &#123;  <span class="hljs-comment">// 贪心策略：将第i小的数变成6</span><br>        next_index = index + <span class="hljs-number">6</span> - nums1[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = index; j &lt; next_index; j++) &#123;<br>          dist1[j] = i;<br>        &#125;<br>        index = next_index;<br>        <span class="hljs-keyword">if</span> (index &gt; possible_value_end) &#123;  <span class="hljs-comment">// 提前退出</span><br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      index = sum2 - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size2; i++) &#123;  <span class="hljs-comment">// 贪心策略：将第i大的数变成1</span><br>        next_index = index - nums2[size2 - i] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = index; j &gt; next_index; j--) &#123;<br>          dist2[j] = i;<br>        &#125;<br>        index = next_index;<br>        <span class="hljs-keyword">if</span> (index &lt; possible_value_start) &#123;  <span class="hljs-comment">// 提前退出</span><br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 数组1逐渐减小，数组2逐渐增大</span><br>      index = sum2 + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size2; i++) &#123;<br>        next_index = index + <span class="hljs-number">6</span> - nums2[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = index; j &lt; next_index; j++) &#123;<br>          dist2[j] = i;<br>        &#125;<br>        index = next_index;<br>        <span class="hljs-keyword">if</span> (index &gt; possible_value_end) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      index = sum1 - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size1; i++) &#123;<br>        next_index = index - nums1[size1 - i] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = index; j &gt; next_index; j--) &#123;<br>          dist1[j] = i;<br>        &#125;<br>        index = next_index;<br>        <span class="hljs-keyword">if</span> (index &lt; possible_value_start) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> min_times = size1 + size2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = possible_value_start; i &lt;= possible_value_end; i++) &#123;  <span class="hljs-comment">// 计算操作次数之和最小的所有数之和</span><br>      min_times = <span class="hljs-built_in">min</span>(min_times, dist1[i] + dist2[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> min_times;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/solution/mei-xiang-ming-bai-yi-ge-dong-hua-miao-d-ocuu/">参考解法</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size1 = nums1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> size2 = nums2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> max_size = <span class="hljs-built_in">max</span>(size1, size2);<br>    <span class="hljs-type">int</span> min_size = <span class="hljs-built_in">min</span>(size1, size2);<br>    <span class="hljs-type">int</span> possible_value_start = max_size;<br>    <span class="hljs-type">int</span> possible_value_end = min_size * <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">if</span> (possible_value_start &gt; possible_value_end) &#123;  <span class="hljs-comment">// 两数组取值范围不交叉</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算当前所有数之和</span><br>    <span class="hljs-type">int</span> sum1 = <span class="hljs-built_in">accumulate</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> sum2 = <span class="hljs-built_in">accumulate</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> diff = sum1 - sum2;<br>    <span class="hljs-keyword">if</span> (diff == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 保证数组1之和大于数组2之和</span><br>      <span class="hljs-built_in">swap</span>(nums1, nums2);<br>      diff = -diff;<br>    &#125;<br>    <span class="hljs-comment">// 计算每个数的贡献  cnt[i]表示贡献为i的个数</span><br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;  <span class="hljs-comment">// 将每个数变成1</span><br>      cnt[num - <span class="hljs-number">1</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;  <span class="hljs-comment">// 将每个数变成6</span><br>      cnt[<span class="hljs-number">6</span> - num]++;<br>    &#125;<br>    <span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;    <span class="hljs-comment">// 贪心：从贡献大的数开始变化</span><br>      <span class="hljs-keyword">if</span> (diff - i * cnt[i] &lt;= <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 变化这些数可以使所有数之和相等</span><br>        times += (diff + i - <span class="hljs-number">1</span>) / i;  <span class="hljs-comment">// 向上取整（例：差值为10，需要4个贡献为3的数）</span><br>        <span class="hljs-keyword">return</span> times;<br>      &#125;<br>      <span class="hljs-comment">// 积累这些数的贡献，叠加次数</span><br>      diff -= i * cnt[i];<br>      times += cnt[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>参考解法比我的解法简洁的点在于：<br>1 通过swap保证nums1与nums2的相对关系<br>2 由于可能的贡献只有6个，可直接用数组存各贡献的次数，而不需要排序<br>3 将两个数组的贡献放在一起考虑，而不是独立考虑然后遍历可能范围两数之和</p>
<h2 id="还原排列的最少操作步数"><a href="#还原排列的最少操作步数" class="headerlink" title="还原排列的最少操作步数"></a>还原排列的最少操作步数</h2><p><strong>题目简要</strong><br>给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] &#x3D;&#x3D; i​（下标 从 0 开始 计数）。</p>
<p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：<br>如果 i % 2 &#x3D;&#x3D; 0 ，那么 arr[i] &#x3D; perm[i &#x2F; 2]<br>如果 i % 2 &#x3D;&#x3D; 1 ，那么 arr[i] &#x3D; perm[n &#x2F; 2 + (i - 1) &#x2F; 2]<br>然后将 arr​​ 赋值​​给 perm 。</p>
<p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p>
<p>我开始想找规律，但看了看没找到，就直接模拟了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = vec.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>      <span class="hljs-keyword">if</span> (vec[i] != i) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reinitializePermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      arr[<span class="hljs-number">0</span>][i] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> src = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> des = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>      times++;<br>      <span class="hljs-built_in">swap</span>(src, des);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        arr[des][i] = (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ? arr[src][i / <span class="hljs-number">2</span>] : arr[src][n / <span class="hljs-number">2</span> + (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">check</span>(arr[des]));<br>    <span class="hljs-keyword">return</span> times;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>参考解法</strong><br><img src="https://img-blog.csdnimg.cn/e473b5be7a074df7910914aab4e375e5.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reinitializePermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>      i = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? i / <span class="hljs-number">2</span> : (n + i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>      times++;<br>    &#125; <span class="hljs-keyword">while</span> (i != <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> times;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="句子相似性-III"><a href="#句子相似性-III" class="headerlink" title="句子相似性 III"></a>句子相似性 III</h2><p><strong>题目简要</strong><br>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，”Hello World” ，”HELLO” ，”hello world hello world” 都是句子。每个单词都 只 包含大写和小写英文字母。</p>
<p>如果两个句子 sentence1 和 sentence2 ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，sentence1 &#x3D; “Hello my name is Jane” 且 sentence2 &#x3D; “Hello Jane” ，我们可以往 sentence2 中 “Hello” 和 “Jane” 之间插入 “my name is” 得到 sentence1 。</p>
<p>给你两个句子 sentence1 和 sentence2 ，如果 sentence1 和 sentence2 是相似的，请你返回 true ，否则返回 false 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>    vector&lt;string&gt; res;<br>    s += <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// 在尾部加上空格，统一处理</span><br>    <span class="hljs-type">size_t</span> last_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos != string::npos) &#123;<br>      pos = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>, last_pos);<br>      <span class="hljs-keyword">if</span> (pos != string::npos) &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(s.<span class="hljs-built_in">substr</span>(last_pos, pos - last_pos));  <span class="hljs-comment">// 记录单词</span><br>        last_pos = pos + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">areSentencesSimilar</span><span class="hljs-params">(string sentence1, string sentence2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sentence1.<span class="hljs-built_in">length</span>() &gt; sentence2.<span class="hljs-built_in">length</span>()) &#123;  <span class="hljs-comment">// 保证第一个字符串短于第二个</span><br>      <span class="hljs-built_in">swap</span>(sentence1, sentence2);<br>    &#125;<br>    vector&lt;string&gt; strs1 = <span class="hljs-built_in">split</span>(sentence1);<br>    vector&lt;string&gt; strs2 = <span class="hljs-built_in">split</span>(sentence2);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = strs1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = strs2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; strs1.<span class="hljs-built_in">size</span>() &amp;&amp; strs1[i] == strs2[i]) &#123;<br>      i++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; strs1[j] == strs2[k]) &#123;<br>      j--;<br>      k--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i &gt; j;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用string_view的版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;string_view&gt; <span class="hljs-title">split</span><span class="hljs-params">(string&amp; str)</span> </span>&#123;<br>    vector&lt;string_view&gt; res;<br>    str += <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// 在尾部加上空格，统一处理</span><br>    <span class="hljs-function">string_view <span class="hljs-title">s</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-type">size_t</span> last_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pos != string::npos) &#123;<br>      pos = s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27; &#x27;</span>, last_pos);<br>      <span class="hljs-keyword">if</span> (pos != string::npos) &#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(s.<span class="hljs-built_in">substr</span>(last_pos, pos - last_pos));  <span class="hljs-comment">// 记录单词</span><br>        last_pos = pos + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">areSentencesSimilar</span><span class="hljs-params">(string sentence1, string sentence2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sentence1.<span class="hljs-built_in">length</span>() &gt; sentence2.<span class="hljs-built_in">length</span>()) &#123;  <span class="hljs-comment">// 保证第一个字符串短于第二个</span><br>      <span class="hljs-built_in">swap</span>(sentence1, sentence2);<br>    &#125;<br>    vector&lt;string_view&gt; strs1 = <span class="hljs-built_in">split</span>(sentence1);<br>    vector&lt;string_view&gt; strs2 = <span class="hljs-built_in">split</span>(sentence2);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = strs1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = strs2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; strs1.<span class="hljs-built_in">size</span>() &amp;&amp; strs1[i] == strs2[i]) &#123;<br>      i++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; strs1[j] == strs2[k]) &#123;<br>      j--;<br>      k--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i &gt; j;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>与官方题解相比运行时间有较大差距，主要在于对string_view类型的应用</p>
<blockquote>
<p>std::string_view类的成员变量只包含两个：字符串指针和字符串长度。字符串指针可能是某个连续字符串的其中一段的指针，而字符串长度也不一定是整个字符串长度，也有可能是某个字符串的一部分长度。std::string_view所实现的接口中，完全包含了std::string的所有只读的接口，所以在很多场合可以轻易使用std::string_view代替std::string。一个通常的用法是，生成一个std::string后，如果后续的操作不再对其进行修改，那么可以考虑把std::string转换成为std::string_view，后续操作全部使用std::string_view来进行，这样字符串的传递变得轻量级。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166359481">C++17剖析：string_view的实现，以及性能</a></p>
<h2 id="统计网格图中没有被保卫的格子数"><a href="#统计网格图中没有被保卫的格子数" class="headerlink" title="统计网格图中没有被保卫的格子数"></a>统计网格图中没有被保卫的格子数</h2><p><strong>题目简要</strong><br>给你两个整数 m 和 n 表示一个下标从 0 开始的 m x n 网格图。同时给你两个二维整数数组 guards 和 walls ，其中 guards[i] &#x3D; [rowi, coli] 且 walls[j] &#x3D; [rowj, colj] ，分别表示第 i 个警卫和第 j 座墙所在的位置。<br>一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 所有 格子，除非他们被一座墙或者另外一个警卫 挡住 了视线。如果一个格子能被 至少 一个警卫看到，那么我们说这个格子被 保卫 了。<br>请你返回空格子中，有多少个格子是 没被保卫 的。</p>
<p><strong>暴力枚举</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countUnguarded</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; guards, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; walls)</span> </span>&#123;<br>    <span class="hljs-comment">// 0 未受保护 1 受保护 -1 警卫 -2 墙</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 空白格</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; guard : guards) &#123;<br>      arr[guard[<span class="hljs-number">0</span>]][guard[<span class="hljs-number">1</span>]] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; wall : walls) &#123;<br>      arr[wall[<span class="hljs-number">0</span>]][wall[<span class="hljs-number">1</span>]] = <span class="hljs-number">-2</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> protected_block = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; guard : guards) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> x = guard[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> y = guard[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> next_x = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> next_y = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (next_x &gt;= <span class="hljs-number">0</span> &amp;&amp; next_x &lt; m &amp;&amp; next_y &gt;= <span class="hljs-number">0</span> &amp;&amp; next_y &lt; n &amp;&amp; arr[next_x][next_y] &gt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 坐标合法且未遇到墙/警卫</span><br>          <span class="hljs-keyword">if</span> (arr[next_x][next_y] == <span class="hljs-number">0</span>) &#123;<br>            protected_block++;<br>          &#125;<br>          x = next_x;<br>          y = next_y;<br>          arr[x][y] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 给空白格赋值</span><br>          next_x = x + dir[i][<span class="hljs-number">0</span>];<br>          next_y = y + dir[i][<span class="hljs-number">1</span>];<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> unprotected_num = m * n - guards.<span class="hljs-built_in">size</span>() - walls.<span class="hljs-built_in">size</span>() - protected_block;<br>    <span class="hljs-keyword">return</span> unprotected_num;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>官方题解——广度优先遍历</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countUnguarded</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; guards, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; walls)</span> </span>&#123;<br>    <span class="hljs-comment">// 0 未受保护 -1 警卫 -2 墙  以前四位作为各方向访问记录</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 空白格</span><br>    queue&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; guard : guards) &#123;<br>      arr[guard[<span class="hljs-number">0</span>]][guard[<span class="hljs-number">1</span>]] = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dir = <span class="hljs-number">0</span>; dir &lt; <span class="hljs-number">4</span>; ++dir) &#123;<br>        q.<span class="hljs-built_in">emplace</span>(guard[<span class="hljs-number">0</span>], guard[<span class="hljs-number">1</span>], dir);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; wall : walls) &#123;<br>      arr[wall[<span class="hljs-number">0</span>]][wall[<span class="hljs-number">1</span>]] = <span class="hljs-number">-2</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> directions[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> protected_block = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [x, y, dir] = q.<span class="hljs-built_in">front</span>();<br>      q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-type">int</span> nx = x + directions[dir][<span class="hljs-number">0</span>];<br>      <span class="hljs-type">int</span> ny = y + directions[dir][<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp; arr[nx][ny] &gt;= <span class="hljs-number">0</span> &amp;&amp; (arr[nx][ny] &amp; (<span class="hljs-number">1</span> &lt;&lt; dir)) == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 坐标合法且为未被访问的空白格</span><br>        <span class="hljs-keyword">if</span> (arr[nx][ny] == <span class="hljs-number">0</span>) &#123;                                                                             <span class="hljs-comment">// 第一次访问</span><br>          protected_block++;<br>        &#125;<br>        arr[nx][ny] |= (<span class="hljs-number">1</span> &lt;&lt; dir);<br>        q.<span class="hljs-built_in">emplace</span>(nx, ny, dir);<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> unprotected_num = m * n - guards.<span class="hljs-built_in">size</span>() - walls.<span class="hljs-built_in">size</span>() - protected_block;<br>    <span class="hljs-keyword">return</span> unprotected_num;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>非常漂亮的思路，另外注意&amp;  &#x3D;&#x3D;的运算符优先级</p>
<h2 id="最大二叉树与单调栈"><a href="#最大二叉树与单调栈" class="headerlink" title="最大二叉树与单调栈"></a>最大二叉树与单调栈</h2><p><strong>题目简要</strong><br>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。<br><strong>思路</strong><br>按照题目步骤，实现简单的递归函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 左闭右开区间</span><br>  <span class="hljs-function">TreeNode *<span class="hljs-title">impl</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, vector&lt;<span class="hljs-type">int</span>&gt;::iterator begin, vector&lt;<span class="hljs-type">int</span>&gt;::iterator end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (begin &gt;= end) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator max_pos = <span class="hljs-built_in">max_element</span>(begin, end);<br>    TreeNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(*max_pos);<br>    node-&gt;left = <span class="hljs-built_in">impl</span>(nums, begin, max_pos);  <span class="hljs-comment">// 注意为max_pos而不是max_pos-1</span><br>    node-&gt;right = <span class="hljs-built_in">impl</span>(nums, max_pos + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-keyword">return</span> node;<br>  &#125;<br>  <span class="hljs-function">TreeNode *<span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">impl</span>(nums, nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>看完官方题解，竟然还能用所谓的单调栈求解，阅读一篇相关博客<a target="_blank" rel="noopener" href="https://www.cnblogs.com/RioTian/p/13462825.html">特殊数据结构：单调栈</a><br>简单写完496. 下一个更大元素 I与503. 下一个更大元素 II</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 496</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; next;  <span class="hljs-comment">// 当前值与更大值映射</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>() &lt; nums2[i]) &#123;  <span class="hljs-comment">// 弹出比其小的元素</span><br>        s.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>      <span class="hljs-type">int</span> next_value = s.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : s.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 下一个更大的元素</span><br>      next.<span class="hljs-built_in">insert</span>(&#123;nums2[i], next_value&#125;);<br>      s.<span class="hljs-built_in">emplace</span>(nums2[i]);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums1.size())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      ans[i] = next[nums1[i]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 503</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums.size())</span></span>;<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-comment">// 进行两次遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt;= nums[i]) &#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>      st.<span class="hljs-built_in">emplace</span>(nums[i]);<br>    &#125;<br>    <span class="hljs-comment">// 此时已有从栈顶至栈底递增的数组元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt;= nums[i]) &#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>      ans[i] = st.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : st.<span class="hljs-built_in">top</span>();<br>      st.<span class="hljs-built_in">emplace</span>(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/7895296ba13043dfbc967d30da26657b.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">TreeNode *<span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span>, <span class="hljs-title">right</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;  <span class="hljs-comment">// 左右两侧更大元素索引，初始为-1</span><br>    <span class="hljs-function">vector&lt;TreeNode *&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n)</span></span>;             <span class="hljs-comment">// 指针数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      tree[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[i]);  <span class="hljs-comment">// 创建节点</span><br>      <span class="hljs-comment">// 维持栈顶至栈底递增关系</span><br>      <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 若栈顶元素比当前元素小</span><br>        right[st.<span class="hljs-built_in">top</span>()] = i;                             <span class="hljs-comment">// 栈顶元素的右侧更大元素索引为i</span><br>        st.<span class="hljs-built_in">pop</span>();                                        <span class="hljs-comment">// 弹出栈顶元素</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 若栈非空，则栈顶元素为左侧更大元素索引</span><br>        left[i] = st.<span class="hljs-built_in">top</span>();<br>      &#125;<br>      st.<span class="hljs-built_in">emplace</span>(i);<br>    &#125;<br><br>    TreeNode *root = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// nums[i] 的父结点是两个边界中较小的那个元素对应的节点。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (left[i] == <span class="hljs-number">-1</span> &amp;&amp; right[i] == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 最大元素，即为根节点</span><br>        root = tree[i];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right[i] == <span class="hljs-number">-1</span> || (left[i] != <span class="hljs-number">-1</span> &amp;&amp; nums[left[i]] &lt; nums[right[i]])) &#123;  <span class="hljs-comment">// 左侧的元素较小，那么该元素就是左侧元素的右子节点</span><br>        tree[left[i]]-&gt;right = tree[i];<br>      &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 右侧的元素较小，那么该元素就是右侧元素的左子节点。</span><br>        tree[right[i]]-&gt;left = tree[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h2><p><strong>题目简要</strong><br>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p><strong>思路</strong><br>刚开始想通过数学方法解出来，想了一会没想到，就直接暴力枚举了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-type">int</span> target) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> max_begin = target / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max_begin; i++) &#123;<br>      <span class="hljs-type">int</span> num = i;<br>      <span class="hljs-type">int</span> sum = target;<br>      <span class="hljs-keyword">while</span> (sum &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 依次减去后面的数</span><br>        sum -= num;<br>        num++;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 为该序列之和</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>        arr.<span class="hljs-built_in">reserve</span>(num - i);  <span class="hljs-comment">// 预订空间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; num; j++) &#123;<br>          arr.<span class="hljs-built_in">emplace_back</span>(j);<br>        &#125;<br>        res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(arr));  <span class="hljs-comment">// 加入结果集</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>看到官方题解双指针&#x2F;滑动窗口解题，mark一下<br><img src="https://img-blog.csdnimg.cn/83f8683e97d441708e2db0e52d2f0ccf.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-type">int</span> target) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>; l &lt; r;) &#123;<br>      <span class="hljs-type">int</span> sum = (l + r) * (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (sum == target) &#123;<br>        res.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i) &#123;<br>          res.<span class="hljs-built_in">emplace_back</span>(i);<br>        &#125;<br>        vec.<span class="hljs-built_in">emplace_back</span>(res);<br>        l++;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>        r++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        l++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vec;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="LFU-缓存"><a href="#LFU-缓存" class="headerlink" title="LFU 缓存"></a>LFU 缓存</h2><p><strong>题目简要</strong><br>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p>
<p>实现 LFUCache 类：</p>
<p>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象<br>int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。<br>void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。<br>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p>
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p><strong>思路</strong><br>刚开始我想的是使用LRU实现类似的方式，用一个双向链表存放数据，用一个哈希表记录数据位置，加速查找，但提交后超出时间限制。<br>我的实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataNode</span> &#123;  <span class="hljs-comment">// 数据节点</span><br>  <span class="hljs-type">int</span> key_;<br>  <span class="hljs-type">int</span> value_;<br>  <span class="hljs-type">int</span> count_;<br>  <span class="hljs-built_in">DataNode</span>(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> count) : <span class="hljs-built_in">key_</span>(key), <span class="hljs-built_in">value_</span>(value), <span class="hljs-built_in">count_</span>(count) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">size_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity_</span>(capacity) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> iter = speed_map_.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (iter == speed_map_.<span class="hljs-built_in">end</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    list&lt;DataNode&gt;::iterator pos = iter-&gt;second;<br>    DataNode new_node = *pos;<br>    new_node.count_++;<br>    <span class="hljs-keyword">auto</span> new_pos = data_.<span class="hljs-built_in">erase</span>(pos);  <span class="hljs-comment">// 找到新的插入位置(大于该count或末尾)</span><br>    <span class="hljs-keyword">while</span> (new_pos != data_.<span class="hljs-built_in">end</span>() &amp;&amp; new_pos-&gt;count_ &lt;= new_node.count_) &#123;<br>      ++new_pos;<br>    &#125;<br>    speed_map_[key] = data_.<span class="hljs-built_in">insert</span>(new_pos, new_node);<br>    <span class="hljs-keyword">return</span> new_node.value_;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> iter = speed_map_.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (iter == speed_map_.<span class="hljs-built_in">end</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (size_ == capacity_) &#123;  <span class="hljs-comment">// 淘汰头部的数据节点</span><br>        speed_map_.<span class="hljs-built_in">erase</span>(data_.<span class="hljs-built_in">front</span>().key_);<br>        data_.<span class="hljs-built_in">pop_front</span>();<br>        size_--;<br>      &#125;<br>      <span class="hljs-comment">// 插入新节点</span><br>      <span class="hljs-function">DataNode <span class="hljs-title">node</span><span class="hljs-params">(key, value, <span class="hljs-number">1</span>)</span></span>;<br>      <span class="hljs-keyword">auto</span> pos = data_.<span class="hljs-built_in">begin</span>();<br>      <span class="hljs-keyword">while</span> (pos != data_.<span class="hljs-built_in">end</span>() &amp;&amp; pos-&gt;count_ &lt;= <span class="hljs-number">1</span>) &#123;<br>        ++pos;<br>      &#125;<br>      speed_map_.<span class="hljs-built_in">insert</span>(&#123;key, data_.<span class="hljs-built_in">insert</span>(pos, node)&#125;);<br>      size_++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 更新节点</span><br>      list&lt;DataNode&gt;::iterator pos = iter-&gt;second;<br>      DataNode new_node = *pos;<br>      new_node.value_ = value;<br>      new_node.count_++;<br>      <span class="hljs-keyword">auto</span> new_pos = data_.<span class="hljs-built_in">erase</span>(pos);<br>      <span class="hljs-keyword">while</span> (new_pos != data_.<span class="hljs-built_in">end</span>() &amp;&amp; new_pos-&gt;count_ &lt;= new_node.count_) &#123;<br>        ++new_pos;<br>      &#125;<br>      speed_map_[key] = data_.<span class="hljs-built_in">insert</span>(new_pos, new_node);<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> size_;<br>  <span class="hljs-type">int</span> capacity_;<br>  list&lt;DataNode&gt; data_;                                     <span class="hljs-comment">// 存放数据节点，越靠前越容易被淘汰</span><br>  unordered_map&lt;<span class="hljs-type">int</span>, list&lt;DataNode&gt;::iterator&gt; speed_map_;  <span class="hljs-comment">// 加速查找</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>LFU与LRU不同的是，它并不是每次都会插入至队首或队尾，故更新节点位置时需要进行遍历，为此，就不能用链表作为存放数据的数据结构，而是平衡二叉树（set）<br>官方题解1大致实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataNode</span> &#123;  <span class="hljs-comment">// 数据节点</span><br>  <span class="hljs-type">int</span> key_;<br>  <span class="hljs-type">int</span> value_;<br>  <span class="hljs-type">int</span> count_;        <span class="hljs-comment">// 出现次数</span><br>  <span class="hljs-type">int</span> insert_time_;  <span class="hljs-comment">// 插入时间</span><br>  <span class="hljs-built_in">DataNode</span>(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> count, <span class="hljs-type">int</span> insert_time) : <span class="hljs-built_in">key_</span>(key), <span class="hljs-built_in">value_</span>(value), <span class="hljs-built_in">count_</span>(count), <span class="hljs-built_in">insert_time_</span>(insert_time) &#123;&#125;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> DataNode&amp; node) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> count_ &lt; node.count_ || (count_ == node.count_ &amp;&amp; insert_time_ &lt; node.insert_time_); &#125;  <span class="hljs-comment">// 自定义排序函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">capacity_</span>(capacity), <span class="hljs-built_in">timer_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> iter = position_.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (iter == position_.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// key不存在</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 更新节点信息</span><br>    <span class="hljs-keyword">auto</span> pos = iter-&gt;second;<br>    <span class="hljs-function">DataNode <span class="hljs-title">new_node</span><span class="hljs-params">(key, pos-&gt;value_, pos-&gt;count_ + <span class="hljs-number">1</span>, timer_++)</span></span>;<br>    data_.<span class="hljs-built_in">erase</span>(pos);<br>    position_[key] = data_.<span class="hljs-built_in">emplace</span>(new_node).first;<br>    <span class="hljs-keyword">return</span> new_node.value_;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> iter = position_.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (iter == position_.<span class="hljs-built_in">end</span>()) &#123;      <span class="hljs-comment">// 插入数据</span><br>      <span class="hljs-keyword">if</span> (data_.<span class="hljs-built_in">size</span>() == capacity_) &#123;  <span class="hljs-comment">// 达到容量，淘汰数据</span><br>        <span class="hljs-keyword">auto</span> evict_pos = data_.<span class="hljs-built_in">begin</span>();<br>        position_.<span class="hljs-built_in">erase</span>(evict_pos-&gt;key_);<br>        data_.<span class="hljs-built_in">erase</span>(evict_pos);<br>      &#125;<br>      <span class="hljs-function">DataNode <span class="hljs-title">new_node</span><span class="hljs-params">(key, value, <span class="hljs-number">1</span>, timer_++)</span></span>;<br>      position_.<span class="hljs-built_in">insert</span>(&#123;key, data_.<span class="hljs-built_in">emplace</span>(new_node).first&#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 更新数据</span><br>      <span class="hljs-keyword">auto</span> pos = iter-&gt;second;<br>      <span class="hljs-function">DataNode <span class="hljs-title">new_node</span><span class="hljs-params">(key, value, pos-&gt;count_ + <span class="hljs-number">1</span>, timer_++)</span></span>;<br>      data_.<span class="hljs-built_in">erase</span>(pos);<br>      position_[key] = data_.<span class="hljs-built_in">emplace</span>(new_node).first;<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> capacity_;<br>  <span class="hljs-type">int</span> timer_;                                             <span class="hljs-comment">// 逻辑计数器</span><br>  set&lt;DataNode&gt; data_;                                    <span class="hljs-comment">// 以红黑树存放数据节点</span><br>  unordered_map&lt;<span class="hljs-type">int</span>, set&lt;DataNode&gt;::iterator&gt; position_;  <span class="hljs-comment">// 数据位置</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>DataNode包含key是为了淘汰时删除map中的数据。虽然题解1可以通过测试，但复杂度在对数级。题解2则使用两个哈希表，将复杂度降到了常数级。<br>实际上题解2相当于使用两个哈希表将LFU分成了不同出现次数的LRU。<br><img src="https://img-blog.csdnimg.cn/97efd84354c840c29cdaae264007abd9.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 缓存的节点信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>  <span class="hljs-type">int</span> key, val, freq;<br>  <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val, <span class="hljs-type">int</span> _freq) : <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">freq</span>(_freq) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>  <span class="hljs-type">int</span> minfreq, capacity;<br>  unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Node&gt;::iterator&gt; key_table;<br>  unordered_map&lt;<span class="hljs-type">int</span>, list&lt;Node&gt;&gt; freq_table;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> _capacity) &#123;<br>    minfreq = <span class="hljs-number">0</span>;<br>    capacity = _capacity;<br>    key_table.<span class="hljs-built_in">clear</span>();<br>    freq_table.<span class="hljs-built_in">clear</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">auto</span> it = key_table.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (it == key_table.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    list&lt;Node&gt;::iterator node = it-&gt;second;<br>    <span class="hljs-type">int</span> val = node-&gt;val, freq = node-&gt;freq;<br>    freq_table[freq].<span class="hljs-built_in">erase</span>(node);<br>    <span class="hljs-comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span><br>    <span class="hljs-keyword">if</span> (freq_table[freq].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>      freq_table.<span class="hljs-built_in">erase</span>(freq);<br>      <span class="hljs-keyword">if</span> (minfreq == freq) minfreq += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 插入到 freq + 1 中</span><br>    freq_table[freq + <span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_front</span>(<span class="hljs-built_in">Node</span>(key, val, freq + <span class="hljs-number">1</span>));<br>    key_table[key] = freq_table[freq + <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">return</span> val;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">auto</span> it = key_table.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (it == key_table.<span class="hljs-built_in">end</span>()) &#123;<br>      <span class="hljs-comment">// 缓存已满，需要进行删除操作</span><br>      <span class="hljs-keyword">if</span> (key_table.<span class="hljs-built_in">size</span>() == capacity) &#123;<br>        <span class="hljs-comment">// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点</span><br>        <span class="hljs-keyword">auto</span> it2 = freq_table[minfreq].<span class="hljs-built_in">back</span>();<br>        key_table.<span class="hljs-built_in">erase</span>(it2.key);<br>        freq_table[minfreq].<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">if</span> (freq_table[minfreq].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>          freq_table.<span class="hljs-built_in">erase</span>(minfreq);<br>        &#125;<br>      &#125;<br>      freq_table[<span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_front</span>(<span class="hljs-built_in">Node</span>(key, value, <span class="hljs-number">1</span>));<br>      key_table[key] = freq_table[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>      minfreq = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 与 get 操作基本一致，除了需要更新缓存的值</span><br>      list&lt;Node&gt;::iterator node = it-&gt;second;<br>      <span class="hljs-type">int</span> freq = node-&gt;freq;<br>      freq_table[freq].<span class="hljs-built_in">erase</span>(node);<br>      <span class="hljs-keyword">if</span> (freq_table[freq].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        freq_table.<span class="hljs-built_in">erase</span>(freq);<br>        <span class="hljs-keyword">if</span> (minfreq == freq) minfreq += <span class="hljs-number">1</span>;<br>      &#125;<br>      freq_table[freq + <span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_front</span>(<span class="hljs-built_in">Node</span>(key, value, freq + <span class="hljs-number">1</span>));<br>      key_table[key] = freq_table[freq + <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>    &#125;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h2><p><strong>题目简要</strong><br>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<p>开始想找规律，找到坐标与值的关系，没找到就直接模拟，刚开始用递归实现，先赋值外圈，再赋值内圈，后面直接改成非递归实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 递归实现</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computeNumber</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; vec, <span class="hljs-type">int</span> start_x, <span class="hljs-type">int</span> start_y, <span class="hljs-type">int</span> start_value, <span class="hljs-type">int</span> dim)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dim == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dim == <span class="hljs-number">1</span>) &#123;<br>      vec[start_x][start_y] = start_value;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> i = start_x;<br>    <span class="hljs-type">int</span> j = start_y;<br>    <span class="hljs-type">int</span> x = start_value;<br>    <span class="hljs-type">int</span> times = dim * dim - (dim - <span class="hljs-number">2</span>) * (dim - <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 对外围赋值次数</span><br>    <span class="hljs-type">int</span> cur_dir = <span class="hljs-number">0</span>;<br>    vec[i][j] = x++;<br>    <span class="hljs-keyword">while</span> (times--) &#123;<br>      i += dir[cur_dir][<span class="hljs-number">0</span>];<br>      j += dir[cur_dir][<span class="hljs-number">1</span>];<br>      vec[i][j] = x++;<br>      <span class="hljs-comment">// 遇到边界，转向</span><br>      <span class="hljs-keyword">if</span> (i == start_x &amp;&amp; j == start_y + dim - <span class="hljs-number">1</span>) &#123;<br>        cur_dir = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == start_x + dim - <span class="hljs-number">1</span> &amp;&amp; j == start_y + dim - <span class="hljs-number">1</span>) &#123;<br>        cur_dir = <span class="hljs-number">2</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == start_x + dim - <span class="hljs-number">1</span> &amp;&amp; j == start_y) &#123;<br>        cur_dir = <span class="hljs-number">3</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对内圈赋值</span><br>    <span class="hljs-built_in">computeNumber</span>(vec, start_x + <span class="hljs-number">1</span>, start_y + <span class="hljs-number">1</span>, x, dim - <span class="hljs-number">2</span>);<br>  &#125;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>    <span class="hljs-built_in">computeNumber</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 非递归实现</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vec</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>    <span class="hljs-type">int</span> dim = n;<br>    <span class="hljs-type">int</span> start_x = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> start_y = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> cur_dir = <span class="hljs-number">0</span>;<br>    vec[i][j] = x++;<br>    <span class="hljs-type">int</span> times = dim * dim - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (times--) &#123;<br>      i += dir[cur_dir][<span class="hljs-number">0</span>];<br>      j += dir[cur_dir][<span class="hljs-number">1</span>];<br>      vec[i][j] = x++;<br>      <span class="hljs-keyword">if</span> (i == start_x &amp;&amp; j == start_y + dim - <span class="hljs-number">1</span>) &#123;<br>        cur_dir = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == start_x + dim - <span class="hljs-number">1</span> &amp;&amp; j == start_y + dim - <span class="hljs-number">1</span>) &#123;<br>        cur_dir = <span class="hljs-number">2</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == start_x + dim - <span class="hljs-number">1</span> &amp;&amp; j == start_y) &#123;<br>        cur_dir = <span class="hljs-number">3</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == start_x + <span class="hljs-number">1</span> &amp;&amp; j == start_y) &#123;<br>        <span class="hljs-comment">// 进入内圈，转向</span><br>        cur_dir = <span class="hljs-number">0</span>;<br>        start_x++;<br>        start_y++;<br>        dim -= <span class="hljs-number">2</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vec;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>官方题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> maxNum = n * n;<br>        <span class="hljs-type">int</span> curNum = <span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>, column = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;  <span class="hljs-comment">// 右下左上</span><br>        <span class="hljs-type">int</span> directionIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curNum &lt;= maxNum) &#123;<br>            matrix[row][column] = curNum;<br>            curNum++;<br>            <span class="hljs-type">int</span> nextRow = row + directions[directionIndex][<span class="hljs-number">0</span>], nextColumn = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="hljs-number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="hljs-number">0</span>) &#123;<br>                directionIndex = (directionIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 顺时针旋转至下一个方向</span><br>            &#125;<br>            row = row + directions[directionIndex][<span class="hljs-number">0</span>];<br>            column = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>我的解法远没有官方题解简洁，关键在于官方题解抓住了<strong>若不为 0，则说明已经访问过此位置。</strong> 的性质，减去了四角边界的检查。</p>
<h2 id="最大整除子集"><a href="#最大整除子集" class="headerlink" title="最大整除子集"></a>最大整除子集</h2><p><strong>题目简要：</strong><br>给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：<br>answer[i] % answer[j] &#x3D;&#x3D; 0 ，或<br>answer[j] % answer[i] &#x3D;&#x3D; 0<br>如果存在多个有效解子集，返回其中任何一个均可。</p>
<p>这个题目很容易看出是要使用动态规划解决，状态转移方程也比较容易看出，比较简单</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largestDivisibleSubset</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> nums_size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums_size, <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// 以第i位数结尾的最大整除子集长度</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 对数组进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums_size; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] % nums[j] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 尝试将第i位数字放在第j位数字后</span><br>          dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> max_iter = <span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 找到最大整除子集长度</span><br>    <span class="hljs-keyword">if</span> (*max_iter == <span class="hljs-number">1</span>) &#123;                               <span class="hljs-comment">// 题目未表达清晰此时应返回何值</span><br>      <span class="hljs-keyword">return</span> &#123;nums[<span class="hljs-number">0</span>]&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 倒推得到最大整除子集</span><br>    <span class="hljs-type">int</span> end = max_iter - dp.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-type">int</span> count = *max_iter;         <span class="hljs-comment">// 尚未加入集合数字的数目</span><br>    <span class="hljs-type">int</span> cur_multiple = nums[end];  <span class="hljs-comment">// 下一个加入的数需被该数整除</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = end; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">if</span> (cur_multiple % nums[i] == <span class="hljs-number">0</span> &amp;&amp; dp[i] == count) &#123;  <span class="hljs-comment">// 符合条件，加入集合</span><br>        ans.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>        cur_multiple = nums[i];<br>        count--;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="非重叠矩形中的随机点"><a href="#非重叠矩形中的随机点" class="headerlink" title="非重叠矩形中的随机点"></a>非重叠矩形中的随机点</h2><p><strong>题目简要：</strong><br>给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] &#x3D; [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。</p>
<p>在给定的矩形覆盖的空间内的任何整数点都有可能被返回。</p>
<p>我刚开始就直接用点数组存储所有矩阵中的点，对于每个矩阵都进行两层循环遍历，但提交后显示超时，故计算矩阵总面积，或者说将所有整数点抽象成一条直线，先计算直线的总长度，在直线范围内随机选择一点，而后找到与其相对应的点坐标。虽然我刚开始使用了矩阵面积的前缀和辅助计算，但由于不怎么熟悉c++二分查找的相关函数，没有使用二分查找的方法加速查找。<br><strong>最终代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Solution</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rects) &#123;<br>    <span class="hljs-type">int</span> rect_size = rects.<span class="hljs-built_in">size</span>();<br>    area_cusum = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(rect_size);<br>    <span class="hljs-comment">// 计算面积累加和</span><br>    area_cusum[<span class="hljs-number">0</span>] = (rects[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] - rects[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (rects[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] - rects[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; rect_size; i++) &#123;<br>      <span class="hljs-type">int</span> area = (rects[i][<span class="hljs-number">2</span>] - rects[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (rects[i][<span class="hljs-number">3</span>] - rects[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>      area_cusum[i] = area_cusum[i - <span class="hljs-number">1</span>] + area;<br>    &#125;<br>    area_sum = area_cusum[rect_size - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">this</span>-&gt;rects = <span class="hljs-built_in">move</span>(rects);<br>  &#125;<br><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pick</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">rand</span>() % area_sum;<br>    <span class="hljs-comment">// 找到第一个大于index的矩阵索引</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">upper_bound</span>(area_cusum.<span class="hljs-built_in">begin</span>(), area_cusum.<span class="hljs-built_in">end</span>(), index) - area_cusum.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-type">int</span> rect_index = (i == <span class="hljs-number">0</span>) ? index : index - area_cusum[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> x = rect_index % (rects[i][<span class="hljs-number">2</span>] - rects[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) + rects[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> y = rect_index / (rects[i][<span class="hljs-number">2</span>] - rects[i][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) + rects[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> &#123;x, y&#125;;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; rects;<br>  vector&lt;<span class="hljs-type">int</span>&gt; area_cusum;  <span class="hljs-comment">// 累计和</span><br>  <span class="hljs-type">int</span> area_sum;            <span class="hljs-comment">// 总面积</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011815404/article/details/87019062#:~:text=STL%20%E5%8A%A0%E5%85%A5%20C++%2011%E6%A0%87%E5%87%86%E4%B8%BA%20C++%20%E6%B3%A8%E5%85%A5%E4%BA%86%E6%96%B0%E7%9A%84%E6%B4%BB%E5%8A%9B%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%8F%90%E5%87%BA%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%BA%20C++%20%E7%A8%8B%E5%BA%8F%E5%B8%A6%E6%9D%A5%E4%BA%86%E7%BF%BB%E5%A4%A9%E8%A6%86%E5%9C%B0%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E4%B8%80%E4%BA%9B%E6%B3%9B%E5%8C%96%E7%9A%84,%E7%AE%97%E6%B3%95%20%E5%AE%9E%E7%8E%B0%E8%AE%A9%E7%BC%96%E7%A8%8B%E5%8F%98%E5%BE%97%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E3%80%82%20STL%20%E4%B8%AD%E6%9C%89%E5%85%B3%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20%E7%9A%84%20%E7%AE%97%E6%B3%95%20%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%89%E4%B8%AA%EF%BC%9Alower_bound%E3%80%81upper_bound%E3%80%81binary_search%E3%80%82">C++ 语言基础 —— STL —— 算法 —— 二分查找算法</a><br><img src="https://img-blog.csdnimg.cn/f6b2b75e9c134fb2bd617de5fc850b0d.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="模拟行走机器人"><a href="#模拟行走机器人" class="headerlink" title="模拟行走机器人"></a>模拟行走机器人</h2><p><strong>题目简要：</strong><br>机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：<br>-2 ：向左转 90 度<br>-1 ：向右转 90 度<br>1 &lt;&#x3D; x &lt;&#x3D; 9 ：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点  obstacles[i] &#x3D; (xi, yi) 。<br>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。<br>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 5 ，则返回 25 ）</p>
<p>我的解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; commands, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacles)</span> </span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, set&lt;<span class="hljs-type">int</span>&gt;&gt; obstacle_x;  <span class="hljs-comment">// 存入x坐标相同的y坐标 set有序</span><br>    map&lt;<span class="hljs-type">int</span>, set&lt;<span class="hljs-type">int</span>&gt;&gt; obstacle_y;  <span class="hljs-comment">// 存入y坐标相同的y坐标 set有序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; obstacle : obstacles) &#123;<br>      <span class="hljs-keyword">if</span> (obstacle_x.<span class="hljs-built_in">count</span>(obstacle[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span>) &#123;<br>        obstacle_x[obstacle[<span class="hljs-number">0</span>]] = &#123;obstacle[<span class="hljs-number">1</span>]&#125;;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        obstacle_x[obstacle[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace</span>(obstacle[<span class="hljs-number">1</span>]);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (obstacle_y.<span class="hljs-built_in">count</span>(obstacle[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) &#123;<br>        obstacle_y[obstacle[<span class="hljs-number">1</span>]] = &#123;obstacle[<span class="hljs-number">0</span>]&#125;;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        obstacle_y[obstacle[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace</span>(obstacle[<span class="hljs-number">0</span>]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;  <span class="hljs-comment">// 东 南 西 北</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max_dist = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> next_x;<br>    <span class="hljs-type">int</span> next_y;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cmd : commands) &#123;<br>      <span class="hljs-keyword">switch</span> (cmd) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>          index = (index + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 右转90度</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-2</span>:<br>          index = (index + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 左转90度</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          next_x = x + dir[index][<span class="hljs-number">0</span>] * cmd;<br>          next_y = y + dir[index][<span class="hljs-number">1</span>] * cmd;<br>          <span class="hljs-keyword">switch</span> (index) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <span class="hljs-comment">// 向东 顺序遍历</span><br>              <span class="hljs-keyword">if</span> (obstacle_y.<span class="hljs-built_in">count</span>(y) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = obstacle_y[y].<span class="hljs-built_in">begin</span>(); iter != obstacle_y[y].<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>                  <span class="hljs-keyword">if</span> (*iter &gt; x &amp;&amp; *iter &lt;= next_x) &#123;  <span class="hljs-comment">// 遇到障碍点</span><br>                    next_x = *iter - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                  &#125;<br>                &#125;<br>              &#125;<br>              <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <span class="hljs-comment">// 向南 逆序遍历</span><br>              <span class="hljs-keyword">if</span> (obstacle_x.<span class="hljs-built_in">count</span>(x) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = obstacle_x[x].<span class="hljs-built_in">rbegin</span>(); iter != obstacle_x[x].<span class="hljs-built_in">rend</span>(); ++iter) &#123;<br>                  <span class="hljs-keyword">if</span> (*iter &lt; y &amp;&amp; *iter &gt;= next_y) &#123;  <span class="hljs-comment">// 遇到障碍点</span><br>                    next_y = *iter + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                  &#125;<br>                &#125;<br>              &#125;<br>              <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <span class="hljs-comment">// 向西 逆序遍历</span><br>              <span class="hljs-keyword">if</span> (obstacle_y.<span class="hljs-built_in">count</span>(y) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = obstacle_y[y].<span class="hljs-built_in">rbegin</span>(); iter != obstacle_y[y].<span class="hljs-built_in">rend</span>(); ++iter) &#123;<br>                  <span class="hljs-keyword">if</span> (*iter &lt; x &amp;&amp; *iter &gt;= next_x) &#123;  <span class="hljs-comment">// 遇到障碍点</span><br>                    next_x = *iter + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                  &#125;<br>                &#125;<br>              &#125;<br>              <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:  <span class="hljs-comment">// 向北 顺序遍历</span><br>              <span class="hljs-keyword">if</span> (obstacle_x.<span class="hljs-built_in">count</span>(x) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = obstacle_x[x].<span class="hljs-built_in">begin</span>(); iter != obstacle_x[x].<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>                  <span class="hljs-keyword">if</span> (*iter &gt; y &amp;&amp; *iter &lt;= next_y) &#123;  <span class="hljs-comment">// 遇到障碍点</span><br>                    next_y = *iter - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                  &#125;<br>                &#125;<br>              &#125;<br>              <span class="hljs-keyword">break</span>;<br>              <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>              <span class="hljs-keyword">break</span>;<br>          &#125;<br>          x = next_x;<br>          y = next_y;<br>          max_dist = <span class="hljs-built_in">max</span>(max_dist, x * x + y * y);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_dist;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>官方题解（修改后）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Coord = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CoordHash</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Coord&amp; c)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> fn = <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fn</span>(c.first) ^ <span class="hljs-built_in">fn</span>(c.second);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robotSim</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; commands, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacles)</span> </span>&#123;<br>    unordered_set&lt;Coord, CoordHash&gt; obstacle_set;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; obstacle : obstacles) &#123;  <span class="hljs-comment">// 加入障碍点集合</span><br>      obstacle_set.<span class="hljs-built_in">emplace</span>(Coord&#123;obstacle[<span class="hljs-number">0</span>], obstacle[<span class="hljs-number">1</span>]&#125;);<br>    &#125;<br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;  <span class="hljs-comment">// 东 南 西 北</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max_dist = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> next_x;<br>    <span class="hljs-type">int</span> next_y;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cmd : commands) &#123;<br>      <span class="hljs-keyword">switch</span> (cmd) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>          index = (index + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 右转90度</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-2</span>:<br>          index = (index + <span class="hljs-number">3</span>) % <span class="hljs-number">4</span>;  <span class="hljs-comment">// 左转90度</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          next_x = x + dir[index][<span class="hljs-number">0</span>] * cmd;<br>          next_y = y + dir[index][<span class="hljs-number">1</span>] * cmd;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= cmd; k++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacle_set.<span class="hljs-built_in">count</span>(&#123;x + dir[index][<span class="hljs-number">0</span>] * k, y + dir[index][<span class="hljs-number">1</span>] * k&#125;) != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 遇见障碍，回退到前一个点</span><br>              next_x = x + dir[index][<span class="hljs-number">0</span>] * (k - <span class="hljs-number">1</span>);<br>              next_y = y + dir[index][<span class="hljs-number">1</span>] * (k - <span class="hljs-number">1</span>);<br>              <span class="hljs-keyword">break</span>;<br>            &#125;<br>          &#125;<br>          x = next_x;<br>          y = next_y;<br>          max_dist = <span class="hljs-built_in">max</span>(max_dist, x * x + y * y);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_dist;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>我的解法比官方题解多很多代码的点在于没有很好利用dir[index][0]和dir[index][1]，而是对index进行分类（东南西北），另外想利用机器人走直线的特点，x全部相等或y全部相等，但遍历时不能直接跳转到出发点，仍需从头或从尾开始遍历，效率很低，不如直接一个一个坐标判断是否在障碍点集合中。<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/469655331">在 C++ 中用 lambda 函数自定义 unordered_set 时，为什么赋值运算符失效了？</a></p>
<h2 id="从给定原材料中找到所有可以做出的菜"><a href="#从给定原材料中找到所有可以做出的菜" class="headerlink" title="从给定原材料中找到所有可以做出的菜"></a>从给定原材料中找到所有可以做出的菜</h2><p><strong>题目简要：</strong><br>你有 n 道不同菜的信息。给你一个字符串数组 recipes 和一个二维字符串数组 ingredients 。第 i 道菜的名字为 recipes[i] ，如果你有它 所有 的原材料 ingredients[i] ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜，也就是说 ingredients[i] 可能包含 recipes 中另一个字符串。<br>同时给你一个字符串数组 supplies ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。<br>请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。<br>注意两道菜在它们的原材料中可能互相包含。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findAllRecipes</span><span class="hljs-params">(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies)</span> </span>&#123;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; recipe_map;<br>    unordered_set&lt;string&gt; supply_set;<br>    <span class="hljs-type">int</span> recipe_size = recipes.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adjacency_list</span>(recipe_size);  <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">induity</span><span class="hljs-params">(recipe_size, <span class="hljs-number">0</span>)</span></span>;              <span class="hljs-comment">// 入度矩阵</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(recipe_size, <span class="hljs-number">-1</span>)</span></span>;              <span class="hljs-comment">// -1 初始化 0 不能做 1 能做</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; recipe_size; i++) &#123;<br>      recipe_map[recipes[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (string&amp; supply : supplies) &#123;<br>      supply_set.<span class="hljs-built_in">emplace</span>(supply);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; recipe_size; i++) &#123;<br>      <span class="hljs-type">bool</span> include_all_ingredient = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">for</span> (string&amp; ingredient : ingredients[i]) &#123;<br>        <span class="hljs-keyword">if</span> (supply_set.<span class="hljs-built_in">count</span>(ingredient) == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 不在原材料列表</span><br>          include_all_ingredient = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">auto</span> iter = recipe_map.<span class="hljs-built_in">find</span>(ingredient);<br>          <span class="hljs-keyword">if</span> (iter == recipe_map.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 不在菜单列表，不可能做出该菜</span><br>            induity[i] = <span class="hljs-number">0</span>;                <span class="hljs-comment">// 将入度设为0</span><br>            result[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 配菜添加指向当前菜的边，入度加一</span><br>            adjacency_list[iter-&gt;second].<span class="hljs-built_in">emplace_back</span>(i);<br>            induity[i]++;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (include_all_ingredient) &#123;  <span class="hljs-comment">// 拥有所有原材料，可以做出来</span><br>        result[i] = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; in_queue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; recipe_size; i++) &#123;  <span class="hljs-comment">// 将入度为0的节点压入队列</span><br>      <span class="hljs-keyword">if</span> (induity[i] == <span class="hljs-number">0</span>) &#123;<br>        in_queue.<span class="hljs-built_in">emplace</span>(i);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!in_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-type">int</span> i = in_queue.<span class="hljs-built_in">front</span>();<br>      in_queue.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : adjacency_list[i]) &#123;<br>        induity[j]--;<br>        <span class="hljs-keyword">if</span> (induity[j] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 若入度变为0，加入队列</span><br>          in_queue.<span class="hljs-built_in">emplace</span>(j);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (result[i] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果配菜不能做出来，这菜也不可能做出来</span><br>          result[j] = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result[j] != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果配菜可以做出来</span><br>          result[j] = <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; recipe_size; i++) &#123;<br>      <span class="hljs-keyword">if</span> (result[i] == <span class="hljs-number">1</span> &amp;&amp; induity[i] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 判断入度为0用来解决环问题</span><br>        ans.<span class="hljs-built_in">emplace_back</span>(recipes[i]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>最后再次判断入度以解决环问题<br><strong>官方题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findAllRecipes</span><span class="hljs-params">(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = recipes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 图</span><br>        unordered_map&lt;string, vector&lt;string&gt;&gt; depend;<br>        <span class="hljs-comment">// 入度统计</span><br>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; ing: ingredients[i]) &#123;<br>                depend[ing].<span class="hljs-built_in">push_back</span>(recipes[i]);<br>            &#125;<br>            cnt[recipes[i]] = ingredients[i].<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <br>        vector&lt;string&gt; ans;<br>        queue&lt;string&gt; q;<br>        <span class="hljs-comment">// 把初始的原材料放入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; sup: supplies) &#123;<br>            q.<span class="hljs-built_in">push</span>(sup);<br>        &#125;<br>        <span class="hljs-comment">// 拓扑排序</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            string cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (depend.<span class="hljs-built_in">count</span>(cur)) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; rec: depend[cur]) &#123;<br>                    --cnt[rec];<br>                    <span class="hljs-comment">// 如果入度变为 0，说明可以做出这道菜</span><br>                    <span class="hljs-keyword">if</span> (cnt[rec] == <span class="hljs-number">0</span>) &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(rec);<br>                        q.<span class="hljs-built_in">push</span>(rec);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>评论：</strong><br>学习了，用菜做菜肴，不要用菜肴找菜。</p>
<ul>
<li>有鸡蛋，可以用来做煎蛋，煮蛋，鸡蛋羹，鸡蛋布丁 </li>
<li>有煎蛋，可以拿来做三明治，汉堡，夹心煎饼</li>
</ul>
<p>但是用菜肴找菜，就会存在套娃问题。</p>
<ul>
<li>我想要鸡蛋，需要先获得母鸡 </li>
<li>想要母鸡，需要先获得鸡蛋</li>
</ul>
<h2 id="翻转卡片游戏"><a href="#翻转卡片游戏" class="headerlink" title="翻转卡片游戏"></a>翻转卡片游戏</h2><p><strong>题目简要：</strong><br>在桌子上有 N 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。<br>我们可以先翻转任意张卡片，然后选择其中一张卡片。<br>如果选中的那张卡片背面的数字 X 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。<br>哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。<br>其中, fronts[i] 和 backs[i] 分别代表第 i 张卡片的正面和背面的数字。<br>如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">flipgame</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fronts, vector&lt;<span class="hljs-type">int</span>&gt;&amp; backs)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = fronts.<span class="hljs-built_in">size</span>();<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; number_map;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (fronts[i] == backs[i]) &#123;  <span class="hljs-comment">// 相同的正反牌</span><br>        number_map[fronts[i]] = n + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        number_map[fronts[i]]++;<br>        number_map[backs[i]]++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; kv : number_map) &#123;  <span class="hljs-comment">// map为红黑树实现，元素有序</span><br>      <span class="hljs-keyword">if</span> (kv.second &lt;= n) &#123;        <span class="hljs-comment">// 该数不存在相同的正反牌</span><br>        <span class="hljs-keyword">return</span> kv.first;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 未找到符合要求的数字</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>多使用哈希表与集合，把它们当做树 图一样的解题数据结构</p>
<h2 id="元音拼写检查器"><a href="#元音拼写检查器" class="headerlink" title="元音拼写检查器"></a>元音拼写检查器</h2><p><strong>题目简要</strong><br>在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。<br>对于给定的查询单词 query，拼写检查器将会处理两类拼写错误：<br>大小写：如果查询匹配单词列表中的某个单词（不区分大小写），则返回的正确单词与单词列表中的大小写相同。<br>例如：wordlist &#x3D; [“yellow”], query &#x3D; “YellOw”: correct &#x3D; “yellow”<br>例如：wordlist &#x3D; [“Yellow”], query &#x3D; “yellow”: correct &#x3D; “Yellow”<br>例如：wordlist &#x3D; [“yellow”], query &#x3D; “yellow”: correct &#x3D; “yellow”<br>元音错误：如果在将查询单词中的元音 (‘a’, ‘e’, ‘i’, ‘o’, ‘u’)  分别替换为任何元音后，能与单词列表中的单词匹配（不区分大小写），则返回的正确单词与单词列表中的匹配项大小写相同。<br>例如：wordlist &#x3D; [“YellOw”], query &#x3D; “yollow”: correct &#x3D; “YellOw”<br>例如：wordlist &#x3D; [“YellOw”], query &#x3D; “yeellow”: correct &#x3D; “” （无匹配项）<br>例如：wordlist &#x3D; [“YellOw”], query &#x3D; “yllw”: correct &#x3D; “” （无匹配项）<br>此外，拼写检查器还按照以下优先级规则操作：</p>
<p>当查询完全匹配单词列表中的某个单词（区分大小写）时，应返回相同的单词。<br>当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。<br>当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。<br>如果该查询在单词列表中没有匹配项，则应返回空字符串。<br>给出一些查询 queries，返回一个单词列表 answer，其中 answer[i] 是由查询 query &#x3D; queries[i] 得到的正确单词。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">modifyError</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; origin, <span class="hljs-type">bool</span> vowel_option)</span> </span>&#123;  <span class="hljs-comment">// 修改错误，附带元音纠错选项</span><br>    <span class="hljs-type">int</span> len = origin.<span class="hljs-built_in">length</span>();<br>    string feature;<br>    feature.<span class="hljs-built_in">resize</span>(len);<br>    <span class="hljs-type">const</span> string vowel = <span class="hljs-string">&quot;aeiouAEIOU&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (vowel_option &amp;&amp; vowel.<span class="hljs-built_in">find</span>(origin[i]) != string::npos) &#123;  <span class="hljs-comment">// 元音全部用&#x27;a&#x27;代表</span><br>        feature[i] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (origin[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;  <span class="hljs-comment">// 字母全部变成小写便于比较</span><br>        feature[i] = origin[i] + (<span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        feature[i] = origin[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> feature;<br>  &#125;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">spellchecker</span><span class="hljs-params">(vector&lt;string&gt;&amp; wordlist, vector&lt;string&gt;&amp; queries)</span> </span>&#123;<br>    <span class="hljs-type">int</span> word_size = wordlist.<span class="hljs-built_in">size</span>();<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; right_map;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; case_error_map;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; vowel_error_map;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = word_size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 逆序添加，保证相同的key最后的i最小</span><br>      right_map[wordlist[i]] = i;<br>      case_error_map[<span class="hljs-built_in">modifyError</span>(wordlist[i], <span class="hljs-literal">false</span>)] = i;<br>      vowel_error_map[<span class="hljs-built_in">modifyError</span>(wordlist[i], <span class="hljs-literal">true</span>)] = i;<br>    &#125;<br>    vector&lt;string&gt; result;<br>    <span class="hljs-keyword">for</span> (string&amp; query : queries) &#123;<br>      <span class="hljs-keyword">auto</span> iter = right_map.<span class="hljs-built_in">find</span>(query);  <span class="hljs-comment">// 寻找完全匹配的单词</span><br>      <span class="hljs-keyword">if</span> (iter != right_map.<span class="hljs-built_in">end</span>()) &#123;<br>        result.<span class="hljs-built_in">emplace_back</span>(wordlist[iter-&gt;second]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      iter = case_error_map.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">modifyError</span>(query, <span class="hljs-literal">false</span>));  <span class="hljs-comment">// 选择大小写错误的单词</span><br>      <span class="hljs-keyword">if</span> (iter != case_error_map.<span class="hljs-built_in">end</span>()) &#123;<br>        result.<span class="hljs-built_in">emplace_back</span>(wordlist[iter-&gt;second]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      iter = vowel_error_map.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">modifyError</span>(query, <span class="hljs-literal">true</span>));  <span class="hljs-comment">// 寻找元音错误的单词</span><br>      <span class="hljs-keyword">if</span> (iter != case_error_map.<span class="hljs-built_in">end</span>()) &#123;<br>        result.<span class="hljs-built_in">emplace_back</span>(wordlist[iter-&gt;second]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      result.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// 未找到，加入空字符串</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用map&#x2F;set加速查找，用空间换时间<br><strong>未使用map直接查找的版本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">modifyError</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; origin, <span class="hljs-type">bool</span> vowel_option)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = origin.<span class="hljs-built_in">length</span>();<br>    string feature;<br>    feature.<span class="hljs-built_in">resize</span>(len);<br>    <span class="hljs-type">const</span> string vowel = <span class="hljs-string">&quot;aeiouAEIOU&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (vowel_option &amp;&amp; vowel.<span class="hljs-built_in">find</span>(origin[i]) != string::npos) &#123;<br>        feature[i] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (origin[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>        feature[i] = origin[i] + (<span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        feature[i] = origin[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> feature;<br>  &#125;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">spellchecker</span><span class="hljs-params">(vector&lt;string&gt;&amp; wordlist, vector&lt;string&gt;&amp; queries)</span> </span>&#123;<br>    <span class="hljs-type">int</span> word_size = wordlist.<span class="hljs-built_in">size</span>();<br>    vector&lt;string&gt; case_error;<br>    vector&lt;string&gt; vowel_error;<br>    <span class="hljs-keyword">for</span> (string&amp; word : wordlist) &#123;<br>      case_error.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">modifyError</span>(word, <span class="hljs-literal">false</span>));<br>      vowel_error.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">modifyError</span>(word, <span class="hljs-literal">true</span>));<br>    &#125;<br>    vector&lt;string&gt; result;<br>    <span class="hljs-keyword">for</span> (string&amp; query : queries) &#123;<br>      <span class="hljs-type">bool</span> find = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word_size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (wordlist[i] == query) &#123;<br>          result.<span class="hljs-built_in">emplace_back</span>(wordlist[i]);<br>          find = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (find == <span class="hljs-literal">false</span>) &#123;<br>        string case_query = <span class="hljs-built_in">modifyError</span>(query, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word_size; i++) &#123;<br>          <span class="hljs-keyword">if</span> (case_error[i] == case_query) &#123;<br>            result.<span class="hljs-built_in">emplace_back</span>(wordlist[i]);<br>            find = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (find == <span class="hljs-literal">false</span>) &#123;<br>        string vowel_query = <span class="hljs-built_in">modifyError</span>(query, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word_size; i++) &#123;<br>          <span class="hljs-keyword">if</span> (vowel_error[i] == vowel_query) &#123;<br>            result.<span class="hljs-built_in">emplace_back</span>(wordlist[i]);<br>            find = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (find == <span class="hljs-literal">false</span>) &#123;<br>        result.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="信物传送"><a href="#信物传送" class="headerlink" title="信物传送"></a>信物传送</h2><p><strong>题目简要：</strong><br>本次试炼场地设有若干传送带，matrix[i][j] 表示第 i 行 j 列的传送带运作方向，”^”,”v”,”&lt;”,”&gt;” 这四种符号分别表示 上、下、左、右 四个方向。信物会随传送带的方向移动。勇者每一次施法操作，可临时变更一处传送带的方向，在物品经过后传送带恢复原方向。<br><strong>结构体</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kInf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>  <span class="hljs-built_in">Node</span>() &#123;&#125;<br>  <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> value) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;x = x;<br>    <span class="hljs-keyword">this</span>-&gt;y = y;<br>    <span class="hljs-keyword">this</span>-&gt;value = value;<br>  &#125;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Node&amp; node) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;value &gt; node.value; &#125;  <span class="hljs-comment">// 距离越小优先级越高</span><br>  <span class="hljs-type">int</span> x;<br>  <span class="hljs-type">int</span> y;<br>  <span class="hljs-type">int</span> value;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">conveyorBelt</span><span class="hljs-params">(vector&lt;string&gt;&amp; matrix, vector&lt;<span class="hljs-type">int</span>&gt;&amp; start, vector&lt;<span class="hljs-type">int</span>&gt;&amp; end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col, kInf));<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">marked</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>    priority_queue&lt;Node&gt; small_heap;<br>    <span class="hljs-comment">// 注意坐标轴与箭头方向，坑！</span><br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; symbol = &#123;&#123;<span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>&#125;&#125;;  <span class="hljs-comment">// 箭头符号与dir数组索引</span><br>    dist[start[<span class="hljs-number">0</span>]][start[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;<br>    small_heap.<span class="hljs-built_in">emplace</span>(Node&#123;start[<span class="hljs-number">0</span>], start[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>&#125;);  <span class="hljs-comment">// 压入起始节点</span><br>    <span class="hljs-keyword">while</span> (!small_heap.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> node = small_heap.<span class="hljs-built_in">top</span>();<br>      small_heap.<span class="hljs-built_in">pop</span>();<br>      marked[node.x][node.y] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 加入结果集合</span><br>      <span class="hljs-keyword">if</span> (node.x == end[<span class="hljs-number">0</span>] &amp;&amp; node.y == end[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> node.value;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;  <span class="hljs-comment">// 遍历四个方向</span><br>        <span class="hljs-type">int</span> next_x = node.x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> next_y = node.y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(next_x, next_y, row, col) &amp;&amp; !marked[next_x][next_y]) &#123;  <span class="hljs-comment">// 如果节点合法且未加入结果集合</span><br>          <span class="hljs-keyword">if</span> (i == symbol[matrix[node.x][node.y]]) &#123;                       <span class="hljs-comment">// 箭头指向的方向，两点距离为0</span><br>            dist[next_x][next_y] = <span class="hljs-built_in">min</span>(dist[next_x][next_y], node.value);<br>          &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 其他情况距离为1</span><br>            dist[next_x][next_y] = <span class="hljs-built_in">min</span>(dist[next_x][next_y], node.value + <span class="hljs-number">1</span>);<br>          &#125;<br>          small_heap.<span class="hljs-built_in">emplace</span>(Node&#123;next_x, next_y, dist[next_x][next_y]&#125;);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>lambda表达式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kInf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-keyword">using</span> Node = tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">conveyorBelt</span><span class="hljs-params">(vector&lt;string&gt;&amp; matrix, vector&lt;<span class="hljs-type">int</span>&gt;&amp; start, vector&lt;<span class="hljs-type">int</span>&gt;&amp; end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col, kInf));<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">marked</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">auto</span> compare = [](<span class="hljs-type">const</span> Node&amp; node1, <span class="hljs-type">const</span> Node&amp; node2) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(node1) &gt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(node2); &#125;;  <span class="hljs-comment">// 自定义比较函数</span><br>    priority_queue&lt;Node, vector&lt;Node&gt;, <span class="hljs-keyword">decltype</span>(compare)&gt; <span class="hljs-built_in">small_heap</span>(compare);<br>    <span class="hljs-comment">// 注意坐标轴与箭头方向，坑！</span><br>    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; symbol = &#123;&#123;<span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>&#125;&#125;;  <span class="hljs-comment">// 箭头符号与dir数组索引</span><br>    dist[start[<span class="hljs-number">0</span>]][start[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;<br>    small_heap.<span class="hljs-built_in">emplace</span>(Node&#123;<span class="hljs-number">0</span>, start[<span class="hljs-number">0</span>], start[<span class="hljs-number">1</span>]&#125;);  <span class="hljs-comment">// 压入起始节点</span><br>    <span class="hljs-keyword">while</span> (!small_heap.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [val, x, y] = small_heap.<span class="hljs-built_in">top</span>();<br>      small_heap.<span class="hljs-built_in">pop</span>();<br>      marked[x][y] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 加入结果集合</span><br>      <span class="hljs-keyword">if</span> (x == end[<span class="hljs-number">0</span>] &amp;&amp; y == end[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> val;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;  <span class="hljs-comment">// 遍历四个方向</span><br>        <span class="hljs-type">int</span> next_x = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> next_y = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(next_x, next_y, row, col) &amp;&amp; !marked[next_x][next_y]) &#123;  <span class="hljs-comment">// 如果节点合法且未加入结果集合</span><br>          <span class="hljs-keyword">if</span> (i == symbol[matrix[x][y]]) &#123;                                 <span class="hljs-comment">// 箭头指向的方向，两点距离为0</span><br>            dist[next_x][next_y] = <span class="hljs-built_in">min</span>(dist[next_x][next_y], val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 其他情况距离为1</span><br>            dist[next_x][next_y] = <span class="hljs-built_in">min</span>(dist[next_x][next_y], val + <span class="hljs-number">1</span>);<br>          &#125;<br>          small_heap.<span class="hljs-built_in">emplace</span>(Node&#123;dist[next_x][next_y], next_x, next_y&#125;);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用方向数组简化处理流程<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21539375/article/details/122128445">c++优先队列priority_queue（自定义比较函数）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/vict_wang/article/details/81590984">C++函数指针、函数对象与C++11 function对象对比分析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014609638/article/details/106987131/">【C++深陷】之“decltype”</a></p>
<h2 id="引爆最多的炸弹"><a href="#引爆最多的炸弹" class="headerlink" title="引爆最多的炸弹"></a>引爆最多的炸弹</h2><p><strong>题目简要</strong>:给你一个炸弹列表。一个炸弹的 爆炸范围 定义为以炸弹为圆心的一个圆。<br>炸弹用一个下标从 0 开始的二维整数数组 bombs 表示，其中 bombs[i] &#x3D; [xi, yi, ri] 。xi 和 yi 表示第 i 个炸弹的 X 和 Y 坐标，ri 表示爆炸范围的 半径 。<br>你需要选择引爆 一个 炸弹。当这个炸弹被引爆时，所有 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。<br>给你数组 bombs ，请你返回在引爆 一个 炸弹的前提下，最多 能引爆的炸弹数目。</p>
<p><strong>邻接矩阵实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inRadius</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; start, vector&lt;<span class="hljs-type">int</span>&gt; end)</span> </span>&#123;  <span class="hljs-comment">// 判断两点是否在起点圆内</span><br>    ll dist = (ll)(start[<span class="hljs-number">0</span>] - end[<span class="hljs-number">0</span>]) * (start[<span class="hljs-number">0</span>] - end[<span class="hljs-number">0</span>]) + (ll)(start[<span class="hljs-number">1</span>] - end[<span class="hljs-number">1</span>]) * (start[<span class="hljs-number">1</span>] - end[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> (ll)(start[<span class="hljs-number">2</span>]) * start[<span class="hljs-number">2</span>] &gt;= dist;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumDetonation</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bombs)</span> </span>&#123;<br>    <span class="hljs-type">int</span> bomb_number = bombs.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">connected</span>(bomb_number, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(bomb_number));  <span class="hljs-comment">// 各节点是否连通</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bomb_number; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; bomb_number; j++) &#123;<br>        <span class="hljs-keyword">if</span> (i != j) &#123;  <span class="hljs-comment">// 自己与自己相连</span><br>          connected[i][j] = <span class="hljs-built_in">inRadius</span>(bombs[i], bombs[j]);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> visit_node;<br>    <span class="hljs-type">int</span> visit_node_num;<br>    <span class="hljs-type">int</span> max_visit_node_num = <span class="hljs-number">1</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; visit_queue;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">marked</span><span class="hljs-params">(bomb_number, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 节点是否被访问过</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">trace</span><span class="hljs-params">(bomb_number, <span class="hljs-number">-1</span>)</span></span>;       <span class="hljs-comment">// 是否在一次遍历中被访问过，用于解决环的问题</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bomb_number; i++) &#123;<br>      <span class="hljs-keyword">if</span> (marked[i] == <span class="hljs-literal">false</span>) &#123;<br>        trace[i] = i;  <span class="hljs-comment">// 用起始节点号标识本次遍历</span><br>        visit_node_num = <span class="hljs-number">0</span>;<br>        visit_queue.<span class="hljs-built_in">emplace</span>(i);  <span class="hljs-comment">// 压入节点，开始一轮遍历</span><br><br>        <span class="hljs-keyword">while</span> (!visit_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>          visit_node = visit_queue.<span class="hljs-built_in">front</span>();<br>          visit_queue.<span class="hljs-built_in">pop</span>();<br><br>          marked[visit_node] = <span class="hljs-literal">true</span>;<br>          visit_node_num++;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; bomb_number; j++) &#123;<br>            <span class="hljs-keyword">if</span> (trace[j] != i &amp;&amp; connected[visit_node][j] == <span class="hljs-literal">true</span>) &#123;<br>              visit_queue.<span class="hljs-built_in">emplace</span>(j);<br>              trace[j] = i;  <span class="hljs-comment">// 在本次遍历中被访问</span><br>            &#125;<br>          &#125;<br>        &#125;<br>        max_visit_node_num = <span class="hljs-built_in">max</span>(max_visit_node_num, visit_node_num);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_visit_node_num;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>邻接表</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inRadius</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; start, vector&lt;<span class="hljs-type">int</span>&gt; end)</span> </span>&#123;  <span class="hljs-comment">// 判断两点是否在起点圆内</span><br>    ll dist = (ll)(start[<span class="hljs-number">0</span>] - end[<span class="hljs-number">0</span>]) * (start[<span class="hljs-number">0</span>] - end[<span class="hljs-number">0</span>]) + (ll)(start[<span class="hljs-number">1</span>] - end[<span class="hljs-number">1</span>]) * (start[<span class="hljs-number">1</span>] - end[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> (ll)(start[<span class="hljs-number">2</span>]) * start[<span class="hljs-number">2</span>] &gt;= dist;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumDetonation</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bombs)</span> </span>&#123;<br>    <span class="hljs-type">int</span> bomb_number = bombs.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">connected</span>(bomb_number);  <span class="hljs-comment">// 各节点是否连通</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bomb_number; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; bomb_number; j++) &#123;<br>        <span class="hljs-keyword">if</span> (i != j &amp;&amp; <span class="hljs-built_in">inRadius</span>(bombs[i], bombs[j])) &#123;<br>          connected[i].<span class="hljs-built_in">emplace_back</span>(j);<br>        &#125;<br>      &#125;<br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; visit_queue;<br>    <span class="hljs-type">int</span> visit_node;<br>    <span class="hljs-type">int</span> visit_node_num;<br>    <span class="hljs-type">int</span> max_visit_node_num = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">marked</span><span class="hljs-params">(bomb_number, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 节点是否被访问过</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">trace</span><span class="hljs-params">(bomb_number, <span class="hljs-number">-1</span>)</span></span>;       <span class="hljs-comment">// 是否在一次遍历中被访问过，用于解决环的问题</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bomb_number; i++) &#123;<br>      <span class="hljs-keyword">if</span> (marked[i] == <span class="hljs-literal">false</span>) &#123;<br>        trace[i] = i;  <span class="hljs-comment">// 用起始节点号标识本次遍历</span><br>        visit_node_num = <span class="hljs-number">0</span>;<br>        visit_queue.<span class="hljs-built_in">emplace</span>(i);  <span class="hljs-comment">// 压入该节点，开始遍历</span><br>        <span class="hljs-keyword">while</span> (!visit_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>          visit_node = visit_queue.<span class="hljs-built_in">front</span>();<br>          visit_queue.<span class="hljs-built_in">pop</span>();<br><br>          marked[visit_node] = <span class="hljs-literal">true</span>;<br>          visit_node_num++;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : connected[visit_node]) &#123;<br>            <span class="hljs-keyword">if</span> (trace[j] != i) &#123;<br>              visit_queue.<span class="hljs-built_in">emplace</span>(j);<br>              trace[j] = i;<br>            &#125;<br>          &#125;<br>        &#125;<br>        max_visit_node_num = <span class="hljs-built_in">max</span>(max_visit_node_num, visit_node_num);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_visit_node_num;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用trace避免环问题，使用marked去除没必要的节点遍历</p>
<h2 id="从二叉树一个节点到另一个节点每一步的方向"><a href="#从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="从二叉树一个节点到另一个节点每一步的方向"></a>从二叉树一个节点到另一个节点每一步的方向</h2><p><strong>题目简要：</strong><br>给你一棵 二叉树 的根节点 root ，这棵二叉树总共有 n 个节点。每个节点的值为 1 到 n 中的一个整数，且互不相同。给你一个整数 startValue ，表示起点节点 s 的值，和另一个不同的整数 destValue ，表示终点节点 t 的值。<br>请找到从节点 s 到节点 t 的 最短路径 ，并以字符串的形式返回每一步的方向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findValue</span><span class="hljs-params">(TreeNode *node, <span class="hljs-type">int</span> target_value, vector&lt;<span class="hljs-type">int</span>&gt; &amp;trace)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;val == target_value) &#123;  <span class="hljs-comment">// 找到目标值</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">findValue</span>(node-&gt;left, target_value, trace)) &#123;  <span class="hljs-comment">// 左子树找到目标，将-1（左）加入轨迹</span><br>        trace.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">findValue</span>(node-&gt;right, target_value, trace)) &#123;  <span class="hljs-comment">// 右子树找到目标，将1（右）加入轨迹</span><br>        trace.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-function">string <span class="hljs-title">getDirections</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> startValue, <span class="hljs-type">int</span> destValue)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; trace1, trace2;<br>    <span class="hljs-built_in">findValue</span>(root, startValue, trace1);  <span class="hljs-comment">// 获取根节点到起始节点的逆序轨迹</span><br>    <span class="hljs-built_in">findValue</span>(root, destValue, trace2);   <span class="hljs-comment">// 获取根节点到终止节点的逆序轨迹</span><br>    <span class="hljs-type">int</span> i = trace1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j = trace2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; trace1[i] == trace2[j]) &#123;  <span class="hljs-comment">// 去掉末尾共同的轨迹，找到共同的父节点</span><br>      i--;<br>      j--;<br>    &#125;<br>    string ans = <span class="hljs-built_in">string</span>(i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;U&#x27;</span>);  <span class="hljs-comment">// 起始节点需一直前往父节点，直到共同的父节点</span><br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;                  <span class="hljs-comment">// 从共同父节点到终止节点的轨迹</span><br>      <span class="hljs-keyword">if</span> (trace2[j] == <span class="hljs-number">1</span>) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;R&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;L&#x27;</span>);<br>      &#125;<br>      j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>回溯法得到逆序轨迹<br>递归第一要义：相信自己已经写出了递归函数，然后进行调用。</p>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>使用备忘录的递归方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kNotInitialized = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    memo = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len, kNotInitialized));  <span class="hljs-comment">// 初始化备忘录</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = len; j &gt;= <span class="hljs-number">1</span>; j--) &#123;                                     <span class="hljs-comment">// 回文串长度为主序</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - j + <span class="hljs-number">1</span>; i++) &#123;                            <span class="hljs-comment">// 改变起始索引</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, i, i + j - <span class="hljs-number">1</span>)) &#123;<br>          <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(i, j);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (memo[i][j] != kNotInitialized) &#123;  <span class="hljs-comment">// 如果存在记录，直接返回</span><br>      <span class="hljs-keyword">return</span> memo[i][j] == <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &gt;= j) &#123;  <span class="hljs-comment">// 奇数回文字符串i j相等终止，偶数回文字符串交错时相等</span><br>      memo[i][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>      memo[i][j] = <span class="hljs-built_in">isPalindrome</span>(s, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <span class="hljs-comment">// 两边字符相等，判断内侧字符串是否为回文字符串</span><br>      <span class="hljs-keyword">return</span> memo[i][j] == <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      memo[i][j] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; memo;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>动态规划</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len));  <span class="hljs-comment">// 初始化DPtable</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;             <span class="hljs-comment">// 一个字符一定为回文字符串</span><br>      dp[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> longest_palindrome_length = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> longest_palindrome_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> palindrome_length = <span class="hljs-number">2</span>; palindrome_length &lt;= len; palindrome_length++) &#123;  <span class="hljs-comment">// 回文字符串长度从小到大</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; len - palindrome_length + <span class="hljs-number">1</span>; start++) &#123;             <span class="hljs-comment">// 改变起始位置</span><br>        end = start + palindrome_length - <span class="hljs-number">1</span>;                                          <span class="hljs-comment">// 字符串末尾位置</span><br>        <span class="hljs-keyword">if</span> (s[start] == s[end]) &#123;<br>          <span class="hljs-keyword">if</span> (end - start &lt; <span class="hljs-number">3</span>) &#123;  <span class="hljs-comment">// 中间隔一个字符或相邻</span><br>            dp[start][end] = <span class="hljs-number">1</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[start][end] = dp[start + <span class="hljs-number">1</span>][end - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 取决于内侧字符串是否为回文字符串</span><br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          dp[start][end] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[start][end] == <span class="hljs-number">1</span> &amp;&amp; palindrome_length &gt; longest_palindrome_length) &#123;  <span class="hljs-comment">// 更新最大回文字符串长度与起始位置</span><br>          longest_palindrome_length = palindrome_length;<br>          longest_palindrome_start = start;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(longest_palindrome_start, longest_palindrome_length);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p> 1.递归方法自顶向下，动态规划自底向上<br> 2.递归方法时回文串长度从大到小，保证第一时间找到最大回文字符串<br> 3.动态规划方法时回文串长度从小到大，保证内侧字符串结果已产生(dp[i+1][j-1]）</p>
<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a><br><strong>题目简要</strong>：给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            ans ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>异或运算性质</p>
<p><strong>其他数字出现三次</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bit_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;  <span class="hljs-comment">// 0-31位</span><br>      bit_num = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        bit_num += (num &gt;&gt; i &amp; <span class="hljs-number">1</span>);  <span class="hljs-comment">// 取数字的第i位</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (bit_num % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 答案数字该位为1</span><br>        ans |= <span class="hljs-number">1</span> &lt;&lt; i;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>位运算</p>
<h2 id="二叉搜索树中两个节点之和"><a href="#二叉搜索树中两个节点之和" class="headerlink" title="二叉搜索树中两个节点之和"></a>二叉搜索树中两个节点之和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/opLdQZ/">剑指 Offer II 056. 二叉搜索树中两个节点之和</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrderTraversal</span><span class="hljs-params">(TreeNode *node, vector&lt;<span class="hljs-type">int</span>&gt; &amp;sort_list)</span> </span>&#123;  <span class="hljs-comment">// 中序遍历得到有序序列</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;                                          <span class="hljs-comment">//  节点为空，直接返回</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">preOrderTraversal</span>(node-&gt;left, sort_list);   <span class="hljs-comment">// 先访问左子树</span><br>    sort_list.<span class="hljs-built_in">emplace_back</span>(node-&gt;val);          <span class="hljs-comment">// 再访问根节点</span><br>    <span class="hljs-built_in">preOrderTraversal</span>(node-&gt;right, sort_list);  <span class="hljs-comment">// 最后访问右子树</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sort_list;<br>    <span class="hljs-built_in">preOrderTraversal</span>(root, sort_list);<br>    <span class="hljs-comment">// 头尾两个指针</span><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> q = sort_list.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-keyword">while</span> (p &lt; q) &#123;<br>      sum = sort_list[p] + sort_list[q];<br>      <span class="hljs-keyword">if</span> (sum &gt; k) &#123;  <span class="hljs-comment">// 数字过大，末尾指针前移</span><br>        q--;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; k) &#123;  <span class="hljs-comment">// 数字过小，头部指针后移</span><br>        p++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 找到相应数字，返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>中序遍历+双指针</p>
<h2 id="多次求和构造目标数组"><a href="#多次求和构造目标数组" class="headerlink" title="多次求和构造目标数组"></a>多次求和构造目标数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-target-array-with-multiple-sums/">多次求和构造目标数组</a></p>
<blockquote>
<p>给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作：<br>令 x 为你数组里所有元素的和<br>选择满足 0 &lt;&#x3D; i &lt; target.size 的任意下标 i ，并让 A 数组里下标为 i 处的值为 x 。<br>你可以重复该过程任意次<br>如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPossible</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 只有一个元素时，仅当该元素为1时正确</span><br>      <span class="hljs-keyword">return</span> target[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    ll sum = <span class="hljs-number">0</span>, other_number_sum = <span class="hljs-number">0</span>;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; max_queue;<br>    <span class="hljs-type">int</span> max_value, divisor_number;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : target) &#123;  <span class="hljs-comment">// 将所有元素压入优先队列并计算总和</span><br>      sum += n;<br>      max_queue.<span class="hljs-built_in">emplace</span>(n);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      max_value = max_queue.<span class="hljs-built_in">top</span>();<br>      max_queue.<span class="hljs-built_in">pop</span>();<br>      other_number_sum = sum - max_value;             <span class="hljs-comment">// 其他所有数的总和</span><br>      <span class="hljs-keyword">if</span> (max_value == <span class="hljs-number">1</span> || other_number_sum == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 总能迭代至[1,1,1]的情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (max_value &lt;= other_number_sum || max_value % other_number_sum == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 无法通过减other_number_sum迭代至[1,1,1]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      divisor_number = max_value / other_number_sum * other_number_sum;  <span class="hljs-comment">// 减小到other_sum之下</span><br>      max_value -= divisor_number;<br>      sum -= divisor_number;<br>      max_queue.<span class="hljs-built_in">emplace</span>(max_value);  <span class="hljs-comment">// 重新加入优先队列</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>解题关键：<br>1 最大值减去多个其余数之和而不是每次减去一个，提高程序执行效率<br>2 溢出情况，数组总和大于int最大值，其余数之和同样大于int最大值</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">题目链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; output, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; mark, <span class="hljs-type">int</span> first, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (first == len) &#123;<br>      res.<span class="hljs-built_in">emplace_back</span>(output);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!mark[i]) &#123;<br>        mark[i] = <span class="hljs-literal">true</span>;<br>        output.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>        <span class="hljs-built_in">backtrack</span>(nums, res, output, mark, first + <span class="hljs-number">1</span>, len);<br>        mark[i] = <span class="hljs-literal">false</span>;<br>        output.<span class="hljs-built_in">pop_back</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;      <span class="hljs-comment">// 借助标记数组，使用回溯法找到所有全排列</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>());<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">mark</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; output;<br>    <span class="hljs-built_in">backtrack</span>(nums, res, output, mark, <span class="hljs-number">0</span>, n);       <br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, <span class="hljs-type">int</span> first, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (first == len) &#123;<br>      res.<span class="hljs-built_in">emplace_back</span>(nums);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = first; i &lt; len; i++) &#123;  <span class="hljs-comment">// [0,first−1] 是已填过的数的集合，[first,n−1] 是待填的数的集合</span><br>      <span class="hljs-built_in">swap</span>(nums[i], nums[first]);<br>      <span class="hljs-built_in">backtrack</span>(nums, res, first + <span class="hljs-number">1</span>, len);<br>      <span class="hljs-built_in">swap</span>(nums[i], nums[first]);<br>    &#125;<br>  &#125;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;  <span class="hljs-comment">// 不使用标记数组</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>());<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">backtrack</span>(nums, res, <span class="hljs-number">0</span>, n);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">题目链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt;&amp; source, string combine, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, vector&lt;string&gt;&amp; res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start == end) &#123;  <span class="hljs-comment">// 到达末尾，加入结果集</span><br>      res.<span class="hljs-built_in">emplace_back</span>(combine);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> letter : source[start]) &#123;  <span class="hljs-comment">// 依次使用各个字母</span><br>      <span class="hljs-built_in">traverse</span>(source, combine + letter, start + <span class="hljs-number">1</span>, end, res);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-type">static</span> vector&lt;string&gt; dig2str = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;  <span class="hljs-comment">// 数字字母映射</span><br>    vector&lt;string&gt; strs;<br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> digit : digits) &#123;  <span class="hljs-comment">// 将数字转换成字母集合</span><br>      idx = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(digit - <span class="hljs-string">&#x27;2&#x27;</span>);<br>      strs.<span class="hljs-built_in">emplace_back</span>(dig2str[idx]);<br>    &#125;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-type">int</span> digit_len = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(digits.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">traverse</span>(strs, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, digit_len, res);  <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="两个列表的最小索引总和"><a href="#两个列表的最小索引总和" class="headerlink" title="两个列表的最小索引总和"></a>两个列表的最小索引总和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-index-sum-of-two-lists/">题目链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 使用数组遍历的方式找到最小索引和的餐厅</span><br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findRestaurant</span><span class="hljs-params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(list1.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-type">int</span> len2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(list2.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-type">int</span> max_idx_sum = len1 + len2 - <span class="hljs-number">2</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> low_bound;<br>    <span class="hljs-type">int</span> high_bound;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= max_idx_sum; k++) &#123;  <span class="hljs-comment">// k为索引和</span><br>      low_bound = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, k + <span class="hljs-number">1</span> - len2);<br>      high_bound = <span class="hljs-built_in">min</span>(k, len1 - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = low_bound; i &lt;= high_bound; i++) &#123;<br>        <span class="hljs-keyword">if</span> (list1[i] == list2[k - i]) &#123;<br>          res.<span class="hljs-built_in">emplace_back</span>(list1[i]);<br>          flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (flag) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-comment">// 官方题解，采用哈希表</span><br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findRestaurant</span><span class="hljs-params">(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(list1.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-type">int</span> len2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(list2.<span class="hljs-built_in">size</span>());<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;  <span class="hljs-comment">// 插入字符串-索引对</span><br>      index.<span class="hljs-built_in">insert</span>(&#123;list1[i], i&#125;);<br>    &#125;<br><br>    <span class="hljs-type">int</span> min_index_sum = len1 + len2 + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> index_sum;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; i++) &#123;<br>      <span class="hljs-keyword">if</span> (index.<span class="hljs-built_in">count</span>(list2[i]) &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 若存在相同餐厅名</span><br>        index_sum = index[list2[i]] + i;<br>        <span class="hljs-keyword">if</span> (index_sum &lt; min_index_sum) &#123;<br>          res.<span class="hljs-built_in">clear</span>();<br>          res.<span class="hljs-built_in">emplace_back</span>(list2[i]);<br>          min_index_sum = index_sum;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index_sum == min_index_sum) &#123;<br>          res.<span class="hljs-built_in">emplace_back</span>(list2[i]);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (i &gt; min_index_sum) &#123;  <span class="hljs-comment">// 当前索引已经超过了最小索引和，直接退出循环，</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="IP-地址无效化"><a href="#IP-地址无效化" class="headerlink" title="IP 地址无效化"></a>IP 地址无效化</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/defanging-an-ip-address/">题目链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">defangIPaddr</span><span class="hljs-params">(string address)</span> </span>&#123;<br>    string new_address;<br>    <span class="hljs-type">size_t</span> last_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> cur_pos;<br>    <span class="hljs-keyword">while</span> ((cur_pos = address.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;.&#x27;</span>, last_pos)) != address.npos) &#123;<br>      new_address.<span class="hljs-built_in">append</span>(address, last_pos, cur_pos - last_pos);  <span class="hljs-comment">// 将两.之间的字符添加至字符串</span><br>      new_address.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;[.]&quot;</span>);                                  <span class="hljs-comment">// 插入[.]</span><br>      last_pos = cur_pos + <span class="hljs-number">1</span>;                                     <span class="hljs-comment">// 更新last_pos，+1跳过字符&#x27;.&#x27;</span><br>    &#125;<br>    new_address.<span class="hljs-built_in">append</span>(address, last_pos, address.<span class="hljs-built_in">length</span>() - last_pos);  <span class="hljs-comment">// 添加末尾字符串</span><br>    <span class="hljs-keyword">return</span> new_address;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="一个图中连通三元组的最小度数"><a href="#一个图中连通三元组的最小度数" class="headerlink" title="一个图中连通三元组的最小度数"></a>一个图中连通三元组的最小度数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/">题目链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> kInf = <span class="hljs-number">0x7fffffff</span>;<br>  <span class="hljs-comment">// 直接枚举</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTrioDegree</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">degree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> edge : edges) &#123;  <span class="hljs-comment">// 构建邻接表</span><br>      matrix[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>      matrix[edge[<span class="hljs-number">1</span>]][edge[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;<br>      degree[edge[<span class="hljs-number">0</span>]]++;  <span class="hljs-comment">// 计算各节点的度</span><br>      degree[edge[<span class="hljs-number">1</span>]]++;<br>    &#125;<br>    <span class="hljs-type">int</span> min_degree = kInf;<br>    <span class="hljs-type">int</span> triple_degree;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">2</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (min_degree == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 最小度为0，直接返回</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果i j之间存在边</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][k] == <span class="hljs-number">1</span> &amp;&amp; matrix[j][k] == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 存在共同边</span><br>              triple_degree = degree[i] + degree[j] + degree[k] - <span class="hljs-number">6</span>;<br>              min_degree = <span class="hljs-built_in">min</span>(min_degree, triple_degree);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (min_degree == kInf) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min_degree;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="最短公共超序列"><a href="#最短公共超序列" class="headerlink" title="最短公共超序列"></a>最短公共超序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-common-supersequence/">题目链接</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">shortestCommonSupersequence</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(str1.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(str2.<span class="hljs-built_in">size</span>());<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;  <span class="hljs-comment">// 由状态转移方程求dp数组</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) &#123;<br>          dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> i = m;<br>    <span class="hljs-type">int</span> j = n;<br>    string lcs;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; j &gt;= <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 倒推出最长公共子序列</span><br>      <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) &#123;<br>        lcs.<span class="hljs-built_in">push_back</span>(str1[i - <span class="hljs-number">1</span>]);<br>        i--;<br>        j--;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>][j] &gt; dp[i][j - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 未选择str1</span><br>          i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 未选择str2</span><br>          j--;<br>        &#125;<br>      &#125;<br>    &#125;<br>    i = <span class="hljs-number">0</span>;<br>    j = <span class="hljs-number">0</span>;<br>    string ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = lcs.<span class="hljs-built_in">rbegin</span>(); iter != lcs.<span class="hljs-built_in">rend</span>(); iter++) &#123;  <span class="hljs-comment">// 填充字符</span><br>      <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; str1[i] != *iter) &#123;                         <span class="hljs-comment">// 不在公共子序列中</span><br>        ans.<span class="hljs-built_in">push_back</span>(str1[i]);<br>        i++;<br>      &#125;<br>      <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; str2[j] != *iter) &#123;  <span class="hljs-comment">// 不在公共子序列中</span><br>        ans.<span class="hljs-built_in">push_back</span>(str2[j]);<br>        j++;<br>      &#125;<br>      ans.<span class="hljs-built_in">push_back</span>(*iter);  <span class="hljs-comment">// 公共序列，只需填一次</span><br>      i++;<br>      j++;<br>    &#125;<br>    <span class="hljs-comment">// 处理剩余字符</span><br>    <span class="hljs-keyword">while</span> (i &lt; m) &#123;<br>      ans.<span class="hljs-built_in">push_back</span>(str1[i]);<br>      i++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>      ans.<span class="hljs-built_in">push_back</span>(str2[j]);<br>      j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>对照题解简单打一下，加深印象</p>
<h2 id="有效的括号字符串"><a href="#有效的括号字符串" class="headerlink" title="有效的括号字符串"></a>有效的括号字符串</h2><p><strong>题目简要</strong><br>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：<br>任何左括号 ( 必须有相应的右括号 )。<br>任何右括号 ) 必须有相应的左括号 ( 。<br>左括号 ( 必须在对应的右括号之前 )。<br>* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。<br>一个空字符串也被视为有效字符串。</p>
<p><strong>回溯+剪枝</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// find_result: 是否找到合法表达式 bracket_diff：左括号数-右括号数 wildcard_num：当前通配符数目</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> left_bracket_number, <span class="hljs-type">int</span> start, <span class="hljs-type">bool</span>&amp; find_result, <span class="hljs-type">int</span> bracket_diff, <span class="hljs-type">int</span> wildcard_num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (find_result || left_bracket_number &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">abs</span>(bracket_diff) &gt; wildcard_num) &#123;  <span class="hljs-comment">// 提前结束：1 已找到合法表达式 2 表达式不合法 3 通配符无法满足需求</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (start == s.<span class="hljs-built_in">length</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (left_bracket_number == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 表达式合法</span><br>        find_result = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (s[start]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>        <span class="hljs-built_in">backtrace</span>(s, left_bracket_number + <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>, find_result, bracket_diff, wildcard_num);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>        <span class="hljs-built_in">backtrace</span>(s, left_bracket_number - <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>, find_result, bracket_diff, wildcard_num);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>        <span class="hljs-built_in">backtrace</span>(s, left_bracket_number + <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>, find_result, bracket_diff + <span class="hljs-number">1</span>, wildcard_num - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 替换为左括号</span><br>        <span class="hljs-built_in">backtrace</span>(s, left_bracket_number, start + <span class="hljs-number">1</span>, find_result, bracket_diff, wildcard_num - <span class="hljs-number">1</span>);          <span class="hljs-comment">// 替换为空字符串</span><br>        <span class="hljs-built_in">backtrace</span>(s, left_bracket_number - <span class="hljs-number">1</span>, start + <span class="hljs-number">1</span>, find_result, bracket_diff - <span class="hljs-number">1</span>, wildcard_num - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 替换为右括号</span><br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> res = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> wildcard_num = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 通配符数目</span><br>    <span class="hljs-type">int</span> left_bracket = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 左括号数目</span><br>    <span class="hljs-type">int</span> right_bracket = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 右括号数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;      <span class="hljs-comment">// 统计各符号数目</span><br>      <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>          left_bracket++;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>          right_bracket++;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>          wildcard_num++;<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">backtrace</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, res, left_bracket - right_bracket, wildcard_num);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>无法通过最后一个测试用例，超时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;*************************************************************************************************((*&quot;</span><br></code></pre></td></tr></table></figure>
<p>这是因为该样例太多通配符，且无法找到合法表达式，故可能情况接近3的100次方。<br>存在性问题若最终答案为不存在需穷举所有情况<br><strong>官方动态规划</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(len, <span class="hljs-literal">false</span>));  <span class="hljs-comment">// dp[i][j]表示[i,j]子串是否合法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;                          <span class="hljs-comment">// 长度为1的子串</span><br>      <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>        dp[i][i] = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= len; k++) &#123;                                         <span class="hljs-comment">// 子串长度</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len - k; i++) &#123;                                   <span class="hljs-comment">// 起始索引</span><br>        <span class="hljs-type">int</span> j = i + k - <span class="hljs-number">1</span>;                                                   <span class="hljs-comment">// 子串末尾索引</span><br>        <span class="hljs-keyword">if</span> ((s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;*&#x27;</span>) &amp;&amp; (s[j] == <span class="hljs-string">&#x27;)&#x27;</span> || s[j] == <span class="hljs-string">&#x27;*&#x27;</span>)) &#123;  <span class="hljs-comment">// 两端字符要求</span><br>          <span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<br>            dp[i][j] = <span class="hljs-literal">true</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = i; x &lt; j &amp;&amp; dp[i][j] == <span class="hljs-literal">false</span>; x++) &#123;  <span class="hljs-comment">// 由两个子串拼接而成的表达式</span><br>          dp[i][j] = dp[i][x] &amp;&amp; dp[x + <span class="hljs-number">1</span>][j];<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][len - <span class="hljs-number">1</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>效率也低，但无所谓，只是用来熟悉动态规划的。</p>
<h2 id="每个小孩最多能分到多少糖果"><a href="#每个小孩最多能分到多少糖果" class="headerlink" title="每个小孩最多能分到多少糖果"></a>每个小孩最多能分到多少糖果</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/">每个小孩最多能分到多少糖果</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 关键性质：如果能满足i，则一定能满足[0,i]区间任意数目</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumCandies</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candies, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> i) -&gt; <span class="hljs-type">bool</span> &#123;  <span class="hljs-comment">// 判断k 个小孩能否按要求拿到 i 个糖果</span><br>      <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candy : candies) &#123;<br>        sum += candy / i;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sum &gt;= k;<br>    &#125;;<br>    <span class="hljs-comment">// 计算无法达到需求的最小i</span><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> high = *<span class="hljs-built_in">max_element</span>(candies.<span class="hljs-built_in">begin</span>(), candies.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>      mid = (low + high) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>        low = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// mid达到要求，+1</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        high = mid;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// low-1即为最大糖果数目</span><br>    <span class="hljs-keyword">return</span> low - <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>不是所有题目都是动态规划。</p>
<h2 id="最大平均值和的分组"><a href="#最大平均值和的分组" class="headerlink" title="最大平均值和的分组"></a>最大平均值和的分组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-sum-of-averages/">最大平均值和的分组</a><br><img src="https://img-blog.csdnimg.cn/0eec17dff99d490294f4c5bc5d6fe500.png" srcset="/img/loading.gif" lazyload><br>最优子结构：dp(i,j)由多个子问题的解dp(x,j-1)合成而来<br>无后效性：一旦dp(i,j)确定，就不再关心由哪个dp(x,j-1)得来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">largestSumOfAverages</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (size &lt;= k) &#123;  <span class="hljs-comment">// 各个数为一个子数组</span><br>      <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        ans += num;<br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(size + <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// prefix[i]= nums[0]+nums[1]+...nums[i-1]</span><br>    prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;<br>      prefix[i] = prefix[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(k + <span class="hljs-number">1</span>));  <span class="hljs-comment">// dp[i][j]：只有前i个数分成j个子数组的最大平均值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;                            <span class="hljs-comment">// j=1，即为整个数组平均值</span><br>      dp[i][<span class="hljs-number">1</span>] = prefix[i] / i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= k; j++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j; i &lt;= size; i++) &#123;<br>        <span class="hljs-comment">// 计算dp[i][j]，此时i&gt;=j，保证能分成j个子数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = j - <span class="hljs-number">1</span>; x &lt; i; x++) &#123;  <span class="hljs-comment">//  j-1=&lt; x &lt;i 保证前面至少能分成j-1个子数组，后面能分一个子数组</span><br>          dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[x][j - <span class="hljs-number">1</span>] + (prefix[i] - prefix[x]) / (i - x));<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[size][k];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">simple</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (size &lt;= k) &#123;  <br>      <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        ans += num;<br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(size + <span class="hljs-number">1</span>)</span></span>;  <br>    prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;<br>      prefix[i] = prefix[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(size + <span class="hljs-number">1</span>)</span></span>;      <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;  <br>      dp[i] = prefix[i] / i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= k; j++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &gt;= j; i--) &#123;  <span class="hljs-comment">// 逆序保证dp[1] ... dp[i-1]为上一次计算的结果，即dp[1][j-1]...dp[i-1][j-1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = j - <span class="hljs-number">1</span>; x &lt; i; x++) &#123;  <br>          dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[x] + (prefix[i] - prefix[x]) / (i - x));<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[size];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>动态规划有可能与前面任意一位有关，不一定是n-1位</p>
<h1 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h1><h2 id="【2021】阿里巴巴编程题（2星）"><a href="#【2021】阿里巴巴编程题（2星）" class="headerlink" title="【2021】阿里巴巴编程题（2星）"></a>【2021】阿里巴巴编程题（2星）</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/exam/test/66997119/detail?pid=30440590&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=134&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">【2021】阿里巴巴编程题（2星）</a></p>
<h3 id="第一题-完美对"><a href="#第一题-完美对" class="headerlink" title="第一题 完美对"></a>第一题 完美对</h3><p><img src="https://img-blog.csdnimg.cn/0e8542dcc32747d28ebe54a7dc1e4062.png" srcset="/img/loading.gif" lazyload><br>数组各数减去第一个数，归并相同特征的数组，使用map记录各数组的出现次数，对每一个map kv，查看map中是否存在相反数组，需对全0数组（相反数组为自身）进行特殊处理，为了避免重复计算，将相反数组出现次数置为-1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Another</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">another</span><span class="hljs-params">(v.size())</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    another[i] = -v[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> another;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, k;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; k) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>        cin &gt;&gt; arr[i][j];<br>      &#125;<br>    &#125;<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; ma;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = k - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        arr[i][j] -= arr[i][<span class="hljs-number">0</span>];<br>      &#125;<br>      ma[arr[i]]++;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = ma.<span class="hljs-built_in">begin</span>(); iter != ma.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>      <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 标记为删除，跳过</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">auto</span> another_iter = ma.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">Another</span>(iter-&gt;first));  <span class="hljs-comment">// 寻找是否存在相反数组</span><br>      <span class="hljs-keyword">if</span> (another_iter == iter) &#123;                         <span class="hljs-comment">// 全零数组，相反即本身</span><br>        ans += iter-&gt;second * (iter-&gt;second - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (another_iter != ma.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 后面存在相反数组</span><br>        ans += iter-&gt;second * another_iter-&gt;second;<br>        another_iter-&gt;second = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 标记为删除</span><br>      &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第二题-选择物品"><a href="#第二题-选择物品" class="headerlink" title="第二题 选择物品"></a>第二题 选择物品</h3><p><img src="https://img-blog.csdnimg.cn/2f208e0d1f404fb19b47cb43c4efd704.png" srcset="/img/loading.gif" lazyload><br>全排列变形问题，长度为m时输出结果，数字交换时强制要求序列递增，去重处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (start == m) &#123;  <span class="hljs-comment">// 长度达到要求，输出结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>      cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (start == <span class="hljs-number">0</span> || vec[i] &gt; vec[start - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 限制序列必须递增，去重</span><br>        <span class="hljs-built_in">swap</span>(vec[i], vec[start]);<br>        <span class="hljs-built_in">dfs</span>(vec, start + <span class="hljs-number">1</span>, m);<br>        <span class="hljs-built_in">swap</span>(vec[i], vec[start]);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 初始化数组内容</span><br>      arr[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(arr, <span class="hljs-number">0</span>, m);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="第三题-小强去春游"><a href="#第三题-小强去春游" class="headerlink" title="第三题 小强去春游"></a>第三题 小强去春游</h3><p><img src="https://img-blog.csdnimg.cn/2c77b77c4a7e43ca8129cf1427e3e4f1.png" srcset="/img/loading.gif" lazyload><br>动态规划问题，假设已解决n-1与n-2规模时最短时间，可能的方法是：n-1 （最轻的人单独过河把最重的人接过来  fn-1+v0+vn） n-2（最轻的人过去 最重的和第二重的人过去 第二轻的人过来 第一第二轻的人过去  fn-2+v1+vn+v2+v2）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> T, n;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      cin &gt;&gt; vec[j];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>      cout &lt;&lt; vec[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>      cout &lt;&lt; vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用三个变量维持前两个 前一个 当前元素</span><br>    <span class="hljs-type">int</span> first = vec[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> second = vec[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> three;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-comment">// 状态转移方程</span><br>      three = <span class="hljs-built_in">min</span>(second + vec[<span class="hljs-number">0</span>] + vec[i], first + vec[i] + vec[<span class="hljs-number">0</span>] + vec[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span>);<br>      <span class="hljs-comment">// 更新序列</span><br>      first = second;<br>      second = three;<br>    &#125;<br>    cout &lt;&lt; three &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="第四题-比例问题"><a href="#第四题-比例问题" class="headerlink" title="第四题 比例问题"></a>第四题 比例问题</h3><p><img src="https://img-blog.csdnimg.cn/26eb023fb31a4b2887884f0a27d4fa9e.png" srcset="/img/loading.gif" lazyload><br>枚举即可，时刻注意溢出问题，机试多使用long long</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> A, B, a, b;  <span class="hljs-comment">// 使用long long存储数字，防止溢出</span><br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; A &gt;&gt; B &gt;&gt; a &gt;&gt; b) &#123;<br>    <span class="hljs-keyword">if</span> (A &gt; B * a / b) &#123;  <span class="hljs-comment">// 缩小查找范围</span><br>      A = B * a / b;<br>    &#125;<br>    <span class="hljs-type">bool</span> find = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = A; i &gt;= <span class="hljs-number">1</span>; i--) &#123;  <span class="hljs-comment">// 逆序遍历可能数字</span><br>      <span class="hljs-keyword">if</span> ((i * b) % a == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i * b / a &lt;&lt; endl;<br>        find = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!find) &#123;  <span class="hljs-comment">// 不存在可能数字组合</span><br>      cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="第五题-小强修水渠"><a href="#第五题-小强修水渠" class="headerlink" title="第五题 小强修水渠"></a>第五题 小强修水渠</h3><p><img src="https://img-blog.csdnimg.cn/80ed7011aa71431698a3a9fcae0f655c.png" srcset="/img/loading.gif" lazyload><br>最开始发现最小距离点一定在端点上（若有多个点，一定存在端点），故从前往后变量，计算端点的距离和，left为与左边点的长度和，right为与右边点的长度和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; x &gt;&gt; y;<br>      vec[i] = x;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = <span class="hljs-number">0</span>; <span class="hljs-comment">// 与左部端点的距离和</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = <span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), -n * vec[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 与右部端点的距离和</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> min_len = left + right;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>      left += i * (vec[i] - vec[i - <span class="hljs-number">1</span>]);<br>      right -= (n - i) * (vec[i] - vec[i - <span class="hljs-number">1</span>]);<br>      min_len = <span class="hljs-built_in">min</span>(min_len, left + right);<br>    &#125;<br>    cout &lt;&lt; min_len &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>后面发现最小距离和是中位数的性质，直接求中位数即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; x &gt;&gt; y;<br>      vec[i] = x;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = (vec[n / <span class="hljs-number">2</span>] + vec[(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) / <span class="hljs-number">2</span>;	<span class="hljs-comment">// 中位数</span><br>    <span class="hljs-type">int</span> sum_len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> xi : vec) &#123;<br>      sum_len += <span class="hljs-built_in">abs</span>(x - xi);<br>    &#125;<br>    cout &lt;&lt; sum_len &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第六题-国际交流会"><a href="#第六题-国际交流会" class="headerlink" title="第六题 国际交流会"></a>第六题 国际交流会</h3><p>最近小强主办了一场国际交流会，大家在会上以一个圆桌围坐在一起。由于大会的目的就是让不同国家的人感受一下不同的异域气息，为了更好地达到这个目的，小强希望最大化邻座两人之间的差异程度和。为此，他找到了你，希望你能给他安排一下座位，达到邻座之间的差异之和最大。</p>
<p>输入总共两行。<br>第一行一个正整数，代表参加国际交流会的人数(即圆桌上所坐的总人数，不单独对牛牛进行区分）<br>第二行包含个正整数，第个正整数a_i代表第个人的特征值。<br>其中<br>注意：<br>邻座的定义为: 第人的邻座为，第人的邻座是，第人的邻座是。<br>邻座的差异值计算方法为。<br>每对邻座差异值只计算一次。<br>输出总共两行。<br>第一行输出最大的差异值。<br>第二行输出用空格隔开的个数，为重新排列过的特征值。<br>（注意：不输出编号）<br>如果最大差异值情况下有多组解，输出任意一组即可。</p>
<p><strong>思路</strong><br>依次选取较大值与较小值即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数组排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;  <span class="hljs-comment">// 依次选取较大值与较小值</span><br>      ans[<span class="hljs-number">2</span> * i] = nums[i];<br>      ans[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = nums[n - i - <span class="hljs-number">1</span>];<br>    &#125;<br>    ans[n - <span class="hljs-number">1</span>] = nums[n / <span class="hljs-number">2</span>];  <span class="hljs-comment">// 奇数时最后一位未赋值</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> diff = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 差异和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      diff += <span class="hljs-built_in">abs</span>(ans[i] - ans[(i + <span class="hljs-number">1</span>) % n]);<br>    &#125;<br>    cout &lt;&lt; diff &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : ans) &#123;<br>      cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 数组排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-comment">// 双指针方式</span><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        ans[i] = nums[low];<br>        low++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans[i] = nums[high];<br>        high--;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> diff = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 差异和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      diff += <span class="hljs-built_in">abs</span>(ans[i] - ans[(i + <span class="hljs-number">1</span>) % n]);<br>    &#125;<br>    cout &lt;&lt; diff &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : ans) &#123;<br>      cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2021】阿里巴巴编程题（4星）"><a href="#2021】阿里巴巴编程题（4星）" class="headerlink" title="2021】阿里巴巴编程题（4星）"></a>2021】阿里巴巴编程题（4星）</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/exam/test/67003139/detail?pid=30440638&examPageSource=Company&testCallback=https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=134&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">2021】阿里巴巴编程题（4星）</a></p>
<h3 id="第一题-子集"><a href="#第一题-子集" class="headerlink" title="第一题 子集"></a>第一题 子集</h3><p><img src="https://img-blog.csdnimg.cn/16aa46d27bc24accabc81e6718834a93.png" srcset="/img/loading.gif" lazyload><br>经典的二维最长递增子序列问题，刚开始使用动态规划实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> T;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; T; k++) &#123;<br>    <span class="hljs-type">int</span> n, x, y;<br>    cin &gt;&gt; n;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">item</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; item[i].first;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; item[i].second;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p1, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p2) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> p1.first &lt; p2.first || (p1.first == p2.first &amp;&amp; p1.second &gt; p2.second); &#125;;<br>    <span class="hljs-built_in">sort</span>(item.<span class="hljs-built_in">begin</span>(), item.<span class="hljs-built_in">end</span>(), cmp);  <span class="hljs-comment">// 使用自定义排序函数</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;                 <span class="hljs-comment">// 以item[i].second为末尾的最长增长子序列长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (item[i].second &gt; item[j].second) &#123;  <span class="hljs-comment">// 进行状态转移</span><br>          dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>超时，过不了，只能使用二分查找解法了<br><img src="https://img-blog.csdnimg.cn/359c7bb28c034055a6dacdd1d0be9d07.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> T;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; T; k++) &#123;<br>    <span class="hljs-type">int</span> n, x, y;<br>    cin &gt;&gt; n;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">item</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; item[i].first;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; item[i].second;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p1, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p2) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> p1.first &lt; p2.first || (p1.first == p2.first &amp;&amp; p1.second &gt; p2.second); &#125;;<br>    <span class="hljs-built_in">sort</span>(item.<span class="hljs-built_in">begin</span>(), item.<span class="hljs-built_in">end</span>(), cmp);  <span class="hljs-comment">// 使用自定义排序函数</span><br>    <span class="hljs-type">int</span> piles = <span class="hljs-number">0</span>;                        <span class="hljs-comment">// 牌堆数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> right = piles;<br>      <span class="hljs-type">int</span> poker = item[i].second;  <span class="hljs-comment">// 待放置的扑克牌</span><br>      <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (item[mid].second &gt;= poker) &#123;<br>          right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (left == piles) &#123;  <span class="hljs-comment">// 新建牌堆</span><br>        piles++;<br>      &#125;<br>      item[left].second = poker;  <span class="hljs-comment">// 放置牌堆顶</span><br>    &#125;<br>    cout &lt;&lt; piles &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第二题-小强爱数学"><a href="#第二题-小强爱数学" class="headerlink" title="第二题 小强爱数学"></a>第二题 小强爱数学</h3><p><img src="https://img-blog.csdnimg.cn/ac8d40cd5db54874ab8b0c42c6760f62.png" srcset="/img/loading.gif" lazyload><br>记忆深刻的问题，之前写过一遍，当时也是写了很久没写出来，看了一下午愣是没看出为啥答案错了<br><img src="https://img-blog.csdnimg.cn/502967515c3d4312bf60cba8011157fe.png" srcset="/img/loading.gif" lazyload><br>题目的难点在于想出这个递推公式，然后就是mod运算的性质，不过我出错的点在于使用int存储A，B，并用A，B计算了一次dp[2]，运算过程会溢出，即使dp[2]为long long，<strong>但表达式的组成元素类型全部为int，故仍然会发生溢出</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> A,B;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x = A * A - <span class="hljs-number">2</span> * B;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> T;<br>  cin &gt;&gt; T;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; T; k++) &#123;<br>    ll A, B, n;  <span class="hljs-comment">// 设置为long long，防止溢出</span><br>    cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">3</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br>    dp[<span class="hljs-number">1</span>] = A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;  <span class="hljs-comment">// fn = A * fn-1 - B * fn-2</span><br>      dp[i] = (dp[i - <span class="hljs-number">1</span>] * A % kMod - dp[i - <span class="hljs-number">2</span>] * B % kMod + kMod) % kMod;<br>    &#125;<br>    cout &lt;&lt; dp[n] &lt;&lt; endl;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/leetcode-%E7%AE%97%E6%B3%95-c/" class="print-no-link">#leetcode 算法 c++</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/%E9%A9%B1%E5%8A%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html" title="驱动虚拟环境搭建记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">驱动虚拟环境搭建记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/r8169%E9%A9%B1%E5%8A%A8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95.html" title="r8169驱动源码阅读记录">
                        <span class="hidden-mobile">r8169驱动源码阅读记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz","appKey":"0e2MMh7ddBCGGytOe9UEy5NP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://uu0wegco.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
