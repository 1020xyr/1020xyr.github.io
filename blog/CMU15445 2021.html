

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/nano-1.jpg">
  <link rel="icon" href="/img/nano-1.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="最佳损友1020">
  <meta name="keywords" content="">
  
    <meta name="description" content="写在前面lab地址讲义地址推荐书籍：《数据库系统概念》 &#x2F; 《Database-System-Concepts》中文版有许多删减和错误，英文版看起来又费劲。 数据密集型应用设计《C++ primer》，Google 开源项目风格指南，Effective系列（Effective c++，Effective STL，Effective modern c++） 由于刚开始不知道咋注册Gr">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15445 2021">
<meta property="og:url" content="https://www.jiasun.top/blog/CMU15445%202021.html">
<meta property="og:site_name" content="最佳损友1020’s Blog">
<meta property="og:description" content="写在前面lab地址讲义地址推荐书籍：《数据库系统概念》 &#x2F; 《Database-System-Concepts》中文版有许多删减和错误，英文版看起来又费劲。 数据密集型应用设计《C++ primer》，Google 开源项目风格指南，Effective系列（Effective c++，Effective STL，Effective modern c++） 由于刚开始不知道咋注册Gr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/caa4bd8758da47d4b403b54845e64233.jpeg">
<meta property="article:published_time" content="2022-02-21T14:05:34.000Z">
<meta property="article:modified_time" content="2023-10-31T14:45:58.865Z">
<meta property="article:author" content="最佳损友1020">
<meta property="article:tag" content="cmu 15445 hash index buffer pool query execution concurrency">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/caa4bd8758da47d4b403b54845e64233.jpeg">
  
  
  
  <title>CMU15445 2021 - 最佳损友1020’s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/csdn.css">
<link rel="stylesheet" href="/css/top.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.jiasun.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz","app_key":"ljkRZDiTtVmjn5mpaQmpFqgv","server_url":"https://n227fxnj.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>最佳损友1020</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15445 2021"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-21 22:05" pubdate>
          2022年2月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          81k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          676 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15445 2021</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer" />


<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/assignments.html">lab地址</a><br><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/schedule.html">讲义地址</a><br>推荐书籍：<br><a target="_blank" rel="noopener" href="https://www.jiumodiary.com/">《数据库系统概念》</a> &#x2F; <a target="_blank" rel="noopener" href="https://github.com/omarhosny206/Database-System-Concepts-7th-edition/blob/master/Book/Database%20System%20Concepts.pdf">《Database-System-Concepts》</a><br>中文版有许多删减和错误，英文版看起来又费劲。<br> <a target="_blank" rel="noopener" href="https://github.com/Vonng/ddia">数据密集型应用设计</a><br>《C++ primer》，<a target="_blank" rel="noopener" href="https://google-styleguide.readthedocs.io/zh_CN/latest/">Google 开源项目风格指南</a>，<br>Effective系列（Effective c++，Effective STL，Effective modern c++）</p>
<p>由于刚开始不知道咋注册Gradescope，就只通过了本地的测试用例，做完了3个实验后才开始提交Gradescope。Gradescope的注册邀请码为4PR8G5，学校填Carnegie Mellon University就可以了。实际上这个在FAQ提到了，以前没看。<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/faq.html">CMU 15445 faq</a><br>同时可以看看这个博客<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366484273">CMU 15-445：知名教授历时多年打磨，数据库神级课程限时免费！</a>,里面的课程群有相应的测试用例。另外加入<a target="_blank" rel="noopener" href="https://discord.gg/YF7dMCg">Discord Channel</a>看看别人问的问题等等。</p>
<p><strong>代码Q群自取：237108591，如有任何问题，望请告知！</strong></p>
<h3 id="C-primer"><a href="#C-primer" class="headerlink" title="C++ primer"></a>C++ primer</h3><p>test&#x2F;primer&#x2F;starter_test.cpp：测试代码<br>src&#x2F;include&#x2F;primer&#x2F;p0_starter.h：实现代码</p>
<p>在实现完代码功能后，去掉测试代码中的DISABLED_前缀，进行测试。我一般都是一边看着测试代码，一边看测试输出，看看是代码哪块出了问题。测试成功之后使用以下命令调整代码格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># check.sh</span><br>make format<br>make check-lint -j12<br>make check-clang-tidy -j12<br></code></pre></td></tr></table></figure>
<p>可以把以上这几个命令写成脚本，省的一次一次打，也可以把压缩proj的命令写成脚本，便于执行</p>
<p><strong>模板类继承模板类 子类看不到父类成员</strong><br>RowMatrix使用Matrix的成员变量需加上Matrix<T>::</p>
<p>C++的模板中的名称会进行两次查找，称为两阶段查找（two-phase lookup）。对于一个非依赖型名称（不以任何方式依赖于模板参数的名称），在模板声明进行解析的时候就会进行查找。但C++标准中规定（14.6.2 3），一个非受限的名称查找的时候将不会考虑依赖型的基类。因为有偏特化，所以一个模板子类其实是不能在实例化之前就知道他的模板父类到底是谁，因此名字也无法resolve，所以只能this-&gt;了。不过VC++有个小扩展，允许你不使用this-&gt;就可以调用父类的名字，特别方便。由此可见，其实也是完全可以做到的。<br>Effective C++ 210页：因为base class templates有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因为编译器往往拒绝在模板化基类内寻找继承而来的名称。（好像仅仅解释了方法，没解释成员变量）</p>
<p>查找不到就会错误。解决办法是把它变成一个依赖型名称：<br>在x前加</p>
<ol>
<li>this-&gt;或者Parent::</li>
<li>子类中添加using Parent::x;</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lonelyisland_syz/article/details/103517885">模板类继承模板类 子类看不到父类成员</a></p>
<p><strong>提交后发现的问题：</strong><br>GEMM函数里调用Add函数写成了ADD</p>
<p>语法风格问题</p>
<p>1 条件语句中直接用布尔变量，不需要写布尔值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(ret==<span class="hljs-literal">true</span>)  -&gt; <span class="hljs-keyword">if</span>(ret)<br></code></pre></td></tr></table></figure>
<p>实际上我觉得加上布尔值加强了可读性（软件工程）<br><img src="https://img-blog.csdnimg.cn/73a9e20765f347d282a2c1f7dd8fa85d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_15,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br><a target="_blank" rel="noopener" href="https://clang.llvm.org/extra/clang-tidy/checks/readability-simplify-boolean-expr.html">readability-simplify-boolean-expr</a></p>
<p>2 即使if语句后只有一条语句，也需要用大括号括起来</p>
<p>3 注释后空格再加文字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// comment</span><br></code></pre></td></tr></table></figure>
<h4 id="语法点"><a href="#语法点" class="headerlink" title="语法点"></a>语法点</h4><blockquote>
<p>#pragma once</p>
</blockquote>
<p>#pragma once一般由编译器提供保证：同一个文件不会被包含多次。这里所说的”同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作#pragma once声明，而只能针对文件。</p>
<blockquote>
<p>nullptr</p>
</blockquote>
<p>C语言中常数0和(void*)0都是空指针常量；C++中（暂且忽略C++11）常数0是，而(void*)0 不是。因为C语言中任何类型的指针都可以（隐式地）转换为void*型，反过来也行，而C++中void*型不能隐式地转换为别的类型指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__cplusplus)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> NULL 0    <span class="hljs-comment">// C++中使用0作为NULL的值</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> NULL ((void *)0)    <span class="hljs-comment">// C中使用((void *)0)作为NULL的值</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;&#125;     <span class="hljs-comment">// #1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span> </span>&#123;&#125;   <span class="hljs-comment">// #2</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 调用#1还是#2？</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从字面上来讲，NULL是个空指针常量，我们可能会觉得：既然是个指针，那么应该调用#2。但事实上调用的却是#1，因为C++中NULL扩展为常数0，它是int型。<br><strong>根本原因就是：常数0既是整数常量，也是空指针常量。</strong></p>
<p>为了解决这种二义性，C++11标准引入了关键字nullptr，它作为一种空指针常量<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nothx/p/8523191.html">NULL、0、nullptr的区别</a></p>
<blockquote>
<p>return {}</p>
</blockquote>
<p>return {};表示“返回用空 list-initializer 初始化的函数返回类型的对象”。确切的行为取决于返回对象的类型。</p>
<p><strong>Effective modern c++ item21: 优先考虑使⽤std::make_unique和std::make_shared而⾮new</strong></p>
<h3 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h3><p><strong>实验背景：</strong><br>BufferManager运行时内部维护一份高速缓存，其中有些page是正在被使用的，有些page是不被使用但但仍有意义的(unpinned)，Repalcer则是维护那些unpinned page，在必要的时候将其中某些page替换出去。</p>
<blockquote>
<p>《数据库系统概念》10.8.1缓冲区管理器：<br>被钉住的块（pinned block）：为了使数据库系统能够从系统崩溃中恢复，限制一个块写回磁盘的时间是十分必要的。例如：当一个块上更新操作正在进行时，大多数恢复系统不允许该块写回磁盘。不允许写回磁盘的块称为被钉住的（pinned）的块。</p>
</blockquote>
<p><strong>page_id和frame_id：</strong><br>前者指的是某一个page编号，比如disk上第十个page；后者指的是BufferPoolManager中的页框号码。<br>前者需要通过disk层获取，后者是BufferPoolManager中固定的，从0开始。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366788722">《CMU15445》 &amp;&amp; [BufferPoolManager]</a></p>
<p>在函数中我大多使用lock_guard进行加锁，只是为了图方便，也不知道是否实现了线程安全。但一个持有锁的函数调用另一个加锁的函数会造成死锁，可以使用recursive_mutex解决该问题，但我后面才知道recursive_mutex，懒得再改了。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ykun089/article/details/113697205">[c++] 同一线程两次加锁可能导致死锁问题</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40179091/article/details/108650433">c++11 std::recursive_mutex</a></p>
<p><strong>LRU Replacement Policy</strong><br>根据测试代码推出，对同一个元素调用两次unpin函数，第二次无效<br><strong>Buffer Pool Manager Instance</strong><br>这个部分我都是按照给出的提示写的，倒也没太大问题，就是刚开始都没发现要用disk_manager_成员，要修改Page，后面简单看了这两个类的定义才正确实现了函数的功能。<br><strong>Parallel Buffer Pool Manager</strong><br>这个部分功能本来是最简单的，调用一下第二部分的代码就结束了。然而当时写的太快，一些符号写错了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span> &#123;<br>  page = instances_[index]-&gt;<span class="hljs-built_in">NewPage</span>(page_id);<br>  <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>    start_index_ = (start_index_ + <span class="hljs-number">1</span>) % num_instances_;<br>    <span class="hljs-keyword">return</span> page;<br>  &#125;<br>  index = (index + <span class="hljs-number">1</span>) % num_instances_;<br>&#125; <span class="hljs-keyword">while</span> (index != start_index_);<br><span class="hljs-comment">//其中索引加1时 = 写成了 +=</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParallelBufferPoolManager::FlushPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Flush page_id from responsible BufferPoolManagerInstance</span><br>  BufferPoolManager *manager = <span class="hljs-built_in">GetBufferPoolManager</span>(page_id);<br>  <span class="hljs-keyword">return</span> manager-&gt;<span class="hljs-built_in">FlushPage</span>(page_id);<br>&#125;<br><span class="hljs-comment">//其中manager-&gt;FlushPage(page_id);写成了manager-&gt;FetchPage(page_id); </span><br></code></pre></td></tr></table></figure>
<p>这就引来了一堆错误，一进行测试就产生段错误（数组越界）。然后就开始了几小时的debug。我觉得这过程还比较有纪念意义的，故记录在此。</p>
<h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 <span class="hljs-built_in">mkdir</span> build_debug  <span class="hljs-comment">#创建专用于debug的文件夹</span><br>2 cmake -DCMAKE_BUILD_TYPE=DEBUG .. <span class="hljs-comment">#看CMakeLists.txt实际上就是加了一个-g选项，生成调试信息。</span><br><span class="hljs-comment"># CMakeLists.txt</span><br><span class="hljs-built_in">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -fPIC -Wall -Wextra -Werror -march=native&quot;</span>)<br><span class="hljs-built_in">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -Wno-unused-parameter -Wno-attributes&quot;</span>) <span class="hljs-comment">#<span class="hljs-doctag">TODO:</span> remove</span><br><span class="hljs-built_in">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CMAKE_CXX_FLAGS_DEBUG&#125;</span> -O0 -ggdb -fsanitize=address -fno-omit-frame-pointer -fno-optimize-sibling-calls&quot;</span>)<br><span class="hljs-built_in">set</span>(CMAKE_EXE_LINKER_FLAGS  <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CMAKE_EXE_LINKER_FLAGS&#125;</span> -fPIC&quot;</span>)<br><span class="hljs-built_in">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CMAKE_SHARED_LINKER_FLAGS&#125;</span> -fPIC&quot;</span>)<br><span class="hljs-built_in">set</span>(CMAKE_STATIC_LINKER_FLAGS <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;CMAKE_STATIC_LINKER_FLAGS&#125;</span> -fPIC&quot;</span>)<br>3 make parallel_buffer_pool_manager_test -j12<br></code></pre></td></tr></table></figure>
<p>段错误实际上是最好调试的（我gbd就会几个命令）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb./test/parallel_buffer_pool_manager_test  <br>r <span class="hljs-comment"># 执行</span><br>bt <span class="hljs-comment"># 查看调用栈</span><br>frame n <span class="hljs-comment"># 转到栈n的上下文</span><br>p var <span class="hljs-comment"># 输出变量值 </span><br></code></pre></td></tr></table></figure>
<p>通过以上这几个步骤我那个&#x3D;误写成+&#x3D;的错误就被找出来了。而FlushPage不小心写成FetchPage的错误就非常难找的（vscode自动补全）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//parallel_buffer_pool_manager_test.cpp</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>  <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-literal">true</span>, bpm-&gt;<span class="hljs-built_in">UnpinPage</span>(i, <span class="hljs-literal">true</span>));<br>  bpm-&gt;<span class="hljs-built_in">FlushPage</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>  <span class="hljs-built_in">EXPECT_NE</span>(<span class="hljs-literal">nullptr</span>, bpm-&gt;<span class="hljs-built_in">NewPage</span>(&amp;page_id_temp));<br>  bpm-&gt;<span class="hljs-built_in">UnpinPage</span>(page_id_temp, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试代码段的大意为：通过5次UnpinPage操作，应该多了5个可被淘汰的页，也就能新建5个新页。<br>运行测试代码时，EXPECT_NE(nullptr, bpm-&gt;NewPage(&amp;page_id_temp));一行报错。在此打断点（b parallel_buffer_pool_manager_test.cpp：73）后发现仅仅第一次时报错，后续4次成功。当然这是74行再次调用UnpinPage函数的结果。这也就是说第一个for循环并没有成功将5页放入replacer中，所以我错误地一直研究UnpinPage函数的调用路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb./test/parallel_buffer_pool_manager_test  <br>b parallel_buffer_pool_manager_test.cpp：73<br>r <span class="hljs-comment"># 执行</span><br>n <span class="hljs-comment"># 下一步，但不进入函数</span><br>s <span class="hljs-comment"># 下一步，进入函数</span><br>c <span class="hljs-comment"># 下一个断点</span><br></code></pre></td></tr></table></figure>
<p>在设置许多个printf语句，通过n或s进入UnpinPage函数内部执行路径，一直没有发现问题。而后直接在测试代码处查看UnpinPage是否改变了相应replacer的size，没想到居然改变了，而执行完bpm-&gt;FlushPage(i);<br>后又变成0了，我就知道是FlushPage函数的问题，稍微检查一下后即发现是拼写错误。流程如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb ./test/parallel_buffer_pool_manager_test <br>b parallel_buffer_pool_manager_test.cpp:69<br>r<br><span class="hljs-comment">#69          EXPECT_EQ(true, bpm-&gt;UnpinPage(i, true));</span><br>p bpm-&gt;instances_ [0]-&gt;replacer_ -&gt;Size()<br><span class="hljs-comment">#0</span><br>n<br><span class="hljs-comment">#70          bpm-&gt;FlushPage(i);</span><br>p bpm-&gt;instances_ [0]-&gt;replacer_ -&gt;Size()<br><span class="hljs-comment">#1</span><br>n<br><span class="hljs-comment">#68        for (int i = 0; i &lt; 5; ++i) &#123;</span><br>p bpm-&gt;instances_ [0]-&gt;replacer_ -&gt;Size()<br><span class="hljs-comment">#0</span><br></code></pre></td></tr></table></figure>
<p>这也算一次比较奇葩的经历。在debug这个之后，编译器提示内存泄漏，显示我在构造函数申请的空间没有释放，这是因为我析构函数刚开始只有delete[] instances_;,我以为这样能顺带把指针数组里指向的对象也释放掉呢。<mark>实际上用了多少次new，就要使用多少次delete。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ParallelBufferPoolManager::<span class="hljs-built_in">ParallelBufferPoolManager</span>(<span class="hljs-type">size_t</span> num_instances, <span class="hljs-type">size_t</span> pool_size, DiskManager *disk_manager,<br>                                                     LogManager *log_manager) &#123;<br>  <span class="hljs-comment">// Allocate and create individual BufferPoolManagerInstances</span><br>  num_instances_ = num_instances;<br>  pool_size_ = pool_size;<br>  start_index_ = <span class="hljs-number">0</span>;<br>  instances_ = <span class="hljs-keyword">new</span> BufferPoolManagerInstance *[num_instances];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instances; i++) &#123;<br>    instances_[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferPoolManagerInstance</span>(pool_size, num_instances, i, disk_manager, log_manager);<br>  &#125;<br>&#125;<br>ParallelBufferPoolManager::~<span class="hljs-built_in">ParallelBufferPoolManager</span>() &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instances_; i++) &#123;  <span class="hljs-comment">//释放指针所指对象空间</span><br>    <span class="hljs-keyword">delete</span> instances_[i];<br>  &#125;<br>  <span class="hljs-keyword">delete</span>[] instances_;  <span class="hljs-comment">//释放指针空间</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Gradescope测试"><a href="#Gradescope测试" class="headerlink" title="Gradescope测试"></a>Gradescope测试</h4><p>在知道如何注册Gradescope后， 我将我的代码提交到Gradescope，结果只得了85分。分别是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test_build显示的报错信息</span><br>#RoundRobinNewPage<br>Expected equality of these values:<br>  unpin_page + num_instances<br>    Which is: <span class="hljs-number">11</span><br>  page_id_temp<br>    Which is: <span class="hljs-number">13</span><br>起始索引问题<br>#test_memory_safety<br>Timeout Happened during valgrind<br>执行时间太长？<br>#ParallelBufferPoolManager_HardTestD<br>由于我的FlushPgImp中只对脏页进行写入，而该测试中并未将需写回的页设置为脏页，故使得预期数据不一致<br>page = bpm-&gt;<span class="hljs-built_in">NewPage</span>(&amp;temp_page_id, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">while</span> (page == <span class="hljs-literal">nullptr</span>) &#123;<br>  page = bpm-&gt;<span class="hljs-built_in">NewPage</span>(&amp;temp_page_id, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><span class="hljs-built_in">EXPECT_NE</span>(<span class="hljs-literal">nullptr</span>, page);<br><span class="hljs-built_in">ASSERT_NE</span>(<span class="hljs-literal">nullptr</span>, page);<br><span class="hljs-built_in">strcpy</span>(page-&gt;<span class="hljs-built_in">GetData</span>(), std::<span class="hljs-built_in">to_string</span>(temp_page_id).<span class="hljs-built_in">c_str</span>());  <span class="hljs-comment">// NOLINT</span><br><span class="hljs-comment">// FLush page instead of unpining with true</span><br><span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">1</span>, bpm-&gt;<span class="hljs-built_in">FlushPage</span>(temp_page_id, <span class="hljs-literal">nullptr</span>));<br><span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">1</span>, bpm-&gt;<span class="hljs-built_in">UnpinPage</span>(temp_page_id, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>));<br></code></pre></td></tr></table></figure>
<p>3个测试没通过<br>如果编译通过但测试一个没过有可能就是死锁了。<mark>修改代码后先通过本地样例，再进行格式调整，再进行提交</mark><br>1 我认为LRUReplacer中的容量是没什么用的，因为replacer_和pages_的大小一样，不可能超过<br>2 为减少执行时间，将LRUReplacer的实现从普通的链表变成链表+map（降低时间复杂度），但我当时为了通过RoundRobinNewPage，map的value是pair，bool表示该项是否存在，实际上这是没必要的，用iterator当value就可以了<br>（我后面又改回去了，这种形式可读性不强，还是迭代器为value值更好看）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// using IteratorPair = std::pair&lt;bool, std::list&lt;frame_id_t&gt;::iterator&gt;;</span><br><span class="hljs-comment">// std::unordered_map&lt;frame_id_t, IteratorPair&gt; map_;</span><br>std::mutex lock_;<br>std::list&lt;<span class="hljs-type">frame_id_t</span>&gt; data_;<br>std::unordered_map&lt;<span class="hljs-type">frame_id_t</span>, std::list&lt;<span class="hljs-type">frame_id_t</span>&gt;::iterator&gt; map_;<br><span class="hljs-comment">// size_t capacity_;</span><br></code></pre></td></tr></table></figure>

<p>3 DeletePgImp中同时把replacer里的页删去（好像没影响）</p>
<p>4 NewPgImp中创建新页后立即写入磁盘，防止被淘汰后找不到页号（我没改也过了全部测试）</p>
<p>5 ParallelBufferPoolManager::NewPgImp中的起始索引，我改了半天，最后发现调换个位置就成了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">size_t</span> index = start_index_;<br> <span class="hljs-comment">// printf(&quot;index is %ld\n&quot;,index);</span><br> <span class="hljs-keyword">do</span> &#123;<br>   page = instances_[index]-&gt;<span class="hljs-built_in">NewPage</span>(page_id);<br>   <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>   	 <span class="hljs-comment">// 原先在这增加起始索引</span><br>     <span class="hljs-keyword">break</span>;<br>   &#125;<br>   index = (index + <span class="hljs-number">1</span>) % num_instances_;<br> &#125; <span class="hljs-keyword">while</span> (index != start_index_);<br> <span class="hljs-comment">// 改到这里</span><br> start_index_ = (start_index_ + <span class="hljs-number">1</span>) % num_instances_;<br></code></pre></td></tr></table></figure>
<h4 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h4><p>看完Effective系列的书后，回过头来修改之前写过的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">push_back</span>()改成 <span class="hljs-built_in">emplace_back</span>()<br><br>当给map添加一个元素时，我们断定insert比<span class="hljs-keyword">operator</span>[]好；当更新已经在map里的元素值时<span class="hljs-keyword">operator</span>[]更好<br><br>测试存在性时，如果是map，count方法好，multimap的话，find好<br><br>在我写代码时，<span class="hljs-number">80</span>%的bug来自于<span class="hljs-keyword">while</span>循环最后忘了修改迭代器的值，<br>所以我觉得<span class="hljs-keyword">for</span>循环比<span class="hljs-keyword">while</span>循环更好一点，这样就不会忘了修改迭代器。<br><span class="hljs-comment">// while循环</span><br><span class="hljs-keyword">auto</span> iter = page_table_.<span class="hljs-built_in">cbegin</span>();<br><span class="hljs-keyword">while</span> (iter != page_table_.<span class="hljs-built_in">cend</span>()) &#123;<br>  page_id = iter-&gt;first;<br>  frame_id = page_table_[page_id];<br>  <span class="hljs-keyword">if</span> (pages_[frame_id].<span class="hljs-built_in">IsDirty</span>()) &#123;<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page_id, pages_[frame_id].data_);<br>    pages_[frame_id].is_dirty_ = <span class="hljs-literal">false</span>;<br>  &#125;<br>  ++iter;<br>&#125;<br><span class="hljs-comment">// for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = page_table_.<span class="hljs-built_in">cbegin</span>(); iter != page_table_.<span class="hljs-built_in">cend</span>(); ++iter) &#123;<br>  page_id = iter-&gt;first;<br>  frame_id = page_table_[page_id];<br>  <span class="hljs-keyword">if</span> (pages_[frame_id].<span class="hljs-built_in">IsDirty</span>()) &#123;<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page_id, pages_[frame_id].data_);<br>    pages_[frame_id].is_dirty_ = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 范围for语句</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;item : page_table_) &#123;<br>  page_id = item.first;<br>  frame_id = page_table_[page_id];<br>  <span class="hljs-keyword">if</span> (pages_[frame_id].<span class="hljs-built_in">IsDirty</span>()) &#123;<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page_id, pages_[frame_id].data_);<br>    pages_[frame_id].is_dirty_ = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br>迭代器用前自增效率更高一点<br>前自增运算符改变了对象的状态并返回对象改变后的状态，不需要创建临时对象。下面是前自增运算符的例子：<br>MyOwnClass&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>	++meOwnField;<br>	<span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br>后自增运算符也改变了对象的状态但是返回的是对象改变前的状态，并且需要创建一个临时对象。下面是后自增运算符重载的例子：<br>MyOwnClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br>	MyOWnCLass tmp = *<span class="hljs-keyword">this</span>;<br>	++(*<span class="hljs-keyword">this</span>);<br>	<span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Step</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Step</span>(<span class="hljs-type">int</span> num) &#123;<span class="hljs-keyword">this</span>-&gt;num = num;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getStep</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> num;&#125;<br>    Step&amp; <span class="hljs-keyword">operator</span>++();   <span class="hljs-comment">//重载前自增运算符</span><br>    Step <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">//重载后自增运算符</span><br>&#125;;<br> <br>Step&amp; Step::<span class="hljs-keyword">operator</span>++()&#123;<br>    num++;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br> <br>Step Step::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)&#123;<br>    Step temp = *<span class="hljs-keyword">this</span>;<br>    ++ *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br>DeletePgImp函数需调用DeallocatePage函数，不用写回磁盘<br>虽然DeallocatePage函数并没有实现<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Deallocate a page on disk.</span><br><span class="hljs-comment"> * @param page_id id of the page to deallocate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DeallocatePage</span><span class="hljs-params">(__attribute__((unused)) <span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// This is a no-nop right now without a more complex data structure to track deallocated pages</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><mark>迭代器记得增加</mark></p>
<p>测试通过截图<br><img src="https://img-blog.csdnimg.cn/a9ec067277fb403e8db6869ba26a0c37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="测试通过截图"></p>
<blockquote>
<p><strong>attribute</strong><br>GNU C 的一大特色就是__attribute__ 机制。attribute 可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。<br>其位置约束为： 放于声明的尾部“;” 之前<br>attribute 书写特征为: attribute 前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的__attribute__ 参数。<br>attribute 语法格式为: attribute ((attribute-list))<br>attribute((unused)) 其作用是即使没有使用这个函数，编译器也不警告。</p>
</blockquote>
<h3 id="hash-index"><a href="#hash-index" class="headerlink" title="hash index"></a>hash index</h3><p>为方便起见，用directory代表HashTableDirectoryPage类，用bucket代表HashTableBucketPage，用hash table表示ExtendibleHashTable类<br>由于刚开始没看啥是可扩展的动态哈希，一直没看懂第一部分的代码在讲啥，特别是VerifyIntegrity 函数的三个限制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1) All LD &lt;= GD.<br><br>(2) Each bucket has precisely 2^(GD - LD) pointers pointing to it.<br><br>(3) The LD is the same at each index with the same bucket_page_id<br></code></pre></td></tr></table></figure>
<p>在了解可扩展动态哈希是啥后才明白这3个限制的含义<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gatsby123/p/10613160.html">参考博客</a>，<mark>所以一定要充分理解动态哈希的过程！！！</mark>，可以阅读《数据密集型应用设计》存储与检索一章<br><img src="https://img-blog.csdnimg.cn/img_convert/4e71212b44eb422a02054ddfe73858e8.png#pic_center" srcset="/img/loading.gif" lazyload><br>但我还是没怎么懂为啥local depth和global depth要用不同类型的变量存储。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint32_t</span> global_depth_&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">uint8_t</span> local_depths_[DIRECTORY_ARRAY_SIZE];<br></code></pre></td></tr></table></figure>

<p>更新：</p>
<blockquote>
<p>《数据库系统概念》11.7 动态散列：<br>当数据库增大或缩小时，可扩充散列（extendable hash）可以通过桶的分裂或合并来适应数据库大小的变化。这样就可以保持空间的使用效率。此外，由于重组每次仅作用于一个桶，因此所带来的性能开销较低，可以接受。<br>在更新操作时，如果插入的桶已满，系统必须分裂这个桶并将该桶中现有记录和新记录一起进行重新分配。而后系统再次尝试新记录。通常该尝试会成功。但是，如果桶中所有记录与新插入的记录具有相同的散列值前缀，该桶就必须再次分裂，这是因为所有记录与新记录再次被分配到同一个桶中。</p>
</blockquote>
<p>我写完全部代码很久后才知道原来15445还有教科书，代码里也没对上述情况进行处理，也懒得改了。</p>
<h4 id="directory类"><a href="#directory类" class="headerlink" title="directory类"></a>directory类</h4><p>测试第一部分的代码是test&#x2F;container&#x2F;hash_table_page_test.cpp，我觉得<mark>提前阅读一遍测试代码</mark>是很有帮助的，可以在测试代码中看类的使用。而且建议在写第一部分的时候就将整个实验介绍看完，有些内容在后面才介绍。第一部分的代码实现过于简单，以至于我一直觉得实现的有问题（CanShrink  GetSplitImageIndex两个可选函数未实现，留给第二部分实现）。</p>
<p>CanShrink： 判断是否可以收缩全局深度，即判断是否所有局部深度都小于全局深度<br>GetSplitImageIndex：当一个桶为空需要合并时，寻找与其对应的桶的索引，即将索引最高位取反（并不准确，应该是局部深度的最高位）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::GetSplitImageIndex</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> bucket_idx)</span> </span>&#123;  <span class="hljs-comment">// 得到与该桶对应的桶，即将该桶最高位置反</span><br>  <span class="hljs-type">uint32_t</span> local_depth = <span class="hljs-built_in">GetLocalDepth</span>(bucket_idx);<br>  <span class="hljs-type">uint32_t</span> local_mask = <span class="hljs-built_in">GetLocalDepthMask</span>(bucket_idx);<br>  <span class="hljs-keyword">if</span> (local_depth == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (bucket_idx ^ (<span class="hljs-number">1</span> &lt;&lt; (local_depth - <span class="hljs-number">1</span>))) &amp; local_mask;<br>  <span class="hljs-comment">// 假设只有两个桶 0 1，深度皆为1，则0 ^ (1&lt;&lt;(1-1)) = 1</span><br>  <span class="hljs-comment">// 假设桶11深度为1,，则其实际上用到的位为1，对应的桶即为0  11 ^ 1 &amp; 1 = 0</span><br>  <span class="hljs-comment">// 但实际上返回10也无所谓，因为二者深度相等才进行合并操作</span><br>  <span class="hljs-comment">// 当只有一个桶时返回本身</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="bucket类"><a href="#bucket类" class="headerlink" title="bucket类"></a>bucket类</h4><p>array_[0]为零长数组，其大小为BUCKET_ARRAY_SIZE</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MappingType std::pair<span class="hljs-string">&lt;KeyType, ValueType&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUCKET_ARRAY_SIZE (4 * PAGE_SIZE / (4 * sizeof(MappingType) + 1))</span><br></code></pre></td></tr></table></figure>
<p>关于零长数组的介绍可看这篇博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/gatieme/article/details/64131322">blog</a>，另外cmp比较类相等时返回0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntComparator</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> lhs, <span class="hljs-type">const</span> <span class="hljs-type">int</span> rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lhs &lt; rhs) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rhs &lt; lhs) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>occupied_成员</strong>表示数组该位是否被使用过，可用来提前结束循环。假设顺序寻找数组中的元素，若occupied_[i]为0代表后面没元素了，可以中止寻找了。<br><strong>readable_成员</strong>表示数组该位当前是否存在元素。当需要删除某个元素时，将readable_置为0，occupied_不变。</p>
<p><mark>将数组类型设置为unsigned char可以避免很多问题</mark></p>
<h4 id="实现提示"><a href="#实现提示" class="headerlink" title="实现提示"></a>实现提示</h4><p>Insert方法首先需要遍历数组，看是否存在元素与插入元素一致，而后再寻找插入位置，插入该元素。可以将寻找相同元素和寻找插入位置两件事在一次遍历时完成。</p>
<p><mark>巨坑的点</mark><br>在我通过全部本地测试，将代码上传到gradescope测试时，开始没啥问题，看测试输出就可以知道哪些方面没有考虑到，在代码到70分时，我无意间改了一小部分，gradescope运行40分钟未出结果，显示运行超时<br>Your submission timed out. It took longer than 2400 seconds to run.<br>在我后面排查时我发现原因是一个很小的改动（if 改成 else if）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsReadable</span>(i) &amp;&amp; <span class="hljs-built_in">cmp</span>(array_[i].first, key) == <span class="hljs-number">0</span> &amp;&amp; array_[i].second == value) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsReadable</span>(i)) &#123;<br>  <span class="hljs-keyword">if</span> (insert_index == bucket_array_size) &#123;<br>    insert_index = i;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsOccupied</span>(i)) &#123;  <span class="hljs-comment">// 结束寻找</span><br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br>改成<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsReadable</span>(i) &amp;&amp; <span class="hljs-built_in">cmp</span>(array_[i].first, key) == <span class="hljs-number">0</span> &amp;&amp; array_[i].second == value) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsReadable</span>(i)) &#123;<br> <span class="hljs-keyword">if</span> (insert_index == bucket_array_size) &#123;<br>   insert_index = i;<br> &#125;<br> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsOccupied</span>(i)) &#123;  <span class="hljs-comment">// 结束寻找</span><br>   <span class="hljs-keyword">break</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在想来有点手贱，但这个改动对代码的执行流程没有任何影响，我一直想不通为什么会超时，在将所有锁都去掉后提交还是显示超时，我认为代码执行超时要么是死锁，要么是死循环，但我把在代码看麻了也没看出哪里出现了问题，而后我放弃hash index，先写后面的部分。而后我在虚拟机里运行这些代码，发现这部分代码竟然报错，也就是前面的readability-simplify-boolean-expr错误<br><img src="https://img-blog.csdnimg.cn/73a9e20765f347d282a2c1f7dd8fa85d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_15,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br><mark>但我之前进行语法检查时并没有报错！！！</mark>，所以超时有可能有3个原因：死锁，死循环，<mark>语法风格问题</mark>，所以说不能太相信语法检查，可以自己检查一下。。。。（因为这个我提交了十几次，气！）</p>
<p>IsOccupied等方法对<strong>位</strong>进行操作，IsFull NumReadable等方法对<strong>数</strong>进行操作</p>
<p>NumReadable方法可以用 n &amp; n-1 方法统计数字n中1的数目。<br>IsFull 需要对最后一个数的部分位进行检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HASH_TABLE_BUCKET_TYPE::SetUnreadable</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> bucket_idx)</span> </span>&#123;<br>  <span class="hljs-type">uint32_t</span> index = bucket_idx / <span class="hljs-number">8</span>;<br>  <span class="hljs-type">uint32_t</span> offset = bucket_idx % <span class="hljs-number">8</span>;<br>  readable_[index] &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; offset);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HASH_TABLE_BUCKET_TYPE::IsFull</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">uint32_t</span> exact_div_size = BUCKET_ARRAY_SIZE / <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; exact_div_size; i++) &#123;<br>    <span class="hljs-keyword">if</span> (readable_[i] != <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">0xff</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">uint32_t</span> rest = BUCKET_ARRAY_SIZE - BUCKET_ARRAY_SIZE / <span class="hljs-number">8</span> * <span class="hljs-number">8</span>;<br>  <span class="hljs-comment">// 在这里我觉得BUCKET_ARRAY_SIZE / 8更好，但check-clang-tidy会报错，故使用(BUCKET_ARRAY_SIZE - 1) / 8</span><br>  <span class="hljs-comment">// (rest=0时数组越界) check-clang-tidy报redundant boolean literal in conditional return statement错误,只能写成一行了</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    if (rest != 0 &amp;&amp; readable_[(BUCKET_ARRAY_SIZE - 1) / 8] != static_cast&lt;char&gt;((1 &lt;&lt; rest) - 1)) &#123;</span><br><span class="hljs-comment">    return false;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  return true;</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">return</span> !(rest != <span class="hljs-number">0</span> &amp;&amp; readable_[(BUCKET_ARRAY_SIZE - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span>] != <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;((<span class="hljs-number">1</span> &lt;&lt; rest) - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不得不说，语法风格检查有时候挺鸡肋的。</p>
<h4 id="hash-table类"><a href="#hash-table类" class="headerlink" title="hash table类"></a>hash table类</h4><p>在编写这部分的代码时，请记住以下几个要点</p>
<ol>
<li>不能单独增加某一个local depth或bucket_page_ids，需要进行遍历将属于同一个page id的local depth bucket_page_ids全部改变</li>
<li>用完页时需要及时释放，当遇到条件分支时，检查是否所有分支都正常释放了</li>
<li>桶分裂时按全局深度是否改变两种情况分</li>
<li>合并时注意循环合并情况</li>
</ol>
<p> <strong>递归合并的说明：</strong><br> 合并的条件有3个，桶为空，局部深度大于0，对应桶的深度一致。<br> 当对应桶的深度不一致时，这个桶应该什么时候合并呢？例如00 10对应一个桶，01 11对应两个桶，当00 10的桶为空时，其另一半的桶深度与其不一致。那当01 11两桶合并之后，也应该将00 10的桶合并起来。推广便知，这是一个循环的过程（gradescope只测试了单层）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (ret &amp;&amp; bucket_page-&gt;<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>  <span class="hljs-comment">// printf(&quot;start merge\n&quot;);</span><br>  <span class="hljs-built_in">Merge</span>(transaction, key, value);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">ExtraMerge</span>(transaction, key, value)) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>难点就是桶分裂与桶合并两个函数，其他的注意使用什么锁即可，table_latch锁住目录，(bucket_page)-&gt;WLatch锁住bucket。</p>
<p><mark>我认为在table_latch使用写锁时，bucket不用进行加锁，但测试跑不过（一直没出结果，应该是G了），所以还是加上吧，如有懂的望请告知</mark><br>当table_latch使用写锁时，应该只存在一个进程访问，那桶加锁不加锁不是没啥影响吗？<br>更新：我的问题，锁顺序问题导致死锁</p>
<p><strong>分裂的大致流程如下：</strong></p>
<pre><code class="hljs">旧桶指分裂前索引指向的桶
新桶指申请的新桶
将所有仍指向旧桶的位置深度加一
如果不影响目录大小：
    将现在指向新桶的位置设置新的page id，深度加一
如果影响目录大小：
    目录变成之前的两倍，即上半部与下半部
    下半部除新桶以外，与上半部完全一致，新桶设置新的page id
     这里需要对下半部的所有位置进行处理
删除旧桶中本该在新桶的元素，并将其插入在新桶中
进行正常的插入操作
</code></pre>
<p><strong>合并的大致流程如下：</strong></p>
<pre><code class="hljs">检查是否可以发生合并
将所有指向空桶的位置都指向对应桶
删除该桶（提前unpin）
将所有指向对应桶的位置深度减一
看是否能降低全局深度
进行额外的合并
</code></pre>
<p>合并与分裂需要非常的细心，可以使用后面的测试用例判断执行流程是否符合预期，加油！</p>
<p>测试通过截图：<br><img src="https://img-blog.csdnimg.cn/d4584adec9154753914b45f26fb09d4d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br>排名不高，懒得优化了，这部分代码看麻了。。。<br><img src="https://img-blog.csdnimg.cn/1caa2864d47d45e391a1fca385f0239b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br><strong>怎么哪里都有嘉心糖捏？</strong></p>
<p><strong>其他：</strong><br>我认为将目录页缓存起来能极大提高性能，避免一次一次访问目录页，但测试代码的逻辑不允许，在析构函数中unpin page会报错（此时已经被delete）</p>
<p>warning “will be initialized after [-Wreorder]<br>构造函数时，初始化成员变量的顺序要与类声明中的变量顺序相对应，若不对应，则出现如题错误。解决方法就是按照顺序进行初始化。</p>
<p>在处理分裂逻辑时，写过一个这样的代码，我想通过提前申请桶的写锁的方法减小锁的影响范围，但一直死锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SplitInsert：<br>table_latch_.<span class="hljs-built_in">WLock</span>();<br>处理目录相关逻辑<br><span class="hljs-comment">// 申请新桶旧桶的写锁</span><br><span class="hljs-built_in">reinterpret_cast</span>&lt;Page *&gt;(old_bucket_page)-&gt;<span class="hljs-built_in">WLatch</span>();<br><span class="hljs-built_in">reinterpret_cast</span>&lt;Page *&gt;(new_bucket_page)-&gt;<span class="hljs-built_in">WLatch</span>();<br>table_latch_.<span class="hljs-built_in">WUnlock</span>();<br><span class="hljs-comment">// 对目录的操作完成，持有新桶旧桶的写锁后改用读锁，迁移桶内数据</span><br>table_latch_.<span class="hljs-built_in">RLock</span>();<br><span class="hljs-built_in">reinterpret_cast</span>&lt;Page *&gt;(old_bucket_page)-&gt;<span class="hljs-built_in">WUnlatch</span>();<br><span class="hljs-built_in">reinterpret_cast</span>&lt;Page *&gt;(new_bucket_page)-&gt;<span class="hljs-built_in">WUnlatch</span>();<br>table_latch_.<span class="hljs-built_in">RUnlock</span>();<br></code></pre></td></tr></table></figure>

<p>后面才想明白死锁的原因：<strong>多个线程同时执行SplitInsert函数，线程1持有WLock请求WLatch，线程2持有WLatch请求RLock。</strong><br>我一般判断是否发生死锁都与其他函数进行比较，却忽略了相同函数执行时带来的死锁问题。<br>所以说加锁解锁不对称的顺序很容易造成死锁问题。</p>
<h4 id="自己写的测试用例及说明"><a href="#自己写的测试用例及说明" class="headerlink" title="自己写的测试用例及说明"></a>自己写的测试用例及说明</h4><p>在遇到之前提到的超时情况时，由于等gradescope出结果太慢（提交一次20-40分钟），我便产生了自己写测试用例的想法，刚开始想写并发的插入删除，但写完之后发现并不能测出什么东西来，并发时顺序很难控制，而且后面想了想，只要加锁解锁正确，并发访问与普通访问也没啥区别，而加锁的部分也不太复杂，所以应该将重点放在普通的访问上。<br>以下是我写的两个测试用例，<mark>主要是检查分裂合并是否合乎预期，以及是否正确释放页</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">只测试两个桶</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">TEST</span>(HashTableTest, MySplitShrinkTest1) &#123;<br>  <span class="hljs-keyword">auto</span> *disk_manager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DiskManager</span>(<span class="hljs-string">&quot;test.db&quot;</span>);<br>  <span class="hljs-keyword">auto</span> *bpm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferPoolManagerInstance</span>(<span class="hljs-number">50</span>, disk_manager);<br>  <span class="hljs-function">ExtendibleHashTable&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, IntComparator&gt; <span class="hljs-title">ht</span><span class="hljs-params">(<span class="hljs-string">&quot;blah&quot;</span>, bpm, IntComparator(), HashFunction&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;block size is: %ld\n&quot;</span>, (<span class="hljs-number">4</span> * PAGE_SIZE / (<span class="hljs-number">4</span> * <span class="hljs-built_in">sizeof</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;) + <span class="hljs-number">1</span>)));  <span class="hljs-comment">// 桶容量</span><br>  <span class="hljs-comment">// 插入496个值</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">496</span>; i++) &#123;<br>    ht.<span class="hljs-built_in">Insert</span>(<span class="hljs-literal">nullptr</span>, i, i);<br>  &#125;<br>  ht.<span class="hljs-built_in">PrintDir</span>();                            <span class="hljs-comment">// 输出目录信息</span><br>  ht.<span class="hljs-built_in">Insert</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">496</span>, <span class="hljs-number">496</span>);             <span class="hljs-comment">// 桶分裂</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(bpm-&gt;<span class="hljs-built_in">GetOccupiedPageNum</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 无论何时，被占用的页都应该为0</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(ht.<span class="hljs-built_in">GetGlobalDepth</span>(), <span class="hljs-number">1</span>);<br>  ht.<span class="hljs-built_in">PrintDir</span>();<br>  ht.<span class="hljs-built_in">RemoveAllItem</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 删除索引1对应的桶的所有项</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(bpm-&gt;<span class="hljs-built_in">GetOccupiedPageNum</span>(), <span class="hljs-number">0</span>);<br>  ht.<span class="hljs-built_in">PrintDir</span>();<br>  ht.<span class="hljs-built_in">RemoveAllItem</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 删除索引0对应的桶的所有项</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(bpm-&gt;<span class="hljs-built_in">GetOccupiedPageNum</span>(), <span class="hljs-number">0</span>);<br>  ht.<span class="hljs-built_in">PrintDir</span>();<br><br>  disk_manager-&gt;<span class="hljs-built_in">ShutDown</span>();<br>  <span class="hljs-built_in">remove</span>(<span class="hljs-string">&quot;test.db&quot;</span>);<br>  <span class="hljs-keyword">delete</span> disk_manager;<br>  <span class="hljs-keyword">delete</span> bpm;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">测试4个桶</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">TEST</span>(HashTableTest, MySplitShrinkTest2) &#123;<br>  <span class="hljs-keyword">auto</span> *disk_manager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DiskManager</span>(<span class="hljs-string">&quot;test.db&quot;</span>);<br>  <span class="hljs-keyword">auto</span> *bpm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferPoolManagerInstance</span>(<span class="hljs-number">50</span>, disk_manager);<br>  <span class="hljs-function">ExtendibleHashTable&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, IntComparator&gt; <span class="hljs-title">ht</span><span class="hljs-params">(<span class="hljs-string">&quot;blah&quot;</span>, bpm, IntComparator(), HashFunction&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;block size is: %ld\n&quot;</span>, (<span class="hljs-number">4</span> * PAGE_SIZE / (<span class="hljs-number">4</span> * <span class="hljs-built_in">sizeof</span>(std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;) + <span class="hljs-number">1</span>)));<br>  <span class="hljs-comment">// 插入1500个值</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1500</span>; i++) &#123;<br>    ht.<span class="hljs-built_in">Insert</span>(<span class="hljs-literal">nullptr</span>, i, i);<br>  &#125;<br>  ht.<span class="hljs-built_in">PrintDir</span>();<br>  ht.<span class="hljs-built_in">RemoveAllItem</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);		<span class="hljs-comment">// 删除索引0对应的桶的所有项</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(bpm-&gt;<span class="hljs-built_in">GetOccupiedPageNum</span>(), <span class="hljs-number">0</span>);  <br>  ht.<span class="hljs-built_in">PrintDir</span>();<br>  ht.<span class="hljs-built_in">RemoveAllItem</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);		<span class="hljs-comment">// 再次删除索引0对应的桶的所有项</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(bpm-&gt;<span class="hljs-built_in">GetOccupiedPageNum</span>(), <span class="hljs-number">0</span>);  <br>  bpm-&gt;<span class="hljs-built_in">PrintExistPageId</span>();                  <span class="hljs-comment">// 输出缓冲池中页的状态</span><br>  ht.<span class="hljs-built_in">PrintDir</span>();<br>  ht.<span class="hljs-built_in">RemoveAllItem</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 删除索引1对应的桶的所有项，应该发生递归合并</span><br>  <span class="hljs-built_in">EXPECT_EQ</span>(ht.<span class="hljs-built_in">GetGlobalDepth</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">EXPECT_EQ</span>(bpm-&gt;<span class="hljs-built_in">GetOccupiedPageNum</span>(), <span class="hljs-number">0</span>);<br>  ht.<span class="hljs-built_in">PrintDir</span>();<br><br>  disk_manager-&gt;<span class="hljs-built_in">ShutDown</span>();<br>  <span class="hljs-built_in">remove</span>(<span class="hljs-string">&quot;test.db&quot;</span>);<br>  <span class="hljs-keyword">delete</span> disk_manager;<br>  <span class="hljs-keyword">delete</span> bpm;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="测试方法说明"><a href="#测试方法说明" class="headerlink" title="测试方法说明"></a>测试方法说明</h4><p>BufferPoolManagerInstance类设置了两个测试方法，分别输出被占用的页数以及缓冲池中页的状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">GetOccupiedPageNum</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> page_table_.<span class="hljs-built_in">size</span>() - replacer_-&gt;<span class="hljs-built_in">Size</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintExistPageId</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : page_table_) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page id is:%d pin count is %d\n&quot;</span>, item.first, pages_[item.second].pin_count_);<br>  &#125;<br>&#125;<br>page id is:<span class="hljs-number">4</span> pin count is <span class="hljs-number">0</span><br>page id is:<span class="hljs-number">3</span> pin count is <span class="hljs-number">0</span><br>page id is:<span class="hljs-number">2</span> pin count is <span class="hljs-number">0</span><br>page id is:<span class="hljs-number">0</span> pin count is <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>其中PrintDir方法输出内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 测试方法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HASH_TABLE_TYPE::PrintDir</span><span class="hljs-params">()</span> </span>&#123;<br>  table_latch_.<span class="hljs-built_in">RLock</span>();<br>  HashTableDirectoryPage *dir_page = <span class="hljs-built_in">FetchDirectoryPage</span>();<br>  <span class="hljs-type">uint32_t</span> dir_size = dir_page-&gt;<span class="hljs-built_in">Size</span>();<br><br>  dir_page-&gt;<span class="hljs-built_in">PrintDirectory</span>();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dir size is: %d\n&quot;</span>, dir_size);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> idx = <span class="hljs-number">0</span>; idx &lt; dir_size; idx++) &#123;<br>    <span class="hljs-keyword">auto</span> bucket_page_id = dir_page-&gt;<span class="hljs-built_in">GetBucketPageId</span>(idx);<br>    HASH_TABLE_BUCKET_TYPE *bucket_page = <span class="hljs-built_in">FetchBucketPage</span>(bucket_page_id);<br>    bucket_page-&gt;<span class="hljs-built_in">PrintBucket</span>();<br>    buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(bucket_page_id, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(directory_page_id_, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>));<br>  table_latch_.<span class="hljs-built_in">RUnlock</span>();<br>&#125;<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">139</span>:PrintDirectory] DEBUG - ======== <span class="hljs-built_in">DIRECTORY</span> (global_depth_: <span class="hljs-number">2</span>) ========<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">140</span>:PrintDirectory] DEBUG - | bucket_idx | page_id | local_depth |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">0</span>     |     <span class="hljs-number">3</span>     |     <span class="hljs-number">1</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">1</span>     |     <span class="hljs-number">4</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">2</span>     |     <span class="hljs-number">3</span>     |     <span class="hljs-number">1</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">3</span>     |     <span class="hljs-number">2</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">144</span>:PrintDirectory] DEBUG - ================ END DIRECTORY ================<br>dir size is: <span class="hljs-number">4</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">352</span>, Taken: <span class="hljs-number">0</span>, Free: <span class="hljs-number">352</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">335</span>, Taken: <span class="hljs-number">335</span>, Free: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">352</span>, Taken: <span class="hljs-number">0</span>, Free: <span class="hljs-number">352</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">496</span>, Taken: <span class="hljs-number">384</span>, Free: <span class="hljs-number">112</span><br></code></pre></td></tr></table></figure>
<p>最关键的便是RemoveAllItem方法，这个是将桶的所有元素全部删除，首先需要bucket类返回所有元素，然后对这些元素依次调用remove方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function">std::vector&lt;MappingType&gt; <span class="hljs-title">HASH_TABLE_BUCKET_TYPE::GetAllItem</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">uint32_t</span> bucket_size = BUCKET_ARRAY_SIZE;<br>  std::vector&lt;MappingType&gt; items;<br>  items.<span class="hljs-built_in">reserve</span>(bucket_size);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; bucket_size; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsReadable</span>(i)) &#123;<br>      items.<span class="hljs-built_in">emplace_back</span>(array_[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> items;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HASH_TABLE_TYPE::RemoveAllItem</span><span class="hljs-params">(Transaction *transaction, <span class="hljs-type">uint32_t</span> bucket_idx)</span> </span>&#123;<br>  table_latch_.<span class="hljs-built_in">RLock</span>();<br>  HashTableDirectoryPage *dir_page = <span class="hljs-built_in">FetchDirectoryPage</span>();<br>  <span class="hljs-keyword">auto</span> bucket_page_id = dir_page-&gt;<span class="hljs-built_in">GetBucketPageId</span>(bucket_idx);<br>  HASH_TABLE_BUCKET_TYPE *bucket_page = <span class="hljs-built_in">FetchBucketPage</span>(bucket_page_id);<br>  <span class="hljs-keyword">auto</span> items = bucket_page-&gt;<span class="hljs-built_in">GetAllItem</span>();<br>  buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(bucket_page_id, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>);<br>  table_latch_.<span class="hljs-built_in">RUnlock</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : items) &#123;<br>    <span class="hljs-built_in">Remove</span>(<span class="hljs-literal">nullptr</span>, item.first, item.second);<br>  &#125;<br><br>  buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(directory_page_id_, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>MySplitShrinkTest2的结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp">block size is: <span class="hljs-number">496</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">139</span>:PrintDirectory] DEBUG - ======== <span class="hljs-built_in">DIRECTORY</span> (global_depth_: <span class="hljs-number">2</span>) ========<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">140</span>:PrintDirectory] DEBUG - | bucket_idx | page_id | local_depth |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">0</span>     |     <span class="hljs-number">1</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">1</span>     |     <span class="hljs-number">4</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">2</span>     |     <span class="hljs-number">3</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">3</span>     |     <span class="hljs-number">2</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">144</span>:PrintDirectory] DEBUG - ================ END DIRECTORY ================<br>dir size is: <span class="hljs-number">4</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">496</span>, Taken: <span class="hljs-number">429</span>, Free: <span class="hljs-number">67</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">335</span>, Taken: <span class="hljs-number">335</span>, Free: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">352</span>, Taken: <span class="hljs-number">352</span>, Free: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">496</span>, Taken: <span class="hljs-number">384</span>, Free: <span class="hljs-number">112</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">139</span>:PrintDirectory] DEBUG - ======== <span class="hljs-built_in">DIRECTORY</span> (global_depth_: <span class="hljs-number">2</span>) ========<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">140</span>:PrintDirectory] DEBUG - | bucket_idx | page_id | local_depth |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">0</span>     |     <span class="hljs-number">3</span>     |     <span class="hljs-number">1</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">1</span>     |     <span class="hljs-number">4</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">2</span>     |     <span class="hljs-number">3</span>     |     <span class="hljs-number">1</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">3</span>     |     <span class="hljs-number">2</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">144</span>:PrintDirectory] DEBUG - ================ END DIRECTORY ================<br>dir size is: <span class="hljs-number">4</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">352</span>, Taken: <span class="hljs-number">352</span>, Free: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">335</span>, Taken: <span class="hljs-number">335</span>, Free: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">352</span>, Taken: <span class="hljs-number">352</span>, Free: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">496</span>, Taken: <span class="hljs-number">384</span>, Free: <span class="hljs-number">112</span><br>page id is:<span class="hljs-number">4</span> pin count is <span class="hljs-number">0</span><br>page id is:<span class="hljs-number">3</span> pin count is <span class="hljs-number">0</span><br>page id is:<span class="hljs-number">2</span> pin count is <span class="hljs-number">0</span><br>page id is:<span class="hljs-number">0</span> pin count is <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">139</span>:PrintDirectory] DEBUG - ======== <span class="hljs-built_in">DIRECTORY</span> (global_depth_: <span class="hljs-number">2</span>) ========<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">140</span>:PrintDirectory] DEBUG - | bucket_idx | page_id | local_depth |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">0</span>     |     <span class="hljs-number">3</span>     |     <span class="hljs-number">1</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">1</span>     |     <span class="hljs-number">4</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">2</span>     |     <span class="hljs-number">3</span>     |     <span class="hljs-number">1</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">3</span>     |     <span class="hljs-number">2</span>     |     <span class="hljs-number">2</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">144</span>:PrintDirectory] DEBUG - ================ END DIRECTORY ================<br>dir size is: <span class="hljs-number">4</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">352</span>, Taken: <span class="hljs-number">0</span>, Free: <span class="hljs-number">352</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">335</span>, Taken: <span class="hljs-number">335</span>, Free: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">352</span>, Taken: <span class="hljs-number">0</span>, Free: <span class="hljs-number">352</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">496</span>, Taken: <span class="hljs-number">384</span>, Free: <span class="hljs-number">112</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">139</span>:PrintDirectory] DEBUG - ======== <span class="hljs-built_in">DIRECTORY</span> (global_depth_: <span class="hljs-number">0</span>) ========<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">140</span>:PrintDirectory] DEBUG - | bucket_idx | page_id | local_depth |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">142</span>:PrintDirectory] DEBUG - |      <span class="hljs-number">0</span>     |     <span class="hljs-number">2</span>     |     <span class="hljs-number">0</span>     |<br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_directory_page.cpp:<span class="hljs-number">144</span>:PrintDirectory] DEBUG - ================ END DIRECTORY ================<br>dir size is: <span class="hljs-number">1</span><br><span class="hljs-number">2022</span><span class="hljs-number">-02</span><span class="hljs-number">-28</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span>:<span class="hljs-number">41</span> [root/code/CMU1445/vm/vm-CMU1445/bustub/src/storage/page/hash_table_bucket_page.cpp:<span class="hljs-number">205</span>:PrintBucket] INFO  - Bucket Capacity: <span class="hljs-number">496</span>, Size: <span class="hljs-number">496</span>, Taken: <span class="hljs-number">384</span>, Free: <span class="hljs-number">112</span><br></code></pre></td></tr></table></figure>

<h3 id="query-execution"><a href="#query-execution" class="headerlink" title="query execution"></a>query execution</h3><p>进行实验之前简单了解一下火山模型，并将lab3全文先看一遍，特别是SYSTEM CATALOG与INDEX UPDATES部分。代码的编写顺序依次是查询——》插入——》更新——》删除——》嵌套循环联接 ——》 哈希连接——》聚合——》有限——》唯一<br>问题最多的会是更新和嵌套循环联接部分，有许多细节。<br><img src="https://img-blog.csdnimg.cn/3bc68ac655e84be4a6b50e182d1b7669.png" srcset="/img/loading.gif" lazyload><br><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2021/notes/11-queryexecution1.pdf">Query Processing</a></p>
<p>完成实验最重要的便是仔细阅读TableInfo类，你一定会反复看这几个类成员的。IndexInfo类你会在debug的时候仔细看的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TableInfo</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new TableInfo instance.</span><br><span class="hljs-comment">   * @param schema The table schema</span><br><span class="hljs-comment">   * @param name The table name</span><br><span class="hljs-comment">   * @param table An owning pointer to the table heap</span><br><span class="hljs-comment">   * @param oid The unique OID for the table</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">TableInfo</span>(Schema schema, std::string name, std::unique_ptr&lt;TableHeap&gt; &amp;&amp;table, <span class="hljs-type">table_oid_t</span> oid)<br>      : schema_&#123;std::<span class="hljs-built_in">move</span>(schema)&#125;, name_&#123;std::<span class="hljs-built_in">move</span>(name)&#125;, table_&#123;std::<span class="hljs-built_in">move</span>(table)&#125;, oid_&#123;oid&#125; &#123;&#125;<br>  <span class="hljs-comment">/** The table schema */</span><br>  Schema schema_;<br>  <span class="hljs-comment">/** The table name */</span><br>  <span class="hljs-type">const</span> std::string name_;<br>  <span class="hljs-comment">/** An owning pointer to the table heap */</span><br>  std::unique_ptr&lt;TableHeap&gt; table_;<br>  <span class="hljs-comment">/** The table OID */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">table_oid_t</span> oid_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Schema</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Column&gt; &amp;columns)</span></span>;<br><br><span class="hljs-built_in">Column</span>(std::string column_name, TypeId type, <span class="hljs-type">const</span> AbstractExpression *expr = <span class="hljs-literal">nullptr</span>)<br><br><span class="hljs-built_in">Tuple</span>(std::vector&lt;Value&gt; values, <span class="hljs-type">const</span> Schema *schema);<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/209999b670214713a6dca6b0ef2c83f8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br>Schema类即表的第一行，也就是模式{colA，colB，colC，colD}，它由Column类组成，Column类即每一列的表头{colA}，<strong>你如何判断两列相同呢？</strong>。AbstractExpression类是构成列的表达式，这个可能有点绕，但你阅读完测试代码就懂了。你需要调用很多次这里面的Evaluatexxx方法。<br>TableHeap类即表实际的数据，有一系列元组Tuple构成，Tuple即每一行的数据{1，2, 3，4}，Tuple由Value类{1}组成，Value就是数据库中抽象的值，也就是说啥用没有！<mark>Tuple的操作很容易引起数组越界</mark>，所以你需要认真阅读Tuple部分的代码，确保自己真的理解参数的意义！<br><img src="https://img-blog.csdnimg.cn/c7657d703a044d28b2591945f4faea68.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="RID特别说明（更新）"><a href="#RID特别说明（更新）" class="headerlink" title="RID特别说明（更新）"></a>RID特别说明（更新）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Get the starting storage address of specific column</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">GetDataPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> Schema *schema, <span class="hljs-type">uint32_t</span> column_idx)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-type">bool</span> allocated_&#123;<span class="hljs-literal">false</span>&#125;;  <span class="hljs-comment">// is allocated?</span><br>  RID rid_&#123;&#125;;              <span class="hljs-comment">// if pointing to the table heap, the rid is valid</span><br>  <span class="hljs-type">uint32_t</span> size_&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">char</span> *data_&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RID</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">page_id_t</span> page_id_&#123;INVALID_PAGE_ID&#125;;<br>  <span class="hljs-type">uint32_t</span> slot_num_&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// logical offset from 0, 1...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在做lab4时才发现我对于RID的推论全是错的，我之前错误地把RID当做元组的唯一资源ID了，每一个元组都会有一个用来标识他们，但实际上RID只是代表元组在表中的位置而已，<strong>所以只有表元组才会RID</strong>！ 我一开始大方向就错了，虽然最终结果对了<br><mark>所以以下所有对RID的推导都没必要看，因为输出元组根本没有RID</mark></p>
<p>在把没用的RID计算去掉之后，排名竟然还降了，奇怪。<br>我觉得把变量名rid_改成location_更易于理解</p>
<h4 id="SEQUENTIAL-SCAN"><a href="#SEQUENTIAL-SCAN" class="headerlink" title="SEQUENTIAL SCAN"></a>SEQUENTIAL SCAN</h4><p>查询的逻辑比较简单，如果有约束，判断元组是否满足，没有约束直接返回。这部分的点在于以下几个问题？<br><mark>元组从table_schema到output_schema如何转换？ 元组模式转换有一成不变的方法吗？</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">GetColIdx</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;col_name)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; columns_.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">if</span> (columns_[i].<span class="hljs-built_in">GetName</span>() == col_name) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">UNREACHABLE</span>(<span class="hljs-string">&quot;Column does not exist&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/** @return the indices of non-inlined columns */</span><br><span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; &amp;<span class="hljs-title">GetUnlinedColumns</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> uninlined_columns_; &#125;<br><br><span class="hljs-function">Value <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> Schema *schema, <span class="hljs-type">uint32_t</span> column_idx)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure>
<p>我刚开始就是通过列名，列偏移量这种方式转换元组，但这存在一个隐含的约束是：源元组的模式必须是表元组，而不能是由执行器生成的元组，这是因为output_schema的偏移量都是相对表元组来说，如果用执行器使用子执行器的输出元组时，就会产生数组越界的问题。而列名是可以被更改的，所以最稳妥的办法便是使用模式中每一列的生成表达式生成Value，当然不同的模式转换使用不同的Evaluate方法。可以看AbstractExpression类的几个子类对Evaluatexxx方法的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Tuple中许多方法都是针对完整模式（table schema）而言的，对切割后的模式使用很容易发生数组越界</span><br><span class="hljs-comment">// 两模式中两列是一样的是很难判断的，因为列名可以改变，只能通过原始表的列序号，但其隐藏在ColumnValueExpression类中</span><br><span class="hljs-comment">// 故只能不同类型使用不同的Evaluate函数</span><br><span class="hljs-comment">// 这些转换函数的大体流程都一样，即使用输出元祖的模式调用Evaluatexxx方法，输出相应列的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqScanExecutor::TupleSchemaTranformUseEvaluate</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple *table_tuple, <span class="hljs-type">const</span> Schema *table_schema,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                     Tuple *dest_tuple, <span class="hljs-type">const</span> Schema *dest_schema)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> colums = dest_schema-&gt;<span class="hljs-built_in">GetColumns</span>();<br>  std::vector&lt;Value&gt; dest_value;<br>  dest_value.<span class="hljs-built_in">reserve</span>(colums.<span class="hljs-built_in">size</span>());<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;col : colums) &#123;<br>    dest_value.<span class="hljs-built_in">emplace_back</span>(col.<span class="hljs-built_in">GetExpr</span>()-&gt;<span class="hljs-built_in">Evaluate</span>(table_tuple, table_schema));<br>  &#125;<br><br>  *dest_tuple = <span class="hljs-built_in">Tuple</span>(dest_value, dest_schema);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然可以并不是都需要模式转换，如果模式相同就不需要了。以下通过偏移量和列名判断是否相同，我觉得也不算非常保险。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SeqScanExecutor::SchemaEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> Schema *table_schema, <span class="hljs-type">const</span> Schema *output_schema)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> table_colums = table_schema-&gt;<span class="hljs-built_in">GetColumns</span>();<br>  <span class="hljs-keyword">auto</span> output_colums = output_schema-&gt;<span class="hljs-built_in">GetColumns</span>();<br>  <span class="hljs-keyword">if</span> (table_colums.<span class="hljs-built_in">size</span>() != output_colums.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-type">int</span> col_size = table_colums.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">uint32_t</span> offset1;<br>  <span class="hljs-type">uint32_t</span> offset2;<br>  std::string name1;<br>  std::string name2;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; col_size; i++) &#123;<br>    offset1 = table_colums[i].<span class="hljs-built_in">GetOffset</span>();<br>    offset2 = output_colums[i].<span class="hljs-built_in">GetOffset</span>();<br>    name1 = table_colums[i].<span class="hljs-built_in">GetName</span>();<br>    name2 = output_colums[i].<span class="hljs-built_in">GetName</span>();<br>    <span class="hljs-keyword">if</span> (name1 != name2 || offset1 != offset2) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过这一个优化排名就提高了几十名。。。<br><img src="https://img-blog.csdnimg.cn/1c27c2241cb04f108bba302185f2f298.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="**加粗样式**"><br><img src="https://img-blog.csdnimg.cn/d1de2538cefb4ab1b914dc20e68abd04.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br><strong>又看到嘉心糖了捏！</strong></p>
<p>第二个问题便是此时next方法的RID应该哪个元组的RID，表元组还是输出元组？<br>按概念来说应该是输出元组的RID，但如果这个查询被当做更新的子执行器，那么它需要通过这个RID找到原先的表元组并更新。而且当我阅读SimpleDeleteTest代码时，发现其查询部分的输出模式与表模式不相同，但MarkDelete方法需要表元组的RID找到该元组并标记删除，也就是说，&#x3D;&#x3D;不论输出模式与表模式是否相同，RID都应该是表元组的RID，而不是输出元组的RID。&#x3D;&#x3D;</p>
<p>（更新：输出元组没有RID）</p>
<h4 id="INSERT-UPDATE-DELETE"><a href="#INSERT-UPDATE-DELETE" class="headerlink" title="INSERT &#x2F;  UPDATE &#x2F; DELETE"></a>INSERT &#x2F;  UPDATE &#x2F; DELETE</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">res = child_executor_-&gt;<span class="hljs-built_in">Next</span>(&amp;insert_tuple, &amp;insert_rid);<br>insert_rid = insert_tuple.<span class="hljs-built_in">GetRid</span>();  <span class="hljs-comment">// 查询计划返回的不是元组的RID，需自己计算RID</span><br><br>table_info_-&gt;table_-&gt;<span class="hljs-built_in">UpdateTuple</span>(update_tuple, child_rid, transaction);  <span class="hljs-comment">// 传入old rid</span><br><br><span class="hljs-keyword">if</span> (!delete_res) &#123;  <span class="hljs-comment">// 抛出异常，需要进行相应处理</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&quot;delete failed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这三个操作大致相同，没啥讲的，索引部分单独列出来讲。insert执行器调用子计划的next方法RID不是输出元组的RID，需要自己计算，不过用表元组的RID好像也没啥影响  （更新：insert方法不需要RID，调用InsertTuple方法后RID才被赋值）</p>
<p>update执行器提供了GenerateUpdatedTuple方法生成更新元组，需要注意的是UpdateTuple方法传入的是旧元组的RID（找到旧元组）。</p>
<p>delete执行器需要及时判断子执行器的结果，抛出异常，在ExecutionEngine类中处理</p>
<h4 id="NESTED-LOOP-JOIN-HASH-JOIN"><a href="#NESTED-LOOP-JOIN-HASH-JOIN" class="headerlink" title="NESTED LOOP JOIN &#x2F; HASH JOIN"></a>NESTED LOOP JOIN &#x2F; HASH JOIN</h4><p>这里模式转换使用EvaluateJoin方法，对于NESTED LOOP JOIN，必须严格按照Simple Nested Loop Join（SNLJ）算法实现，不要进行任何优化，gradescope有测试右半部扫描次数的（我觉得左半部右半部更直观一点，而不是内表外表）<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/81398139">参考博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 伪代码</span><br> <span class="hljs-keyword">for</span> (r in R) &#123;<br>     <span class="hljs-keyword">for</span> (s in S) &#123;<br>         <span class="hljs-keyword">if</span> (r satisfy condition s) &#123;<br>             output &lt;r, s&gt;;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/badbd192f7b14226a95140940ca55e75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HashJoinExecutor::Next</span><span class="hljs-params">(Tuple *tuple, RID *rid)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left_need_next_) &#123;  <span class="hljs-comment">// 第一次next，找到第一个在hash表的左半部元组</span><br>	...<br>    left_need_next_ = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array_index_ &gt;= hash_table_[left_key_].<span class="hljs-built_in">size</span>()) &#123;  <span class="hljs-comment">// 超出右半部value数组范围，重新开始，需要寻找下一个左半部元组</span><br>    &#125;<br><br>    <span class="hljs-built_in">TupleSchemaTranformUseEvaluateJoin</span>(&amp;left_tuple_, left_schema, &amp;hash_table_[left_key_][array_index_], right_schema,<br>                                       tuple, final_schema);<br>    array_index_++;  <span class="hljs-comment">// 指向下一位置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不管是Nested Loop Join还是HASH JOIN，第一次next方法都需要进行特殊处理，因为第一次左半部需要调用next方法，后面调用next方法时<strong>左半部需要调用next方法的时机</strong>要么在右半部扫描到了末尾（Nested Loop Join），要么是map中value数组到了末尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::map&lt;Value, std::vector&lt;Tuple&gt;, MapComparator&gt; hash_table_;  <span class="hljs-comment">// 不使用unordered_map，需要实现两个方法hash和==</span><br></code></pre></td></tr></table></figure>
<p>HASH JOIN使用map即可，这样方便一点。另外需要处理左表与右表为空的情况。</p>
<h4 id="其余Executor"><a href="#其余Executor" class="headerlink" title="其余Executor"></a>其余Executor</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::set&lt;Tuple, SetComparator&gt; tuples_;<br></code></pre></td></tr></table></figure>
<p>AggregationExecutor使用EvaluateAggregate进行模式转换，DistinctExecutor使用set存储元组。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexInfo</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Construct a new IndexInfo instance.</span><br><span class="hljs-comment">   * @param key_schema The schema for the index key</span><br><span class="hljs-comment">   * @param name The name of the index</span><br><span class="hljs-comment">   * @param index An owning pointer to the index</span><br><span class="hljs-comment">   * @param index_oid The unique OID for the index</span><br><span class="hljs-comment">   * @param table_name The name of the table on which the index is created</span><br><span class="hljs-comment">   * @param key_size The size of the index key, in bytes</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">IndexInfo</span>(Schema key_schema, std::string name, std::unique_ptr&lt;Index&gt; &amp;&amp;index, <span class="hljs-type">index_oid_t</span> index_oid,<br>            std::string table_name, <span class="hljs-type">size_t</span> key_size)<br>      : key_schema_&#123;std::<span class="hljs-built_in">move</span>(key_schema)&#125;,<br>        name_&#123;std::<span class="hljs-built_in">move</span>(name)&#125;,<br>        index_&#123;std::<span class="hljs-built_in">move</span>(index)&#125;,<br>        index_oid_&#123;index_oid&#125;,<br>        table_name_&#123;std::<span class="hljs-built_in">move</span>(table_name)&#125;,<br>        key_size_&#123;key_size&#125; &#123;&#125;<br>  <span class="hljs-comment">/** The schema for the index key */</span><br>  Schema key_schema_;<br>  <span class="hljs-comment">/** The name of the index */</span><br>  std::string name_;<br>  <span class="hljs-comment">/** An owning pointer to the index */</span><br>  std::unique_ptr&lt;Index&gt; index_;<br>  <span class="hljs-comment">/** The unique OID for the index */</span><br>  <span class="hljs-type">index_oid_t</span> index_oid_;<br>  <span class="hljs-comment">/** The name of the table on which the index is created */</span><br>  std::string table_name_;<br>  <span class="hljs-comment">/** The size of the index key, in bytes */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> key_size_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>索引最坑的一点便是，在提交到gradescope之后我才知道原来<mark>DeleteEntry InsertEntry方法中传入的不是整个元组，而是元组的一部分</mark>（现在想来也合乎情理），在本地测试中根本没看出来。所以第一个问题便来了，如何生成索引列的元组呢？<br>答案便是使用KeyFromTuple，这个方法应该就是专门为这个用途而设计的，不过我很好奇的是key_attrs的作用是啥？key_schema不能唯一确定key元组吗？有可能跟Unlined Inlined有关，但我懒得研究了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Generates a key tuple given schemas and attributes</span><br><span class="hljs-function">Tuple <span class="hljs-title">KeyFromTuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Schema &amp;schema, <span class="hljs-type">const</span> Schema &amp;key_schema, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; &amp;key_attrs)</span></span>;<br></code></pre></td></tr></table></figure>
<p>索引的第二个问题便是DeleteEntry InsertEntry的RID参数应该传哪个？key元组或表元组 （更新：key元组没有RID）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Insert an entry into the index.</span><br><span class="hljs-comment"> * @param key The index key</span><br><span class="hljs-comment"> * @param rid The RID associated with the key (unused)</span><br><span class="hljs-comment"> * @param transaction The transaction context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">InsertEntry</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;key, RID rid, Transaction *transaction)</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Delete an index entry by key.</span><br><span class="hljs-comment"> * @param key The index key</span><br><span class="hljs-comment"> * @param rid The RID associated with the key (unused)</span><br><span class="hljs-comment"> * @param transaction The transaction context</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DeleteEntry</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;key, RID rid, Transaction *transaction)</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<p>在看到The RID associated with the key (unused)这个说明时我就没在意，随便传了表元组的RID，然后测试就一直卡在update方法面前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">info-&gt;index_-&gt;<span class="hljs-built_in">DeleteEntry</span>(old_key_tuple, child_rid, transaction);<br>info-&gt;index_-&gt;<span class="hljs-built_in">InsertEntry</span>(new_key_tuple, update_rid, transaction);<br><br>[ RUN      ] GradingExecutorTest.UpdateTableSetWithIndex<br><span class="hljs-number">2022</span><span class="hljs-number">-03</span><span class="hljs-number">-03</span> <span class="hljs-number">15</span>:<span class="hljs-number">06</span>:<span class="hljs-number">13</span> [autograder/bustub/src/storage/disk/disk_manager.cpp:<span class="hljs-number">124</span>:ReadPage] DEBUG - Read less than a page<br>/autograder/bustub/test/execution/grading_update_executor_test.cpp:<span class="hljs-number">230</span>: Failure<br>Value of: table-&gt;<span class="hljs-built_in">GetTuple</span>(rids[i], &amp;indexed_tuple, <span class="hljs-built_in">GetTxn</span>())<br>  Actual: <span class="hljs-literal">false</span><br>Expected: <span class="hljs-literal">true</span><br>[  FAILED  ] GradingExecutorTest.<span class="hljs-built_in">UpdateTableSetWithIndex</span> (<span class="hljs-number">50</span> ms)<br>[ RUN      ] GradingExecutorTest.UpdateIntegrated<br><span class="hljs-number">2022</span><span class="hljs-number">-03</span><span class="hljs-number">-03</span> <span class="hljs-number">15</span>:<span class="hljs-number">06</span>:<span class="hljs-number">13</span> [autograder/bustub/src/storage/disk/disk_manager.cpp:<span class="hljs-number">124</span>:ReadPage] DEBUG - Read less than a page<br>/autograder/bustub/test/execution/grading_update_executor_test.cpp:<span class="hljs-number">317</span>: Failure<br>Value of: table_info-&gt;table_-&gt;<span class="hljs-built_in">GetTuple</span>(rids[<span class="hljs-number">0</span>], &amp;indexed_tuple, <span class="hljs-built_in">GetTxn</span>())<br>  Actual: <span class="hljs-literal">false</span><br>Expected: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>流程分析</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">table_info_-&gt;table_-&gt;<span class="hljs-built_in">UpdateTuple</span>(update_tuple, child_rid, transaction);  <span class="hljs-comment">// 传入old rid</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TableHeap::UpdateTuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;tuple, <span class="hljs-type">const</span> RID &amp;rid, Transaction *txn)</span> </span>&#123;<br>  <span class="hljs-comment">// Find the page which contains the tuple.</span><br>  <span class="hljs-keyword">auto</span> page = <span class="hljs-built_in">reinterpret_cast</span>&lt;TablePage *&gt;(buffer_pool_manager_-&gt;<span class="hljs-built_in">FetchPage</span>(rid.<span class="hljs-built_in">GetPageId</span>()));<br>  <span class="hljs-comment">// If the page could not be found, then abort the transaction.</span><br>  <span class="hljs-keyword">if</span> (page == <span class="hljs-literal">nullptr</span>) &#123;<br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// Update the tuple; but first save the old value for rollbacks.</span><br>  Tuple old_tuple;<br>  page-&gt;<span class="hljs-built_in">WLatch</span>();<br>  <span class="hljs-type">bool</span> is_updated = page-&gt;<span class="hljs-built_in">UpdateTuple</span>(tuple, &amp;old_tuple, rid, txn, lock_manager_, log_manager_);<br>  page-&gt;<span class="hljs-built_in">WUnlatch</span>();<br>  buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(page-&gt;<span class="hljs-built_in">GetTablePageId</span>(), is_updated);<br>  <span class="hljs-comment">// Update the transaction&#x27;s write set.</span><br>  <span class="hljs-keyword">if</span> (is_updated &amp;&amp; txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED) &#123;<br>    txn-&gt;<span class="hljs-built_in">GetWriteSet</span>()-&gt;<span class="hljs-built_in">emplace_back</span>(rid, WType::UPDATE, old_tuple, <span class="hljs-keyword">this</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> is_updated;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TablePage::UpdateTuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;new_tuple, Tuple *old_tuple, <span class="hljs-type">const</span> RID &amp;rid, Transaction *txn,</span></span><br><span class="hljs-params"><span class="hljs-function">                            LockManager *lock_manager, LogManager *log_manager)</span></span><br></code></pre></td></tr></table></figure>
<p>在UpdateTuple方法传入旧元组的RID后，并没有更新RID的操作（TablePage::UpdateTuple有点复杂，但没看到有RID更新的内容）。也就是说更新元组的RID并没有用，我们仍然使用旧元组的RID检索更新后的元组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HASH_TABLE_INDEX_TYPE::InsertEntry</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;key, RID rid, Transaction *transaction)</span> </span>&#123;<br>  <span class="hljs-comment">// construct insert index key</span><br>  KeyType index_key;<br>  index_key.<span class="hljs-built_in">SetFromKey</span>(key);<br><br>  container_.<span class="hljs-built_in">Insert</span>(transaction, index_key, rid);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HASH_TABLE_INDEX_TYPE::DeleteEntry</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;key, RID rid, Transaction *transaction)</span> </span>&#123;<br>  <span class="hljs-comment">// construct delete index key</span><br>  KeyType index_key;<br>  index_key.<span class="hljs-built_in">SetFromKey</span>(key);<br><br>  container_.<span class="hljs-built_in">Remove</span>(transaction, index_key, rid);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>DeleteEntry InsertEntry方法就是调用了上一部分的动态哈希，key值为索引列，value值为RID。所以索引的使用方式便如下面所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">* Search the index for the provided key.</span><br><span class="hljs-comment">* @param key The index key</span><br><span class="hljs-comment">* @param result The collection of RIDs that is populated with results of the search</span><br><span class="hljs-comment">* @param transaction The transaction context</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ScanKey</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;key, std::vector&lt;RID&gt; *result, Transaction *transaction)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Read a tuple from a table.</span><br><span class="hljs-comment"> * @param rid rid of the tuple to read</span><br><span class="hljs-comment"> * @param[out] tuple the tuple that was read</span><br><span class="hljs-comment"> * @param txn transaction performing the read</span><br><span class="hljs-comment"> * @param lock_manager the lock manager</span><br><span class="hljs-comment"> * @return true if the read is successful (i.e. the tuple exists)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTuple</span><span class="hljs-params">(<span class="hljs-type">const</span> RID &amp;rid, Tuple *tuple, Transaction *txn, LockManager *lock_manager)</span></span>;<br>已知一个key元组，想要获取完整元组<br>通过ScanKey方法得到RID数组，通过GetTuple得到完整元组。<br></code></pre></td></tr></table></figure>
<p>在了解完索引的使用流程后DeleteEntry InsertEntry的RID参数应该是哪个就呼之欲出了，<mark>即一直为表元组的RID，既不是索引列元组，也不是更新元组。</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">info-&gt;index_-&gt;<span class="hljs-built_in">DeleteEntry</span>(old_key_tuple, child_rid, transaction);<br>info-&gt;index_-&gt;<span class="hljs-built_in">InsertEntry</span>(new_key_tuple, child_rid, transaction);<br></code></pre></td></tr></table></figure>
<p>当时我没认真看代码，写成这样试了一下，结果测试报另一个错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">info-&gt;index_-&gt;<span class="hljs-built_in">DeleteEntry</span>(old_key_tuple, update_rid, transaction);<br>info-&gt;index_-&gt;<span class="hljs-built_in">InsertEntry</span>(new_key_tuple, update_rid, transaction);<br>rids.<span class="hljs-built_in">size</span>()<br>  Which is: <span class="hljs-number">2</span><br>i + <span class="hljs-number">1</span><br>  Which is: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Halloween problem<br>在1976年的万圣节那一天，IBM的两位程序要需要修改数据库库中内容，其所对应的业务内容是“给所有工资小于25000的员工加薪百分之十”，他们运行的sql语句如下：<br>UPDATE EMP_TABLE SET SALARY&#x3D;SALARY*1.1 WHERE SALARY&lt;25000<br>　　但是他们执行完这条语句以后发现了一个大问题，那就是数据库中所有员工的工资都至少为25000。后来发现出现这样的结果的主要问题是：所有工资小于25000的哪些记录被无限次数得加薪了百分之十，直到工资大于等于25000为止。<br>　如果更新操作是在选择操作扫描索引的执行过程中完成，一个更新的元组可能会在扫描之前和扫描之后重复插入索引两次；同一个元素的元素可能不正确地更新多次（在上述情况下会更新多次直到工资大于等于25000为止）。上述更新操作本身可能影响自己执行的问题称为万圣节问题（Halloween problem）。如果我们在一个字段上创建了索引，那么元组会按照索引进行排序。假如我们在之前的EMP_TABLE表中的SALARY字段上创建了索引，那么每次更新SALARY字段都会更新索引，然后对元组的位置进行调整。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/347526">数据库中的万圣节问题（Database “Halloween problem”）</a></p>
<h4 id="本地测试与gradescope测试"><a href="#本地测试与gradescope测试" class="headerlink" title="本地测试与gradescope测试"></a>本地测试与gradescope测试</h4><p>本地测试时，可以输出元组tuple-&gt;ToString(output_schema)，验证结果。<br>首先分析最简单的测试用例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// SELECT col_a, col_b FROM test_1 WHERE col_a &lt; 500</span><br><span class="hljs-built_in">TEST_F</span>(ExecutorTest, SimpleSeqScanTest) &#123;<br>  <span class="hljs-comment">// Construct query plan</span><br>  TableInfo *table_info = <span class="hljs-built_in">GetExecutorContext</span>()-&gt;<span class="hljs-built_in">GetCatalog</span>()-&gt;<span class="hljs-built_in">GetTable</span>(<span class="hljs-string">&quot;test_1&quot;</span>);		<span class="hljs-comment">// 获取test1表</span><br>  <span class="hljs-type">const</span> Schema &amp;schema = table_info-&gt;schema_;<br>  <span class="hljs-keyword">auto</span> *col_a = <span class="hljs-built_in">MakeColumnValueExpression</span>(schema, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;colA&quot;</span>);		<span class="hljs-comment">// 构建colA的表达式</span><br>  <span class="hljs-keyword">auto</span> *col_b = <span class="hljs-built_in">MakeColumnValueExpression</span>(schema, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;colB&quot;</span>);<br>  <span class="hljs-keyword">auto</span> *const500 = <span class="hljs-built_in">MakeConstantValueExpression</span>(ValueFactory::<span class="hljs-built_in">GetIntegerValue</span>(<span class="hljs-number">500</span>));	<br>  <span class="hljs-keyword">auto</span> *predicate = <span class="hljs-built_in">MakeComparisonExpression</span>(col_a, const500, ComparisonType::LessThan);	<span class="hljs-comment">// 约束条件</span><br>  <span class="hljs-keyword">auto</span> *out_schema = <span class="hljs-built_in">MakeOutputSchema</span>(&#123;&#123;<span class="hljs-string">&quot;colA&quot;</span>, col_a&#125;, &#123;<span class="hljs-string">&quot;colB&quot;</span>, col_b&#125;&#125;);	<span class="hljs-comment">// 输出模式</span><br>  SeqScanPlanNode plan&#123;out_schema, predicate, table_info-&gt;oid_&#125;;<br><br>  <span class="hljs-comment">// Execute</span><br>  std::vector&lt;Tuple&gt; result_set&#123;&#125;;<br>  <span class="hljs-built_in">GetExecutionEngine</span>()-&gt;<span class="hljs-built_in">Execute</span>(&amp;plan, &amp;result_set, <span class="hljs-built_in">GetTxn</span>(), <span class="hljs-built_in">GetExecutorContext</span>());<br><br>  <span class="hljs-comment">// Verify</span><br>  <span class="hljs-built_in">ASSERT_EQ</span>(result_set.<span class="hljs-built_in">size</span>(), <span class="hljs-number">500</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;tuple : result_set) &#123;<br>    <span class="hljs-built_in">ASSERT_TRUE</span>(tuple.<span class="hljs-built_in">GetValue</span>(out_schema, out_schema-&gt;<span class="hljs-built_in">GetColIdx</span>(<span class="hljs-string">&quot;colA&quot;</span>)).<span class="hljs-built_in">GetAs</span>&lt;<span class="hljs-type">int32_t</span>&gt;() &lt; <span class="hljs-number">500</span>);<br>    <span class="hljs-built_in">ASSERT_TRUE</span>(tuple.<span class="hljs-built_in">GetValue</span>(out_schema, out_schema-&gt;<span class="hljs-built_in">GetColIdx</span>(<span class="hljs-string">&quot;colB&quot;</span>)).<span class="hljs-built_in">GetAs</span>&lt;<span class="hljs-type">int32_t</span>&gt;() &lt; <span class="hljs-number">10</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// test1表的生成在table_generator.cpp的TableGenerator::GenerateTestTables()中</span><br><span class="hljs-comment">// 表头</span><br><span class="hljs-string">&quot;test_1&quot;</span>,<br>TEST1_SIZE,<br>&#123;&#123;<span class="hljs-string">&quot;colA&quot;</span>, TypeId::INTEGER, <span class="hljs-literal">false</span>, Dist::Serial, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br> &#123;<span class="hljs-string">&quot;colB&quot;</span>, TypeId::INTEGER, <span class="hljs-literal">false</span>, Dist::Uniform, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>&#125;,<br> &#123;<span class="hljs-string">&quot;colC&quot;</span>, TypeId::INTEGER, <span class="hljs-literal">false</span>, Dist::Uniform, <span class="hljs-number">0</span>, <span class="hljs-number">9999</span>&#125;,<br> &#123;<span class="hljs-string">&quot;colD&quot;</span>, TypeId::INTEGER, <span class="hljs-literal">false</span>, Dist::Uniform, <span class="hljs-number">0</span>, <span class="hljs-number">99999</span>&#125;&#125;&#125;,<br><span class="hljs-comment">// 表数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;table_meta : insert_meta) &#123;<br>  <span class="hljs-comment">// Create Schema</span><br>  std::vector&lt;Column&gt; cols&#123;&#125;;<br>  cols.<span class="hljs-built_in">reserve</span>(table_meta.col_meta_.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;col_meta : table_meta.col_meta_) &#123;<br>    <span class="hljs-keyword">if</span> (col_meta.type_ != TypeId::VARCHAR) &#123;<br>      cols.<span class="hljs-built_in">emplace_back</span>(col_meta.name_, col_meta.type_);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cols.<span class="hljs-built_in">emplace_back</span>(col_meta.name_, col_meta.type_, TEST_VARLEN_SIZE);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">Schema <span class="hljs-title">schema</span><span class="hljs-params">(cols)</span></span>;<br>  <span class="hljs-keyword">auto</span> info = exec_ctx_-&gt;<span class="hljs-built_in">GetCatalog</span>()-&gt;<span class="hljs-built_in">CreateTable</span>(exec_ctx_-&gt;<span class="hljs-built_in">GetTransaction</span>(), table_meta.name_, schema);<br>  <span class="hljs-built_in">FillTable</span>(info, &amp;table_meta);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 SimpleUpdateTest中，结果集应该为空，故需修改ExecutionEngine类的Execute方法，使其在元组未分配内存时不添加到result数组之中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">result_set.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">// Execute update for all tuples in the table</span><br><span class="hljs-built_in">GetExecutionEngine</span>()-&gt;<span class="hljs-built_in">Execute</span>(update_plan.<span class="hljs-built_in">get</span>(), &amp;result_set, <span class="hljs-built_in">GetTxn</span>(), <span class="hljs-built_in">GetExecutorContext</span>());<br><br><span class="hljs-comment">// UpdateExecutor should not modify the result set</span><br><span class="hljs-built_in">ASSERT_EQ</span>(result_set.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>在SimpleDeleteTest测试中查询后的tuple为”(50, 7, 7664, 76652) Tuple size is 16”，元组的大小为16，我刚开始以为这个测试有问题，因为索引大小才为8，会造成数组越界问题，但后面才发现索引列并不是全部的元组。。为此我还专门设计了两个新的测试样例，一个用其他的表，一个用更大的key。但实际上是我理解错了索引的意思。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST_F</span>(ExecutorTest, MyDeleteTest) &#123;<br>  <span class="hljs-comment">// Construct query plan</span><br>  <span class="hljs-keyword">auto</span> table_info = <span class="hljs-built_in">GetExecutorContext</span>()-&gt;<span class="hljs-built_in">GetCatalog</span>()-&gt;<span class="hljs-built_in">GetTable</span>(<span class="hljs-string">&quot;test_3&quot;</span>);<br>  <br><span class="hljs-keyword">using</span> MyKeyType = GenericKey&lt;<span class="hljs-number">16</span>&gt;;<br><span class="hljs-keyword">using</span> MyValueType = RID;<br><span class="hljs-keyword">using</span> MyComparatorType = GenericComparator&lt;<span class="hljs-number">16</span>&gt;;<br><span class="hljs-keyword">using</span> MyHashFunctionType = HashFunction&lt;MyKeyType&gt;<br></code></pre></td></tr></table></figure>
<p>在进行gradescope测试时，一上传就编译失败，显示使用不完全的类AbstractExpression,即未找到AbstractExpression的定义，但plan头文件中都包含了abstract_expression.h。有点奇怪，好像有的版本plan里面没有abstract_expression.h，也懒得管了，在各个Executor里加上abstract_expression.h头文件。<br><strong>报错集</strong><br>索引使用输出元组而不是key元组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">==<span class="hljs-number">2424</span>== Process terminating with <span class="hljs-keyword">default</span> action of signal <span class="hljs-number">6</span> (SIGABRT)<br>==<span class="hljs-number">2424</span>==    at <span class="hljs-number">0x6159FB7</span>: <span class="hljs-built_in">raise</span> (raise.c:<span class="hljs-number">51</span>)<br>==<span class="hljs-number">2424</span>==    by <span class="hljs-number">0x615B920</span>: <span class="hljs-built_in">abort</span> (abort.c:<span class="hljs-number">79</span>)<br>==<span class="hljs-number">2424</span>==    by <span class="hljs-number">0x61A4966</span>: __libc_message (libc_fatal.c:<span class="hljs-number">181</span>)<br>==<span class="hljs-number">2424</span>==    by <span class="hljs-number">0x624FB60</span>: __fortify_fail_abort (fortify_fail.c:<span class="hljs-number">33</span>)<br>==<span class="hljs-number">2424</span>==    by <span class="hljs-number">0x624FB21</span>: __stack_chk_fail (stack_chk_fail.c:<span class="hljs-number">29</span>)<br>==<span class="hljs-number">2424</span>==    by <span class="hljs-number">0x4FA2388</span>: bustub::ExtendibleHashTableIndex&lt;bustub::GenericKey&lt;<span class="hljs-number">8ul</span>&gt;, bustub::RID, bustub::GenericComparator&lt;<span class="hljs-number">8ul</span>&gt; &gt;::<span class="hljs-built_in">DeleteEntry</span>(bustub::Tuple <span class="hljs-type">const</span>&amp;, bustub::RID, bustub::Transaction*) (in /autograder/bustub/build/lib/libbustub_shared.so)<br></code></pre></td></tr></table></figure>
<p>连接时未考虑左表 右表为空的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[ RUN      ] GradingExecutorTest.NestedLoopJoinEmptyOuterTable<br><br>==<span class="hljs-number">2464</span>== Memcheck, a memory error detector<br>==<span class="hljs-number">2464</span>== <span class="hljs-built_in">Copyright</span> (C) <span class="hljs-number">2002</span><span class="hljs-number">-2017</span>, <span class="hljs-keyword">and</span> GNU GP<span class="hljs-string">L&#x27;d, by Julian Seward et al.</span><br><span class="hljs-string">==2464== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="hljs-string">==2464== Command: ./grading_nested_loop_join_executor_test</span><br><span class="hljs-string">==2464== </span><br><span class="hljs-string">grading_nested_loop_join_executor_test: /autograder/bustub/src/storage/table/tuple.cpp:92: bustub::Value bustub::Tuple::GetValue(const bustub::Schema*, uint32_t) const: Assertion `data_&#x27;</span> failed.<br>==<span class="hljs-number">2464</span>== <br>==<span class="hljs-number">2464</span>== Process terminating with <span class="hljs-keyword">default</span> action of signal <span class="hljs-number">6</span> (SIGABRT)<br>==<span class="hljs-number">2464</span>==    at <span class="hljs-number">0x5F56FB7</span>: <span class="hljs-built_in">raise</span> (raise.c:<span class="hljs-number">51</span>)<br>==<span class="hljs-number">2464</span>==    by <span class="hljs-number">0x5F58920</span>: <span class="hljs-built_in">abort</span> (abort.c:<span class="hljs-number">79</span>)<br>==<span class="hljs-number">2464</span>==    by <span class="hljs-number">0x5F48489</span>: __assert_fail_base (assert.c:<span class="hljs-number">92</span>)<br>==<span class="hljs-number">2464</span>==    by <span class="hljs-number">0x5F48501</span>: __assert_fail (assert.c:<span class="hljs-number">101</span>)<br>==<span class="hljs-number">2464</span>==    by <span class="hljs-number">0x4FB7E15</span>: bustub::Tuple::<span class="hljs-built_in">GetValue</span>(bustub::Schema <span class="hljs-type">const</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) <span class="hljs-built_in">const</span> (in /autograder/bustub/build/lib/libbustub_shared.so)<br>==<span class="hljs-number">2464</span>==    by <span class="hljs-number">0x12EAB8</span>: bustub::ColumnValueExpression::<span class="hljs-built_in">EvaluateJoin</span>(bustub::Tuple <span class="hljs-type">const</span>*, bustub::Schema <span class="hljs-type">const</span>*, bustub::Tuple <span class="hljs-type">const</span>*, bustub::Schema <span class="hljs-type">const</span>*) <span class="hljs-built_in">const</span> (in <br>==<span class="hljs-number">2464</span>== <br></code></pre></td></tr></table></figure>
<p>IOcost问题，即使多一次都不行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一次</span><br>[ RUN      ] GradingExecutorTest.NestedLoopJoinIOCost<br>/autograder/bustub/test/execution/grading_nested_loop_join_executor_test.cpp:<span class="hljs-number">443</span>: Failure<br>Expected equality of these values:<br>  scan0_size * scan1_size<br>    Which is: <span class="hljs-number">100</span><br>  scan1-&gt;<span class="hljs-built_in">PollCount</span>()<br>    Which is: <span class="hljs-number">10</span><br>[  FAILED  ] GradingExecutorTest.<span class="hljs-built_in">NestedLoopJoinIOCost</span> (<span class="hljs-number">752</span> ms)<br><span class="hljs-comment">// 第二次</span><br>/autograder/bustub/test/execution/grading_nested_loop_join_executor_test.cpp:<span class="hljs-number">443</span>: Failure<br>Expected equality of these values:<br>  scan0_size * scan1_size<br>    Which is: <span class="hljs-number">100</span><br>  scan1-&gt;<span class="hljs-built_in">PollCount</span>()<br>    Which is: <span class="hljs-number">101</span><br></code></pre></td></tr></table></figure>
<p>update executor索引RID问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[ RUN      ] GradingExecutorTest.UpdateTableSetWithIndex<br><span class="hljs-number">2022</span><span class="hljs-number">-03</span><span class="hljs-number">-03</span> <span class="hljs-number">15</span>:<span class="hljs-number">06</span>:<span class="hljs-number">13</span> [autograder/bustub/src/storage/disk/disk_manager.cpp:<span class="hljs-number">124</span>:ReadPage] DEBUG - Read less than a page<br>/autograder/bustub/test/execution/grading_update_executor_test.cpp:<span class="hljs-number">230</span>: Failure<br>Value of: table-&gt;<span class="hljs-built_in">GetTuple</span>(rids[i], &amp;indexed_tuple, <span class="hljs-built_in">GetTxn</span>())<br>  Actual: <span class="hljs-literal">false</span><br>Expected: <span class="hljs-literal">true</span><br>[  FAILED  ] GradingExecutorTest.<span class="hljs-built_in">UpdateTableSetWithIndex</span> (<span class="hljs-number">50</span> ms)<br>[ RUN      ] GradingExecutorTest.UpdateIntegrated<br><span class="hljs-number">2022</span><span class="hljs-number">-03</span><span class="hljs-number">-03</span> <span class="hljs-number">15</span>:<span class="hljs-number">06</span>:<span class="hljs-number">13</span> [autograder/bustub/src/storage/disk/disk_manager.cpp:<span class="hljs-number">124</span>:ReadPage] DEBUG - Read less than a page<br>/autograder/bustub/test/execution/grading_update_executor_test.cpp:<span class="hljs-number">317</span>: Failure<br>Value of: table_info-&gt;table_-&gt;<span class="hljs-built_in">GetTuple</span>(rids[<span class="hljs-number">0</span>], &amp;indexed_tuple, <span class="hljs-built_in">GetTxn</span>())<br>  Actual: <span class="hljs-literal">false</span><br>Expected: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p>测试通过截图<br><img src="https://img-blog.csdnimg.cn/9dc58f50b0914d71a712e17b883e3d0f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br><strong>其他：</strong><br><strong>unordered_map与map的对比：</strong> 见《effective stl 》关联容器</p>
<p>　　存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator&#x3D;&#x3D;。但是很多系统内置的数据类型都自带这些。</p>
<p>　　总结：结构体用map重载&lt;运算符，结构体用unordered_map重载&#x3D;&#x3D;运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>,                                    <span class="hljs-comment">// unordered_map::key_type</span><br>           <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,                                      <span class="hljs-comment">// unordered_map::mapped_type</span><br>           <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span> = hash&lt;Key&gt;,                       <span class="hljs-comment">// unordered_map::hasher</span><br>           <span class="hljs-keyword">class</span> Pred = equal_to&lt;Key&gt;,                   <span class="hljs-comment">// unordered_map::key_equal</span><br>           <span class="hljs-keyword">class</span> Alloc = allocator&lt; pair&lt;<span class="hljs-type">const</span> Key,T&gt; &gt;  <span class="hljs-comment">// unordered_map::allocator_type</span><br>           &gt; <span class="hljs-keyword">class</span> unordered_map;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/langyao/p/8823092.html">详细介绍C++STL：unordered_map</a><br><a target="_blank" rel="noopener" href="https://www.codenong.com/51220257/">报错use of deleted function</a><br><a target="_blank" rel="noopener" href="https://www.codenong.com/51235355/">关于c ++：比较对象可作为const调用</a></p>
<h3 id="concurrency-control"><a href="#concurrency-control" class="headerlink" title="concurrency control"></a>concurrency control</h3><p>这部分实验是关于事务，隔离级别与死锁的，建议先看<a target="_blank" rel="noopener" href="https://github.com/Vonng/ddia">《数据密集型应用设计》</a>事务一章与《数据库系统概念》<em>15.1 基于锁的协议一节</em>，了解背景知识。实验主要实现四个函数：请求读锁，请求写锁，升级锁，解锁。<br>事务的隔离级别有读未提交，读己提交，可重复读&#x2F;快照隔离三种。这几个隔离级别分别能避免一些问题<br>脏写：写入会覆盖一个尚未提交的值<br>脏读：事务可以看到未提交的数据<br>读偏差：观察数据库处于不一致的状态<br><img src="https://img-blog.csdnimg.cn/ecebbf51e732434981deac11096f0caa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload><br>读未提交：脏写<br>读己提交：脏写，脏读<br>可重复读：脏写，脏读，读偏差<br>落到实现上，读未提交只有写锁，也只加写锁，读己提交 每读取一个元组加读锁，读取完即释放，可重复读使用两阶段锁定（2PL），只有可重复读持有shrink状态，读取时统一加读锁，事务提交时才释放。如果拥有了读锁请求写锁记得使用升级锁。</p>
<p>在又看完一遍事务一节后，我发现了一个问题。在快照隔离中读不阻塞写，写不阻塞读，在2PL中，写入不仅会阻塞其他写入，也会阻塞读，读则只会阻塞写入。<mark>那在实验的读己提交隔离级别中，读锁需要阻塞写锁吗？阻塞的意义在哪呢？</mark>，脏写只需要写阻塞写，脏读只需要写阻塞读，也就是说加读锁只是为了被阻塞，而不是为了阻塞谁</p>
<p>unique_lock与condition_variable的组合，wait时会自动释放锁，唤醒后再获取锁，非常方便<br> 第一部分的实现比较简单，主要就是维持事务的state，处理一些异常。</p>
<p> 实验最难也最坑的地方就是第二部分，我觉得是存在很多问题的。<br> 死锁的四个条件互斥，不可剥夺，请求和保持，循环等待。<br>  Wound-Wait (“Young Waits for Old”): If the requesting transaction has a higher priority than the<br>holding transaction, the holding transaction aborts and releases the lock. Otherwise, the requesting<br>transaction waits.<br>这个  Wound-Wait也就是是年轻事务需等待老事务释放，而老事务可以直接杀死年轻事务，这就破除了循环等待条件。<br><strong>我以为的：</strong><br>看到事务ID为优先级的特性，RID的请求队列我就会选择一些可以自动排序的数据结构，由于优先队列不能访问任意位置，所以我采用了set。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockRequestQueue</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SetpComparator</span> &#123;  <span class="hljs-comment">// 重载map的key值排序方式</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> LockRequest &amp;lhs, <span class="hljs-type">const</span> LockRequest &amp;rhs)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> lhs.txn_id_ &lt; rhs.txn_id_; &#125;<br>  &#125;;<br><br> <span class="hljs-keyword">public</span>:<br>  std::set&lt;LockRequest, SetpComparator&gt; request_queue_;<br><br>  <span class="hljs-comment">// for notifying blocked transactions on this rid</span><br>  std::condition_variable cv_;<br>  <span class="hljs-comment">// txn_id of an upgrading transaction (if any)</span><br>  <span class="hljs-type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;<br><br>  <span class="hljs-type">int</span> share_req_cnt_&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 当前持有S锁的事务个数</span><br><br>  RIDStatus status_;  <span class="hljs-comment">// 当前RID上的锁</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>我以为的逻辑大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S锁：<br>避免重复加锁以及一些异常处理<br>插入请求<br>杀死比其年轻事务持有锁的写请求<br>如果当前RID为空闲状态：<br>	获得锁<br>如果当前RID为写锁状态：	<span class="hljs-comment">// 代表持有锁的事务更老</span><br>	等待锁的释放直到事务中止或得到锁的保证<br>如果当前RID为读锁状态：<br>	如果在其前面存在写锁请求或者更新锁请求，则等待锁的释放直到事务中止或得到锁的保证 <span class="hljs-comment">// 不能使老事务的写/更新请求等待年轻事务的读</span><br>	否则获得锁<br>	<br>X锁：<br>避免重复加锁以及一些异常处理<br>插入请求<br>杀死比其年轻事务持有锁的请求<br>等待锁的释放直到事务中止或得到锁的保证<br><br>升级锁：<br>杀死比其年轻事务持有锁的读请求<br>等待直到事务中止或得到只剩下它这一个读请求<br>升级成写锁<br><br>解锁：<br>在请求队列删除该请求<br>如果是写锁请求或最后一个读锁解锁，则需要给一些请求保证<br>	如果队列第一个是写锁请求，只给这一个锁保证<br>	如果队列第一个是读锁请求，给予连续的读锁请求保证<br>唤醒等待的线程<br></code></pre></td></tr></table></figure>
<p>实现这些逻辑之后，我通过了本地测试，但gradescope4个Wound测试一直无法通过，在阅读了博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/twentyonepilots/article/details/120868216">CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb lab</a>  才知道gradescope的逻辑是大致这样的<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S锁：<br>避免重复加锁以及一些异常处理<br>插入请求<br>杀死比其年轻事务写请求<br>如果当前RID为空闲状态：<br>	获得锁<br>如果当前RID为写锁状态：	<span class="hljs-comment">// 代表持有锁的事务更老</span><br>	等待锁的释放直到事务中止或得到锁的保证<br>如果当前RID为读锁状态：<br>	如果在其前面存在写锁请求或者更新锁请求，则等待锁的释放直到事务中止或得到锁的保证 <span class="hljs-comment">// 不能使老事务的写/更新请求等待年轻事务的读</span><br>	否则获得锁<br>	<br>X锁：<br>避免重复加锁以及一些异常处理<br>插入请求<br>杀死比其年轻事务的请求<br>等待锁的释放直到事务中止或得到锁的保证<br><br>升级锁：<br>杀死比其年轻事务的请求<br>等待直到事务中止或得到只剩下它这一个读请求<br>升级成写锁<br><br>解锁：<br>在请求队列删除该请求<br>如果是写锁请求或最后一个读锁解锁，则需要给一些请求保证<br>	如果队列第一个是写锁请求，只给这一个锁保证<br>	如果队列第一个是读锁请求，给予连续的读锁请求保证<br>唤醒等待的线程<br></code></pre></td></tr></table></figure><br><strong>年轻事务未持有锁，为什么需要被杀死呢？</strong><br>这种实现逻辑实际上是和请求队列的数据结构绑定的，实验希望请求队列使用list，或者说FIFO。但我觉得<strong>将测试与具体实现对应而不与接口或者说功能对应</strong>是很奇怪的一件事情，所以得60分就够了。<br><img src="https://img-blog.csdnimg.cn/c834ba67e3e5437c94a5a5662116d583.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="中止事务"><a href="#中止事务" class="headerlink" title="中止事务"></a>中止事务</h4><p>第二部分最复杂的地方在于对中止事务的处理。中止事务分为持有锁的中止事务与未持有锁的中止事务<br><mark>第一个问题：未持有锁的中止事务什么时候可以停止等待</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED &amp;&amp; !(request_location-&gt;granted_)) &#123;  <span class="hljs-comment">// 事务中止或得到保证</span><br>  lock_table_[rid].cv_.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这种结构中，如果没有调用notify_all方法，则这个线程一直会阻塞在这个地方，所以在加锁函数杀死请求之后，都在其后加上notify_all语句，使得中止的事务尽可能快地结束等待，<mark>而不是只在解锁函数中唤醒线程</mark>。<br><mark>第二个问题：可以对中止事务调用unlock方法吗？</mark></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> request_location = lock_table_[rid].request_queue_.<span class="hljs-built_in">emplace</span>(req).first;<br><span class="hljs-keyword">auto</span> iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> next_iter = iter;<br><span class="hljs-keyword">while</span> (iter != lock_table_[rid].request_queue_.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 杀死所有年轻事务</span><br>  ++next_iter;<br>  <span class="hljs-keyword">if</span> (iter-&gt;txn_id_ &gt; txn_id) &#123;<br>    iter-&gt;transation_-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (iter-&gt;transation_-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED) &#123;  <span class="hljs-comment">// 删除队列中中止事务的请求</span><br>    <span class="hljs-keyword">if</span> (iter-&gt;granted_) &#123;<br>      lock.<span class="hljs-built_in">unlock</span>();<br>      <span class="hljs-built_in">Unlock</span>(iter-&gt;transation_, rid);  <span class="hljs-comment">// 将请求从请求队列移除</span><br>      lock.<span class="hljs-built_in">lock</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lock_table_[rid].request_queue_.<span class="hljs-built_in">erase</span>(iter);<br>    &#125;<br>  &#125;<br>  iter = next_iter;<br>&#125;<br>lock_table_[rid].cv_.<span class="hljs-built_in">notify_all</span>(); <br></code></pre></td></tr></table></figure>
<p><mark>注意内存重分配（vector），删除元素带来的迭代器  指针 引用失效</mark><br>V1： 我最开始的方法是这样的，因为对中止事务的处理有点麻烦，为了省事，我直接删除队列中的中止事务。这段代码看起来是没有问题的，gradescope也能通过全部测试（不知道是运气还是什么的），但实际上是存在问题的。<br> 测试代码中：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">auto</span> otask = [&amp;](Transaction *tx) &#123;<br>    <span class="hljs-keyword">while</span> (tx-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED) &#123;<br>    &#125;<br>    txn_mgr.<span class="hljs-built_in">Abort</span>(tx);<br>&#125;;<br>其中Abort方法调用ReleaseLocks函数<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReleaseLocks</span><span class="hljs-params">(Transaction *txn)</span> </span>&#123;<br>    std::unordered_set&lt;RID&gt; lock_set;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : *txn-&gt;<span class="hljs-built_in">GetExclusiveLockSet</span>()) &#123;<br>        lock_set.<span class="hljs-built_in">emplace</span>(item);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : *txn-&gt;<span class="hljs-built_in">GetSharedLockSet</span>()) &#123;<br>        lock_set.<span class="hljs-built_in">emplace</span>(item);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> locked_rid : lock_set) &#123;<br>        lock_manager_-&gt;<span class="hljs-built_in">Unlock</span>(txn, locked_rid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>两个线程同时对事务的shared_lock_set_，exclusive_lock_set_数据结构进行操作，可能会使得ReleaseLocks函数中的迭代器指向错误的位置（heap-use-after-free，一个线程删除，一个线程访问）。那么结论便是：<mark>不能对中止事务进行解锁操作</mark>，所以队列中永远可能有持有锁的中止事务（未持有锁的中止事务可以移除）<br><strong>那么啥都不干，等事务管理器来释放中止事务拥有的锁，可行吗？</strong><br>从测试代码看也不可行，所以说只能释放锁后再将事务设置为中止。<br>这个事务管理器真是啥用没有。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> request_location = lock_table_[rid].request_queue_.<span class="hljs-built_in">emplace</span>(req).first;<br><span class="hljs-keyword">auto</span> iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> next_iter = iter;<br><span class="hljs-keyword">while</span> (iter != lock_table_[rid].request_queue_.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 杀死比其年轻的写锁请求</span><br>  ++next_iter;<br>  <span class="hljs-keyword">if</span> (iter-&gt;lock_mode_ == LockMode::EXCLUSIVE &amp;&amp; iter-&gt;txn_id_ &gt; txn_id &amp;&amp;<br>      iter-&gt;transation_-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED) &#123;<br>    transaction = iter-&gt;transation_;  <span class="hljs-comment">// 记录事务指针，先解锁再中止事务</span><br>    <span class="hljs-keyword">if</span> (iter-&gt;granted_) &#123;<br>      lock.<span class="hljs-built_in">unlock</span>();<br>      <span class="hljs-built_in">Unlock</span>(iter-&gt;transation_, rid);  <span class="hljs-comment">// 持有锁的请求立即解锁</span><br>      lock.<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    transaction-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iter-&gt;transation_-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED &amp;&amp;<br>             !iter-&gt;granted_) &#123;  <span class="hljs-comment">// 移除队列中未持有锁的中止事务</span><br>    lock_table_[rid].request_queue_.<span class="hljs-built_in">erase</span>(iter);<br>  &#125;<br><br>  iter = next_iter;<br>&#125;<br>lock_table_[rid].cv_.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 唤醒请求，防止中止事务一直等待</span><br></code></pre></td></tr></table></figure>
<p>但在解锁时我碰到了无法解决的问题，在需要唤醒请求后，需要找第一个非中止事务的请求给予保证。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> next_req_iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>(); iter != lock_table_[rid].request_queue_.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>  <span class="hljs-keyword">if</span> (iter-&gt;transation_-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED) &#123;<br>    exist_normal_request = <span class="hljs-literal">true</span>;<br>    next_req_mode = iter-&gt;lock_mode_;<br>    next_req_iter = iter;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而这个虽然运行能成功，但valgrind测试通不过，显示Invalid read of size 4，即iter-&gt;transation_有一些问题，但我不知道问题出在哪里，以后有机会再回头看看吧。<br><img src="https://img-blog.csdnimg.cn/7eb28edf85334db28e4dc3fc0c99058f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload></p>
<p>V2：我换了一个错误的逻辑来写，直接找第一个请求，实际上第一个请求可能是中止事务的等待请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下一个请求</span><br><span class="hljs-keyword">auto</span> next_req_iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">if</span> (!lock_table_[rid].request_queue_.<span class="hljs-built_in">empty</span>()) &#123;<br>  exist_normal_request = <span class="hljs-literal">true</span>;<br>  next_req_mode = next_req_iter-&gt;lock_mode_;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 结果gradescope又过了。。。，所以到头来我认为两个错误的版本都过了，我认为正确的版本valgrind  过不了。</p>
<p><strong>更新</strong>：valgrind 测试不能通过的原因是因为一些异常中止的事务Transaction已经结束了生命周期，此时其未持有锁的请求仍然在队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> wait_die_task = [&amp;]() &#123;<br>  id_mutex.<span class="hljs-built_in">lock</span>();<br>  <span class="hljs-function">Transaction <span class="hljs-title">wait_txn</span><span class="hljs-params">(id_wait++)</span></span>;<br>  id_mutex.<span class="hljs-built_in">unlock</span>();<br>  <span class="hljs-type">bool</span> res;<br>  txn_mgr.<span class="hljs-built_in">Begin</span>(&amp;wait_txn);<br>  res = lock_mgr.<span class="hljs-built_in">LockShared</span>(&amp;wait_txn, rid1);<br>  <span class="hljs-built_in">EXPECT_TRUE</span>(res);<br>  <span class="hljs-built_in">CheckGrowing</span>(&amp;wait_txn);<br>  <span class="hljs-built_in">CheckTxnLockSize</span>(&amp;wait_txn, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">try</span> &#123;<br>    res = lock_mgr.<span class="hljs-built_in">LockExclusive</span>(&amp;wait_txn, rid0);<br>    <span class="hljs-built_in">EXPECT_FALSE</span>(res) &lt;&lt; wait_txn.<span class="hljs-built_in">GetTransactionId</span>() &lt;&lt; <span class="hljs-string">&quot;ERR&quot;</span>;<br>  &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> TransactionAbortException &amp;e) &#123;<br>  &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> Exception &amp;e) &#123;<br>    <span class="hljs-built_in">EXPECT_TRUE</span>(<span class="hljs-literal">false</span>) &lt;&lt; <span class="hljs-string">&quot;Test encountered exception&quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">CheckAborted</span>(&amp;wait_txn);<br><br>  txn_mgr.<span class="hljs-built_in">Abort</span>(&amp;wait_txn);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>故iter-&gt;transation指针指向了未定义的位置，所以<mark>不能让中止事务的未持有锁的请求停留在队列中，此时指针不一定指向合法的地址</mark></p>
<p>所以结论便是这样：<strong>如果中止事务持有锁，则不能擅自解锁，可能一直停留在队列中，如果未持有锁，则需要立即移除</strong><br>V3：故修改代码，如果线程被唤醒后由于事务被中止而退出循环，则立即移除该请求，而不是像前两个版本一样在之前删除未加锁的请求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> request_location = lock_table_[rid].request_queue_.<span class="hljs-built_in">emplace</span>(req).first;<br><span class="hljs-keyword">auto</span> iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> next_iter = iter;<br><span class="hljs-keyword">while</span> (iter != lock_table_[rid].request_queue_.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 杀死比其年轻的请求</span><br>  ++next_iter;<br>  <span class="hljs-keyword">if</span> (iter-&gt;txn_id_ &gt; txn_id &amp;&amp; iter-&gt;transation_-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED) &#123;<br>    transaction = iter-&gt;transation_;  <span class="hljs-comment">// 记录事务指针</span><br>    <span class="hljs-keyword">if</span> (iter-&gt;granted_) &#123;<br>      lock.<span class="hljs-built_in">unlock</span>();<br>      <span class="hljs-built_in">Unlock</span>(iter-&gt;transation_, rid);  <span class="hljs-comment">// 持有锁的请求立即解锁</span><br>      lock.<span class="hljs-built_in">lock</span>();<br>    &#125;<br>    transaction-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>  &#125;<br>  iter = next_iter;<br>&#125;<br>lock_table_[rid].cv_.<span class="hljs-built_in">notify_all</span>();                                                       <span class="hljs-comment">// 唤醒中止事务请求</span><br><span class="hljs-keyword">while</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED &amp;&amp; !(request_location-&gt;granted_)) &#123;  <span class="hljs-comment">// 事务中止或得到保证</span><br>  lock_table_[rid].cv_.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br><span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED) &#123;<br>  lock_table_[rid].request_queue_.<span class="hljs-built_in">erase</span>(request_location);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以前两个版本到底为啥没出错，令人费解。</p>
<p>第三部分也不用加几行语句，就update_executor的索引与write sets维护（根本不用维护，InsertTuple方法中已经维护了）比较坑，建议看<a target="_blank" rel="noopener" href="https://blog.csdn.net/twentyonepilots/article/details/120868216">CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb lab</a>，这篇博客写的很好了，懒得写重复的东西。<br>主要就三点：</p>
<ol>
<li>未等待的事务也需要abort</li>
<li>不抛出异常</li>
<li>update不需要维持索引结构</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/8c4713da2b73441aa79e97772425bdff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_14,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload></p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><p>过了几个月再看lab4的博客我自己都快看不懂了，太过抽象了，还是贴一下lock_manager的代码<br> lab4我也懒得与测试程序反着来了，直接用list实现算了（虽然我觉得用优先队列的方式才是最好的，但测试程序的逻辑太奇怪了），而后把一些功能一致的代码提取成函数，这样看起来就简洁一点了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// lock_manager.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span>  <span class="hljs-comment">// NOLINT</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>  <span class="hljs-comment">// NOLINT</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common/config.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common/rid.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;concurrency/transaction.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> bustub &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManager</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * LockManager handles transactions asking for locks on records.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockManager</span> &#123;<br>  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">LockMode</span> &#123; SHARED, EXCLUSIVE &#125;;<br><br>  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">RIDStatus</span> &#123; FREE, SHARED, EXCLUSIVE &#125;;<br><br>  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">KillType</span> &#123; ALL_REQUEST, WRITE_REQUEST &#125;;<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">txn_id_t</span> MAX_ID = <span class="hljs-number">0x0fffffff</span>;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockRequest</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LockRequest</span>(Transaction *txn, <span class="hljs-type">txn_id_t</span> txn_id, LockMode lock_mode)<br>        : <span class="hljs-built_in">txn_id_</span>(txn_id), <span class="hljs-built_in">transation_</span>(txn), <span class="hljs-built_in">lock_mode_</span>(lock_mode), granted_&#123;<span class="hljs-literal">false</span>&#125; &#123;&#125;<br>    <span class="hljs-type">txn_id_t</span> txn_id_;<br>    Transaction *transation_;<br>    LockMode lock_mode_;<br>    <span class="hljs-type">bool</span> granted_;<br>  &#125;;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockRequestQueue</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SetpComparator</span> &#123;  <span class="hljs-comment">// 重载map的key值排序方式</span><br>      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> LockRequest &amp;lhs, <span class="hljs-type">const</span> LockRequest &amp;rhs)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> lhs.txn_id_ &lt; rhs.txn_id_; &#125;<br>    &#125;;<br><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// std::set&lt;LockRequest, SetpComparator&gt; request_queue_;</span><br>    <span class="hljs-comment">// 改用list实现</span><br>    std::list&lt;LockRequest&gt; request_queue_;<br>    <span class="hljs-comment">// for notifying blocked transactions on this rid</span><br>    std::condition_variable cv_;<br>    <span class="hljs-comment">// txn_id of an upgrading transaction (if any)</span><br>    <span class="hljs-type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;<br><br>    <span class="hljs-type">int</span> share_req_cnt_&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 当前持有S锁的事务个数</span><br><br>    RIDStatus status_;  <span class="hljs-comment">// 当前RID上的锁</span><br>  &#125;;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Creates a new lock manager configured for the deadlock prevention policy.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">LockManager</span>() = <span class="hljs-keyword">default</span>;<br><br>  ~<span class="hljs-built_in">LockManager</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * [LOCK_NOTE]: For all locking functions, we:</span><br><span class="hljs-comment">   * 1. return false if the transaction is aborted; and</span><br><span class="hljs-comment">   * 2. block on wait, return true when the lock request is granted; and</span><br><span class="hljs-comment">   * 3. it is undefined behavior to try locking an already locked RID in the</span><br><span class="hljs-comment">   * same transaction, i.e. the transaction is responsible for keeping track of</span><br><span class="hljs-comment">   * its current locks.</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Acquire a lock on RID in shared mode. See [LOCK_NOTE] in header file.</span><br><span class="hljs-comment">   * @param txn the transaction requesting the shared lock</span><br><span class="hljs-comment">   * @param rid the RID to be locked in shared mode</span><br><span class="hljs-comment">   * @return true if the lock is granted, false otherwise</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Acquire a lock on RID in exclusive mode. See [LOCK_NOTE] in header file.</span><br><span class="hljs-comment">   * @param txn the transaction requesting the exclusive lock</span><br><span class="hljs-comment">   * @param rid the RID to be locked in exclusive mode</span><br><span class="hljs-comment">   * @return true if the lock is granted, false otherwise</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Upgrade a lock from a shared lock to an exclusive lock.</span><br><span class="hljs-comment">   * @param txn the transaction requesting the lock upgrade</span><br><span class="hljs-comment">   * @param rid the RID that should already be locked in shared mode by the</span><br><span class="hljs-comment">   * requesting transaction</span><br><span class="hljs-comment">   * @return true if the upgrade is successful, false otherwise</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockUpgrade</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Release the lock held by the transaction.</span><br><span class="hljs-comment">   * @param txn the transaction releasing the lock, it should actually hold the</span><br><span class="hljs-comment">   * lock</span><br><span class="hljs-comment">   * @param rid the RID that is locked by the transaction</span><br><span class="hljs-comment">   * @return true if the unlock is successful, false otherwise</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KillRequest</span><span class="hljs-params">(<span class="hljs-type">txn_id_t</span> id, <span class="hljs-type">const</span> RID &amp;rid, KillType type)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AwakeSharedRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> RID &amp;rid)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ProcessRequest</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid, <span class="hljs-type">const</span> LockRequest &amp;req)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">UnlockImp</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  std::mutex latch_;<br><br>  <span class="hljs-comment">/** Lock table for lock requests. */</span><br>  std::unordered_map&lt;RID, LockRequestQueue&gt; lock_table_;<br>&#125;;<br><br>&#125;  <span class="hljs-comment">// namespace bustub</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// lock_manager.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;concurrency/lock_manager.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> bustub &#123;<br><span class="hljs-comment">// 如果中止事务持有锁，则不能擅自解锁，可能一直停留在队列中，如果未持有锁，则需要立即移除</span><br><span class="hljs-comment">// 杀死请求队列中优先级更小的请求，保证S锁请求前没有比其更年轻的X锁请求，X锁请求前没有比其更年轻的请求</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LockManager::KillRequest</span><span class="hljs-params">(<span class="hljs-type">txn_id_t</span> id, <span class="hljs-type">const</span> RID &amp;rid, KillType type)</span> </span>&#123;<br>  Transaction *transaction;<br>  <span class="hljs-type">bool</span> expr;<br>  <span class="hljs-keyword">auto</span> &amp;request_queue = lock_table_[rid].request_queue_;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  进行两次遍历，第一次遍历杀死所有未获得锁的低优先级请求并移出队列</span><br><span class="hljs-comment">  第二次遍历将获得锁的低优先级请求解锁后再中止事务，在解锁函数中已经将该请求移出队列</span><br><span class="hljs-comment">  之所以进行两次遍历是为了避免本该被杀死的未加锁的请求在前面加锁请求被杀死后获得锁，避免不必要的解锁操作</span><br><span class="hljs-comment">  所以说最好的遍历方式应该是反向遍历，但反向遍历删除容易产生迭代器失效问题，并且有时请求是在解锁函数中移除，不太好控制，故进行两次遍历</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">auto</span> iter = request_queue.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">while</span> (iter != request_queue.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 此时读请求不应该被杀死，对其取反</span><br>    expr = !(type == KillType::WRITE_REQUEST &amp;&amp; iter-&gt;lock_mode_ == LockMode::SHARED);<br>    transaction = iter-&gt;transation_;  <span class="hljs-comment">// 记录事务指针</span><br>    <span class="hljs-comment">// 将未获得锁的低优先级非中止事务变成中止事务</span><br>    <span class="hljs-keyword">if</span> (id &lt; iter-&gt;txn_id_ &amp;&amp; transaction-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED &amp;&amp; expr &amp;&amp; !iter-&gt;granted_) &#123;<br>      transaction-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    &#125;<br>    <span class="hljs-comment">// 移除未获得锁的中止事务请求</span><br>    <span class="hljs-keyword">if</span> (transaction-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED &amp;&amp; !iter-&gt;granted_) &#123;<br>      iter = request_queue.<span class="hljs-built_in">erase</span>(iter);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ++iter;<br>    &#125;<br>  &#125;<br>  iter = request_queue.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">while</span> (iter != request_queue.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 此时读请求不应该被杀死，对其取反</span><br>    expr = !(type == KillType::WRITE_REQUEST &amp;&amp; iter-&gt;lock_mode_ == LockMode::SHARED);<br>    transaction = iter-&gt;transation_;  <span class="hljs-comment">// 记录事务指针</span><br>    <span class="hljs-comment">// 对低优先级非中止事务进行操作</span><br>    <span class="hljs-keyword">if</span> (id &lt; iter-&gt;txn_id_ &amp;&amp; transaction-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED &amp;&amp; expr &amp;&amp; iter-&gt;granted_) &#123;<br>      ++iter;<br>      <span class="hljs-built_in">UnlockImp</span>(transaction, rid);  <span class="hljs-comment">// 调用解锁函数，同时将请求移出队列</span><br>      transaction-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ++iter;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 唤醒队首后连续的S锁请求</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LockManager::AwakeSharedRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> RID &amp;rid)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> &amp;request_queue = lock_table_[rid].request_queue_;<br>  <span class="hljs-built_in">assert</span>(lock_table_[rid].status_ == RIDStatus::SHARED);<br>  <span class="hljs-type">txn_id_t</span> max_id = MAX_ID;<br>  <span class="hljs-comment">// 若存在更新锁请求，则只能唤醒比其优先级更高的S锁请求</span><br>  <span class="hljs-keyword">if</span> (lock_table_[rid].upgrading_ != INVALID_TXN_ID) &#123;<br>    max_id = lock_table_[rid].upgrading_;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;req : request_queue) &#123;<br>    <span class="hljs-keyword">if</span> (req.lock_mode_ == LockMode::EXCLUSIVE) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!req.granted_ &amp;&amp; req.txn_id_ &lt; max_id) &#123;<br>      req.granted_ = <span class="hljs-literal">true</span>;<br>      lock_table_[rid].share_req_cnt_++;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockManager::LockShared</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> is_shared = txn-&gt;<span class="hljs-built_in">IsSharedLocked</span>(rid);<br>  <span class="hljs-keyword">auto</span> is_exc = txn-&gt;<span class="hljs-built_in">IsExclusiveLocked</span>(rid);<br>  <span class="hljs-keyword">auto</span> transaction_state = txn-&gt;<span class="hljs-built_in">GetState</span>();<br>  <span class="hljs-keyword">auto</span> isolation_level = txn-&gt;<span class="hljs-built_in">GetIsolationLevel</span>();<br>  <span class="hljs-keyword">auto</span> txn_id = txn-&gt;<span class="hljs-built_in">GetTransactionId</span>();<br><br>  <span class="hljs-keyword">if</span> (is_shared || is_exc) &#123;  <span class="hljs-comment">// 防止重复加锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (transaction_state != TransactionState::GROWING) &#123;  <span class="hljs-comment">// 判断当前是否为growing阶段</span><br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (isolation_level == IsolationLevel::READ_UNCOMMITTED) &#123;  <span class="hljs-comment">// 读未提交没有S锁(存在脏读)</span><br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-function">LockRequest <span class="hljs-title">req</span><span class="hljs-params">(txn, txn_id, LockMode::SHARED)</span></span>;<br><br>  <span class="hljs-keyword">if</span> (lock_table_.<span class="hljs-built_in">count</span>(rid) == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 当前资源未被占用,请求得到保证</span><br>    req.granted_ = <span class="hljs-literal">true</span>;<br>    lock_table_[rid].request_queue_.<span class="hljs-built_in">emplace_back</span>(req);<br>    lock_table_[rid].status_ = RIDStatus::SHARED;<br>    lock_table_[rid].share_req_cnt_ = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    lock_table_[rid].request_queue_.<span class="hljs-built_in">emplace_back</span>(req);<br>    LockRequest &amp;request_ref = lock_table_[rid].request_queue_.<span class="hljs-built_in">back</span>();  <span class="hljs-comment">// 保留请求引用</span><br>    <span class="hljs-built_in">KillRequest</span>(txn_id, rid, KillType::WRITE_REQUEST);                  <span class="hljs-comment">// 杀死所有低优先级X锁请求</span><br>    <span class="hljs-keyword">if</span> (lock_table_[rid].status_ == RIDStatus::SHARED) &#123;                <span class="hljs-comment">// 唤醒连续的S锁请求</span><br>      <span class="hljs-built_in">AwakeSharedRequest</span>(rid);<br>    &#125;<br>    lock_table_[rid].cv_.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 唤醒请求，防止中止事务一直等待</span><br>    <span class="hljs-keyword">while</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED &amp;&amp; !(request_ref.granted_)) &#123;  <span class="hljs-comment">// 事务中止或得到保证</span><br>      lock_table_[rid].cv_.<span class="hljs-built_in">wait</span>(lock);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED) &#123;  <span class="hljs-comment">// 在请求队列中删除未持有中止事务</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  txn-&gt;<span class="hljs-built_in">GetSharedLockSet</span>()-&gt;<span class="hljs-built_in">emplace</span>(rid);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockManager::LockExclusive</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> is_shared = txn-&gt;<span class="hljs-built_in">IsSharedLocked</span>(rid);  <span class="hljs-comment">// 防止重复加锁</span><br>  <span class="hljs-keyword">auto</span> is_exc = txn-&gt;<span class="hljs-built_in">IsExclusiveLocked</span>(rid);<br>  <span class="hljs-keyword">auto</span> transaction_state = txn-&gt;<span class="hljs-built_in">GetState</span>();<br>  <span class="hljs-keyword">auto</span> txn_id = txn-&gt;<span class="hljs-built_in">GetTransactionId</span>();<br><br>  <span class="hljs-keyword">if</span> (is_exc) &#123;  <span class="hljs-comment">// 防止重复加锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (is_shared) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (transaction_state != TransactionState::GROWING) &#123;  <span class="hljs-comment">// 判断当前是否为growing阶段</span><br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-function">LockRequest <span class="hljs-title">req</span><span class="hljs-params">(txn, txn_id, LockMode::EXCLUSIVE)</span></span>;<br>  <span class="hljs-keyword">if</span> (lock_table_.<span class="hljs-built_in">count</span>(rid) == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 当前资源未被占用</span><br>    req.granted_ = <span class="hljs-literal">true</span>;<br>    lock_table_[rid].request_queue_.<span class="hljs-built_in">emplace_back</span>(req);<br>    lock_table_[rid].status_ = RIDStatus::EXCLUSIVE;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 与LockShared函数一致的步骤</span><br>    lock_table_[rid].request_queue_.<span class="hljs-built_in">emplace_back</span>(req);<br>    LockRequest &amp;request_ref = lock_table_[rid].request_queue_.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-built_in">KillRequest</span>(txn_id, rid, KillType::ALL_REQUEST);      <span class="hljs-comment">// 杀死所有低优先级请求</span><br>    <span class="hljs-keyword">if</span> (lock_table_[rid].status_ == RIDStatus::SHARED) &#123;  <span class="hljs-comment">// 唤醒连续的S锁请求</span><br>      <span class="hljs-built_in">AwakeSharedRequest</span>(rid);<br>    &#125;<br>    lock_table_[rid].cv_.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 唤醒请求，防止中止事务一直等待</span><br>    <span class="hljs-keyword">while</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED &amp;&amp; !(request_ref.granted_)) &#123;  <span class="hljs-comment">// 事务中止或得到保证</span><br>      lock_table_[rid].cv_.<span class="hljs-built_in">wait</span>(lock);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  txn-&gt;<span class="hljs-built_in">GetExclusiveLockSet</span>()-&gt;<span class="hljs-built_in">emplace</span>(rid);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockManager::LockUpgrade</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> transaction_state = txn-&gt;<span class="hljs-built_in">GetState</span>();<br>  <span class="hljs-keyword">auto</span> txn_id = txn-&gt;<span class="hljs-built_in">GetTransactionId</span>();<br><br>  <span class="hljs-keyword">if</span> (transaction_state != TransactionState::GROWING) &#123;<br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!txn-&gt;<span class="hljs-built_in">IsSharedLocked</span>(rid)) &#123;  <span class="hljs-comment">// 如果自身未持有S锁</span><br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (lock_table_[rid].upgrading_ != INVALID_TXN_ID) &#123;  <span class="hljs-comment">// 已有更新请求</span><br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  lock_table_[rid].upgrading_ = txn_id;<br>  <span class="hljs-built_in">KillRequest</span>(txn_id, rid, KillType::ALL_REQUEST);  <span class="hljs-comment">// 杀死所有低优先级请求</span><br>  lock_table_[rid].cv_.<span class="hljs-built_in">notify_all</span>();                <span class="hljs-comment">// 唤醒请求，防止中止事务一直等待</span><br>  <span class="hljs-keyword">while</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED &amp;&amp;<br>         lock_table_[rid].share_req_cnt_ != <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 未被中止，等待S锁持有者只有自己</span><br>    lock_table_[rid].cv_.<span class="hljs-built_in">wait</span>(lock);<br>  &#125;<br>  lock_table_[rid].upgrading_ = INVALID_TXN_ID;  <span class="hljs-comment">// 将更新请求事务id重新置为无效</span><br>  <span class="hljs-keyword">if</span> (txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> request_location = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-built_in">assert</span>(request_location-&gt;txn_id_ == txn_id);  <span class="hljs-comment">// 队列第一位即该更新请求，此时没有中止事务持有锁</span><br>  request_location-&gt;lock_mode_ = LockMode::EXCLUSIVE;  <span class="hljs-comment">// 更改请求模式</span><br>  lock_table_[rid].share_req_cnt_ = <span class="hljs-number">0</span>;<br>  lock_table_[rid].status_ = RIDStatus::EXCLUSIVE;<br><br>  txn-&gt;<span class="hljs-built_in">GetSharedLockSet</span>()-&gt;<span class="hljs-built_in">erase</span>(rid);<br>  txn-&gt;<span class="hljs-built_in">GetExclusiveLockSet</span>()-&gt;<span class="hljs-built_in">emplace</span>(rid);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockManager::Unlock</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">UnlockImp</span>(txn, rid);<br>&#125;<br><span class="hljs-comment">// 实现unlock函数功能，但不加锁，便于KillRequest调用</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">LockManager::UnlockImp</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> -&gt; <span class="hljs-type">bool</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> is_shared = txn-&gt;<span class="hljs-built_in">IsSharedLocked</span>(rid);<br>  <span class="hljs-keyword">auto</span> is_exc = txn-&gt;<span class="hljs-built_in">IsExclusiveLocked</span>(rid);<br>  <span class="hljs-keyword">auto</span> state = txn-&gt;<span class="hljs-built_in">GetState</span>();<br>  <span class="hljs-keyword">auto</span> isolation_level = txn-&gt;<span class="hljs-built_in">GetIsolationLevel</span>();<br>  <span class="hljs-keyword">auto</span> txn_id = txn-&gt;<span class="hljs-built_in">GetTransactionId</span>();<br><br>  <span class="hljs-keyword">if</span> (!is_shared &amp;&amp; !is_exc) &#123;  <span class="hljs-comment">// 未持有锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 需提前判断事务当前状态，只在growing时才修改状态为shrinking</span><br>  <span class="hljs-keyword">if</span> (isolation_level == IsolationLevel::REPEATABLE_READ &amp;&amp; state == TransactionState::GROWING) &#123;<br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::SHRINKING);<br>  &#125;<br><br>  <span class="hljs-comment">// 在请求队列中删除该请求</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>(); iter != lock_table_[rid].request_queue_.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>    <span class="hljs-keyword">if</span> (iter-&gt;txn_id_ == txn_id) &#123;<br>      lock_table_[rid].request_queue_.<span class="hljs-built_in">erase</span>(iter);<br>      <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 删除后立即返回</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-type">bool</span> need_find_next_req = <span class="hljs-literal">true</span>;<br>  <span class="hljs-type">bool</span> exist_normal_request = <span class="hljs-literal">false</span>;<br>  LockMode next_req_mode;<br>  <span class="hljs-keyword">if</span> (is_shared) &#123;<br>    lock_table_[rid].share_req_cnt_--;<br>    <span class="hljs-keyword">if</span> (lock_table_[rid].share_req_cnt_ != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 仍有事务持有该锁，不应该释放</span><br>      need_find_next_req = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 下一个非中止请求，此时没有中止事务的等待请求，故第一个要么是正常请求，要么是中止事务的持有锁的请求，但第二种情况need_find_next_req为false</span><br>  <span class="hljs-keyword">auto</span> next_req_iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">if</span> (!lock_table_[rid].request_queue_.<span class="hljs-built_in">empty</span>()) &#123;<br>    exist_normal_request = <span class="hljs-literal">true</span>;<br>    next_req_mode = next_req_iter-&gt;lock_mode_;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (need_find_next_req &amp;&amp; exist_normal_request) &#123;  <span class="hljs-comment">// 给予一些请求保证</span><br>    <span class="hljs-keyword">if</span> (next_req_mode == LockMode::SHARED) &#123;<br>      lock_table_[rid].status_ = RIDStatus::SHARED;<br>      <span class="hljs-built_in">AwakeSharedRequest</span>(rid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lock_table_[rid].status_ = RIDStatus::EXCLUSIVE;<br>      next_req_iter-&gt;granted_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  lock_table_[rid].cv_.<span class="hljs-built_in">notify_all</span>();  <span class="hljs-comment">// 唤醒请求</span><br><br>  <span class="hljs-keyword">if</span> (need_find_next_req &amp;&amp; !exist_normal_request) &#123;  <span class="hljs-comment">// 请求队列没有请求</span><br>    lock_table_.<span class="hljs-built_in">erase</span>(rid);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (is_shared) &#123;<br>    txn-&gt;<span class="hljs-built_in">GetSharedLockSet</span>()-&gt;<span class="hljs-built_in">erase</span>(rid);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (is_exc) &#123;<br>    txn-&gt;<span class="hljs-built_in">GetExclusiveLockSet</span>()-&gt;<span class="hljs-built_in">erase</span>(rid);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;  <span class="hljs-comment">// namespace bustub</span><br><br></code></pre></td></tr></table></figure>

<p> <strong>其他：</strong><br> notify_one()方法：</p>
<blockquote>
<p>Unblocks one of the threads currently waiting for this condition. If no threads are waiting, the function does nothing. If more than one, it is unspecified which of the threads is selected.                                                                                                                    </p>
</blockquote>
<p>notify_one()方法只是随机唤醒一个线程，所以用notify_all方法比较好，只要不给请求保证，即使请求被唤醒，仍然会等待。</p>
<p><strong>auto与类型推导规则类似，会忽略引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> b = &amp;a;<br><span class="hljs-keyword">auto</span> c = b;		<span class="hljs-comment">// c为int类型</span><br><span class="hljs-keyword">auto</span>&amp; c = b;	<span class="hljs-comment">// c为int&amp;类型</span><br></code></pre></td></tr></table></figure>
<p>见《efficientive modern c++》第一章</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;string, <span class="hljs-type">int</span>&gt; mymap1;  <br><span class="hljs-keyword">auto</span> val = mymap1[<span class="hljs-string">&quot;str&quot;</span>]; <span class="hljs-comment">// val为0   </span><br><br><span class="hljs-comment">// 常用于词频统计，存在则加一，不存在则创建后赋值为1 </span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; mymap2;  <br>mymap2[<span class="hljs-string">&quot;str&quot;</span>]++; <span class="hljs-comment">// mymap2[&quot;str&quot;] = 1   </span><br>``<br><br>Map中使用方括号访问键对应的值map[key]时：<br>若该key存在，则访问取得value值；<br>若该key不存在，访问仍然成功，取得value对象默认构造的值。具体如下：<br>用 []访问，但key不存在时，C++会利用该key及默认构造的value，组成&#123;key，value&#125;对，插入到map中。<br>value为 string对象，则构造空串；value为<span class="hljs-type">int</span>对象，构造为<span class="hljs-number">0</span>。<br>注：因此在访问map元素时，应先用map.find查找该元素，找到后再访问。 同时，用法mymap2[<span class="hljs-string">&quot;str&quot;</span>]++;常用于词频统计，存在则加一，不存在则创建后赋值为<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure>
<p><strong>修改set元素的方法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">优先队列不能修改任意位置的值，而set不能直接修改值，只能间接地修改（修改后不影响排序的值）<br><br> <span class="hljs-number">1.</span> 先删除，再插入<br> <span class="hljs-number">2.</span> 将要修改的值存储为指针<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LockRequest</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LockRequest</span>(Transaction *txn, <span class="hljs-type">txn_id_t</span> txn_id, LockMode lock_mode) : <span class="hljs-built_in">txn_id_</span>(txn_id), <span class="hljs-built_in">transation_</span>(txn) &#123;<br>        lock_mode_ = std::<span class="hljs-built_in">make_shared</span>&lt;LockMode&gt;(lock_mode);<br>        granted_ = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-type">txn_id_t</span> txn_id_;<br>    Transaction *transation_;<br>    std::shared_ptr&lt;LockMode&gt; lock_mode_;<br>    std::shared_ptr&lt;<span class="hljs-type">bool</span>&gt; granted_;<br>&#125;;<br><span class="hljs-number">3.</span>移除常量性<br><span class="hljs-keyword">auto</span> iter = lock_table_[rid].request_queue_.<span class="hljs-built_in">begin</span>();    <span class="hljs-comment">// 实际上这时候更新请求就在队列第一位</span><br><span class="hljs-keyword">auto</span>&amp; req = <span class="hljs-built_in">const_cast</span>&lt;LockRequest&amp;&gt;(*iter);<br></code></pre></td></tr></table></figure>
<p><strong>等价与相等</strong></p>
<p>等价是基于在一个有序区间中对象值的相对位置。</p>
<p>两个值如果没有哪个在另一个之前（关于某个排序标准），那么它们等价</p>
<p>相等的概念是基于operator&#x3D;&#x3D;的。如果表达式“x &#x3D;&#x3D; y”返回true，x和y有相等的值<br>详细论述见《Effective STL》</p>
<blockquote>
<p>gdb调试奇怪的地方</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">table_info_-&gt;table_-&gt;<span class="hljs-built_in">InsertTuple</span>(insert_tuple, &amp;insert_rid, transaction);  <span class="hljs-comment">// insert_rid此时才被赋值</span><br><br>std::cout &lt;&lt; insert_rid.<span class="hljs-built_in">ToString</span>() &lt;&lt; std::endl;<br>transaction-&gt;<span class="hljs-built_in">AppendTableWriteRecord</span>(<br>    TableWriteRecord&#123;insert_rid, WType::INSERT, insert_tuple, table_info_-&gt;table_.<span class="hljs-built_in">get</span>()&#125;);  <span class="hljs-comment">// 维护WriteSet</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/0685df0ced9940af94d746de5f9dc5b7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="加粗样式"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TableHeap::InsertTuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;tuple, RID *rid, Transaction *txn)</span> </span>&#123;<br>  <span class="hljs-comment">// Update the transaction&#x27;s write set.</span><br>  txn-&gt;<span class="hljs-built_in">GetWriteSet</span>()-&gt;<span class="hljs-built_in">emplace_back</span>(*rid, WType::INSERT, Tuple&#123;&#125;, <span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在不知道InsertTuple实际上已经维护了write set时，我在代码中使用AppendTableWriteRecord语句记录write set。记录两次当事务中止时第二次删除为空，便会报错。当我gdb调试，看为什么为有两个相同的项时，发现gdb的执行顺序非常奇怪，而且AppendTableWriteRecord看起来非常奇怪，而且就算把TableWriteRecord单独拿出来，看起来还是会执行两次（当然实际上只执行了一次）</p>
<blockquote>
<p>debug 模式与正常模式</p>
</blockquote>
<p>不知道为什么，有时候debug模式测试能通过，正常模式不能通过。有时候正常模式能通过，debug模式不能通过<br>以下第一种情况我觉得都不应该通过测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;item : lock_table_[rid].request_queue_) &#123;  <span class="hljs-comment">// 在请求队列中删除该请求</span><br>    <span class="hljs-keyword">if</span> (item.txn_id_ == txn_id) &#123;<br>        lock_table_[rid].request_queue_.<span class="hljs-built_in">erase</span>(item);<br>    &#125;<br>&#125;<br>改成<br>删除一个元素就退出<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;item : lock_table_[rid].request_queue_) &#123;  <span class="hljs-comment">// 在请求队列中删除该请求</span><br>    <span class="hljs-keyword">if</span> (item.txn_id_ == txn_id) &#123;<br>        lock_table_[rid].request_queue_.<span class="hljs-built_in">erase</span>(item);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br>否则使用这种形式<br><span class="hljs-keyword">auto</span> iter = queue.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(iter!=queue.<span class="hljs-built_in">end</span>())&#123;<br>    <span class="hljs-keyword">if</span>(删除元素)&#123;<br>        iter = queue.<span class="hljs-built_in">erase</span>(iter);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        ++iter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;一个加锁的函数调用另一个需要加锁的函数便会产生死锁&#x3D;&#x3D;</p>
<h3 id="8-10更新-在线测试文件获取"><a href="#8-10更新-在线测试文件获取" class="headerlink" title="8-10更新&#x2F;在线测试文件获取"></a>8-10更新&#x2F;在线测试文件获取</h3><p>1 可以通过以下函数获取在线测试文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetTestFileContent</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">bool</span> first_enter = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (first_enter) &#123;<br>    <span class="hljs-comment">//  截取gradescope日志输出文件名</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    std::vector&lt;std::string&gt; all_filenames = &#123;</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/primer/grading_starter_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_update_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_nested_loop_join_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_limit_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_executor_benchmark_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/concurrency/grading_lock_manager_3_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/buffer/grading_parallel_buffer_pool_manager_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/buffer/grading_lru_replacer_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_executor_integrated_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_sequential_scan_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/concurrency/grading_lock_manager_1_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_distinct_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/buffer/grading_buffer_pool_manager_instance_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/concurrency/grading_lock_manager_2_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/concurrency/grading_transaction_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/buffer/grading_leaderboard_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/container/grading_hash_table_verification_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/concurrency/grading_rollback_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/container/grading_hash_table_concurrent_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/container/grading_hash_table_page_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/concurrency/grading_lock_manager_detection_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/container/grading_hash_table_leaderboard_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/container/grading_hash_table_scale_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/container/grading_hash_table_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_aggregation_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_insert_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_delete_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_hash_join_executor_test.cpp&quot;</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_sequential_scan_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_update_executor_test.cpp&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/test/execution/grading_executor_test_util.h&quot;,</span><br><span class="hljs-comment">        &quot;/autograder/bustub/src/include/execution/plans/mock_scan_plan.h&quot;,</span><br><span class="hljs-comment">        &#125;;</span><br><span class="hljs-comment">    */</span><br>    std::vector&lt;std::string&gt; filenames = &#123;<br>        <span class="hljs-string">&quot;/autograder/bustub/test/execution/grading_executor_integrated_test.cpp&quot;</span>,<br>        <span class="hljs-string">&quot;/autograder/bustub/test/execution/grading_executor_benchmark_test.cpp&quot;</span>,<br>    &#125;;<br>    std::ifstream fin;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> std::string &amp;filename : filenames) &#123;<br>      fin.<span class="hljs-built_in">open</span>(filename, std::ios::in);<br>      <span class="hljs-keyword">if</span> (!fin.<span class="hljs-built_in">is_open</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;cannot open the file:&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-type">char</span> buf[<span class="hljs-number">200</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>      std::cout &lt;&lt; filename &lt;&lt; std::endl;<br>      <span class="hljs-keyword">while</span> (fin.<span class="hljs-built_in">getline</span>(buf, <span class="hljs-built_in">sizeof</span>(buf))) &#123;<br>        std::cout &lt;&lt; buf &lt;&lt; std::endl;<br>      &#125;<br>      fin.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    first_enter = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>但不知道为什么打印在线的测试文件输出不会换行，只能复制至vscode，而后全局替换\n，代码中有些还需要进行少量修改</p>
<p>2 重写时发现的问题，其中许多与gradesope测试程序有关，我倒不怎么觉得是我的问题<br>buffer实验中flush&#x2F;flush all不需要判断是否dirty，HardTestD有时候错误就是因为这个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">/*</span><br><span class="hljs-comment">if (pages_[frame_id].IsDirty()) &#123;</span><br><span class="hljs-comment">  disk_manager_-&gt;WritePage(page_id, pages_[frame_id].data_);</span><br><span class="hljs-comment">  pages_[frame_id].is_dirty_ = false;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">我本来以为只有dirty时才进行页的写入，但parallel_buffer_pool_manager_test.cpp 942-944行的逻辑表明不是这样的</span><br><span class="hljs-comment">strcpy(page-&gt;GetData(), std::to_string(temp_page_id).c_str());  // NOLINT</span><br><span class="hljs-comment">// FLush page instead of unpining with true</span><br><span class="hljs-comment">EXPECT_EQ(1, bpm-&gt;FlushPage(temp_page_id, nullptr));</span><br><span class="hljs-comment">EXPECT_EQ(1, bpm-&gt;UnpinPage(temp_page_id, false, nullptr));</span><br><span class="hljs-comment">*/</span><br>disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page_id, pages_[frame_id].data_);<br>pages_[frame_id].is_dirty_ = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<p>hash实验中HashTableBucketPage的数组类型改成unsigned char，这样就能直接与0xff之类的进行比较，而不用强制转换<br>ExtendibleHashTable中直接缓存目录页，使用更简单的方式寻找桶</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 首先遍历一遍目录，将仍指向旧桶的位置深度加一</span><br><br><span class="hljs-comment">// for (uint32_t i = 0; i &lt; dir_size; i++) &#123;</span><br><span class="hljs-comment">//   if ((i &amp; new_local_mask) == old_local_hash) &#123;</span><br><span class="hljs-comment">//     dir_page_-&gt;IncrLocalDepth(i);</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 实现与上面代码一样的功能</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = old_local_hash; i &lt; dir_size; i += new_local_mask + <span class="hljs-number">1</span>) &#123;<br>    dir_page_-&gt;<span class="hljs-built_in">IncrLocalDepth</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3 最近拉取的代码与我之前拉取的代码有挺大的不同，最近拉取的代码都使用auto fun() -&gt; type的形式，不知道为啥使用这种方式，并且AppendTableWriteRecord IndexWriteRecord接口也发生了改变，之前update不能更新索引的问题也得到了解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexWriteRecord</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">IndexWriteRecord</span>(RID rid, <span class="hljs-type">table_oid_t</span> table_oid, WType wtype, <span class="hljs-type">const</span> Tuple &amp;tuple, <span class="hljs-type">const</span> Tuple &amp;old_tuple,<br>                   <span class="hljs-type">index_oid_t</span> index_oid, Catalog *catalog)<br>      : <span class="hljs-built_in">rid_</span>(rid),<br>        <span class="hljs-built_in">table_oid_</span>(table_oid),<br>        <span class="hljs-built_in">wtype_</span>(wtype),<br>        <span class="hljs-built_in">tuple_</span>(tuple),<br>        <span class="hljs-built_in">old_tuple_</span>(old_tuple),<br>        <span class="hljs-built_in">index_oid_</span>(index_oid),<br>        <span class="hljs-built_in">catalog_</span>(catalog) &#123;&#125;<br><br>  <span class="hljs-comment">/** The rid is the value stored in the index. */</span><br>  RID rid_;<br>  <span class="hljs-comment">/** Table oid. */</span><br>  <span class="hljs-type">table_oid_t</span> table_oid_;<br>  <span class="hljs-comment">/** Write type. */</span><br>  WType wtype_;<br>  <span class="hljs-comment">/** The tuple is used to construct an index key. */</span><br>  Tuple tuple_;<br>  <span class="hljs-comment">/** The old tuple is only used for the update operation. */</span><br>  Tuple old_tuple_;<br>  <span class="hljs-comment">/** Each table has an index list, this is the identifier of an index into the list. */</span><br>  <span class="hljs-type">index_oid_t</span> index_oid_;<br>  <span class="hljs-comment">/** The catalog contains metadata required to locate index. */</span><br>  Catalog *catalog_;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>但由于虽然本地代码接口变了，但测试程序没变，故打包时需加上src&#x2F;include&#x2F;concurrency&#x2F;transaction.h<br>error: The left operand of ‘&#x3D;&#x3D;’ is a garbage value: 需加上src&#x2F;include&#x2F;storage&#x2F;page&#x2F;tmp_tuple_page.h</p>
<p>4 lab4我也懒得与测试程序反着来了，直接用list实现算了（虽然我觉得用优先队列的方式才是最好的，但测试程序的逻辑太奇怪了），而后把一些功能一致的代码提取成函数，这样看起来就简洁一点了</p>
<p>5 lab4提交时出现heap-buffer-overflow问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">==<span class="hljs-number">3699</span>== Invalid read of size <span class="hljs-number">4</span><br>==<span class="hljs-number">3699</span>==    at <span class="hljs-number">0x4FB8C4A</span>: bustub::IntegerType::<span class="hljs-built_in">DeserializeFrom</span>(<span class="hljs-type">char</span> <span class="hljs-type">const</span>*) <span class="hljs-built_in">const</span> (in /autograder/bustub/build/lib/libbustub_shared.so)<br>==<span class="hljs-number">3699</span>==    by <span class="hljs-number">0x4F9FAD0</span>: bustub::Value::<span class="hljs-built_in">DeserializeFrom</span>(<span class="hljs-type">char</span> <span class="hljs-type">const</span>*, bustub::TypeId) (in /autograder/bustub/build/lib/libbustub_shared.so)<br>==<span class="hljs-number">3699</span>==    by <span class="hljs-number">0x4FAC077</span>: bustub::Tuple::<span class="hljs-built_in">GetValue</span>(bustub::Schema <span class="hljs-type">const</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) <span class="hljs-built_in">const</span> (in /autograder/bustub/build/lib/libbustub_shared.so)<br>==<span class="hljs-number">3699</span>==    by <span class="hljs-number">0x4FAC163</span>: bustub::Tuple::<span class="hljs-built_in">KeyFromTuple</span>(bustub::Schema <span class="hljs-type">const</span>&amp;, bustub::Schema <span class="hljs-type">const</span>&amp;, std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-type">const</span>&amp;) (in <br></code></pre></td></tr></table></figure>
<p>对照TransactionManager::Abort可以看出IndexWriteRecord中tuple是元组而不是索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Rollback index updates</span><br><span class="hljs-keyword">auto</span> index_write_set = txn-&gt;<span class="hljs-built_in">GetIndexWriteSet</span>();<br><span class="hljs-keyword">while</span> (!index_write_set-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>  <span class="hljs-keyword">auto</span> &amp;item = index_write_set-&gt;<span class="hljs-built_in">back</span>();<br>  <span class="hljs-keyword">auto</span> catalog = item.catalog_;<br>  <span class="hljs-comment">// Metadata identifying the table that should be deleted from.</span><br>  TableInfo *table_info = catalog-&gt;<span class="hljs-built_in">GetTable</span>(item.table_oid_);<br>  IndexInfo *index_info = catalog-&gt;<span class="hljs-built_in">GetIndex</span>(item.index_oid_);<br>  <span class="hljs-keyword">auto</span> new_key = item.tuple_.<span class="hljs-built_in">KeyFromTuple</span>(table_info-&gt;schema_, *(index_info-&gt;index_-&gt;<span class="hljs-built_in">GetKeySchema</span>()),<br>                                          index_info-&gt;index_-&gt;<span class="hljs-built_in">GetKeyAttrs</span>());<br>  <span class="hljs-keyword">if</span> (item.wtype_ == WType::DELETE) &#123;<br>    index_info-&gt;index_-&gt;<span class="hljs-built_in">InsertEntry</span>(new_key, item.rid_, txn);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.wtype_ == WType::INSERT) &#123;<br>    index_info-&gt;index_-&gt;<span class="hljs-built_in">DeleteEntry</span>(new_key, item.rid_, txn);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.wtype_ == WType::UPDATE) &#123;<br>    <span class="hljs-comment">// Delete the new key and insert the old key</span><br>    index_info-&gt;index_-&gt;<span class="hljs-built_in">DeleteEntry</span>(new_key, item.rid_, txn);<br>    <span class="hljs-keyword">auto</span> old_key = item.old_tuple_.<span class="hljs-built_in">KeyFromTuple</span>(table_info-&gt;schema_, *(index_info-&gt;index_-&gt;<span class="hljs-built_in">GetKeySchema</span>()),<br>                                                index_info-&gt;index_-&gt;<span class="hljs-built_in">GetKeyAttrs</span>());<br>    index_info-&gt;index_-&gt;<span class="hljs-built_in">InsertEntry</span>(old_key, item.rid_, txn);<br>  &#125;<br>  index_write_set-&gt;<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2020-b-树"><a href="#2020-b-树" class="headerlink" title="2020 b+树"></a>2020 b+树</h3><p><a href="https://www.jiasun.top/blog/CMU15445%202020%20B+TREE%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95.html">CMU15445 2020 B+TREE简单记录</a></p>
<h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/twentyonepilots/article/details/120868216">CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JayL-zxl/p/14311883.html">CMU数据库（15-445）实验1-BufferPoolManager</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/382151977">CMU 15445 Project 1 Buffer Pool | 手摸手带你撸一个内存管理池</a><br><a target="_blank" rel="noopener" href="https://ravenxrz.ink/archives/2fda900.html">CMU-15445-proj3(QueryExecutor)</a></p>
<p>其中对我帮助最大的便是CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb这篇</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9B%BD%E5%A4%96%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/" class="category-chain-item">国外课程实验</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/cmu-15445-hash-index-buffer-pool-query-execution-concurrency/" class="print-no-link">#cmu 15445 hash index buffer pool query execution concurrency</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/vscode%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BD%E8%AE%B0%E5%BD%95!%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C.html" title="vscode彻底卸载记录/使用经验">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">vscode彻底卸载记录/使用经验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/CMU15445%20buffer%20pool%202021.html" title="CMU15445 buffer pool 2021">
                        <span class="hidden-mobile">CMU15445 buffer pool 2021</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz","appKey":"0e2MMh7ddBCGGytOe9UEy5NP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://uu0wegco.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
