<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/main.jpg"><link rel="icon" href="/img/main.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="xv6 book记录竞态 1234567891011121314struct element &amp;#123;	int data;	struct element *next;&amp;#125;;struct element *list &#x3D; 0;void push(int data)&amp;#123;	struct element *l;	l &#x3D; malloc(sizeof *l);	l-&gt;data &#x3D;"><meta property="og:type" content="article"><meta property="og:title" content="MIT6.S081 2021 locks"><meta property="og:url" content="https://www.jiasun.top/blog/MIT6.S081%202021%20locks.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="xv6 book记录竞态 1234567891011121314struct element &amp;#123;	int data;	struct element *next;&amp;#125;;struct element *list &#x3D; 0;void push(int data)&amp;#123;	struct element *l;	l &#x3D; malloc(sizeof *l);	l-&gt;data &#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/6e9aa2a2ed3d400d90854f0ca8d092d0.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/bb9d5b4e16fb4b2999d648b1bc66488e.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/b3c44c1405ba4d619b5f0eb0c88ddbf9.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/86abbcad3a9e4e5fa02182f53ef29947.png"><meta property="article:published_time" content="2022-08-29T07:36:18.000Z"><meta property="article:modified_time" content="2023-10-31T14:45:58.876Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="6.081 locks"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/6e9aa2a2ed3d400d90854f0ca8d092d0.png"><title>MIT6.S081 2021 locks - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="MIT6.S081 2021 locks"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-29 15:36" pubdate>2022年8月29日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 18k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 149 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">MIT6.S081 2021 locks</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><h2 id="xv6-book记录"><a href="#xv6-book记录" class="headerlink" title="xv6 book记录"></a>xv6 book记录</h2><p><strong>竞态</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> &#123;</span><br>	<span class="hljs-type">int</span> data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">list</span> =</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">l</span>;</span><br>	l = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>	l-&gt;data = data;<br>	l-&gt;next = <span class="hljs-built_in">list</span>;<br>	<span class="hljs-built_in">list</span> = l;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6e9aa2a2ed3d400d90854f0ca8d092d0.png" srcset="/img/loading.gif" lazyload><br>race condition：以图中顺序执行指令，CPU2的更新丢失<br>竞争常常造成丢失更新或读到部分更新问题，竞争的结果取决于CPU的执行顺序，内存操作的重排序，它的结果是很微妙的，调试时一条输出语句就能改变执行顺序，使得bug无法复现。</p><blockquote><p>adding print statements while debugging push might change the timing of the execution enough to make the race disappear.</p></blockquote><p>通过适当地加锁可以解决竞态问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">list</span> =</span> <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">listlock</span>;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">element</span> *<span class="hljs-title">l</span>;</span><br>	l = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> *l);<br>	l-&gt;data = data;<br>	acquire(&amp;listlock);<br>	l-&gt;next = <span class="hljs-built_in">list</span>;<br>	<span class="hljs-built_in">list</span> = l;<br>	release(&amp;listlock);<br>&#125;<br></code></pre></td></tr></table></figure><p>acquire和release之间的代码段被称为临界区，当我们使用锁保护特定数据时，实际上是指保护该数据的一些不变量，这有点像ACID中的一致性：<strong>对数据的一组特定约束必须始终成立。即不变量（invariants）</strong>。</p><p>在临界区中的操作可能会破坏这些不变量，但此时其他线程由于锁的存在无法访问该数据，只需要临界区结束前约束成立即可。在以上示例中，约束便是：list需指向链表头部节点，执行完临界区第一行代码后约束便被破坏了，第二行代码重新满足了约束。</p><p>可以通过重新设计数据结构与相应的算法来缓解锁争用问题。</p><p><strong>自旋锁的实现</strong><br>version1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span> <span class="hljs-comment">// does not work!</span><br>&#123;<br>	<span class="hljs-keyword">for</span>(;;) &#123;<br>		<span class="hljs-keyword">if</span>(lk-&gt;locked == <span class="hljs-number">0</span>) &#123;<br>			lk-&gt;locked = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上实现中可能两个线程同时进入条件语句内部并获得锁，不符合互斥锁的语义。所以说需要让查询和设置语句一起拥有原子性。利用amoswap原子交换指令实现这个要求，以小的原子性获取大的原子性。<br><img src="https://img-blog.csdnimg.cn/bb9d5b4e16fb4b2999d648b1bc66488e.png" srcset="/img/loading.gif" lazyload><br>另外，许多编译器和CPU会对代码进行指令重排，乱序执行以获取更高的性能，为了不让临界区代码移出临界区，使用内存屏障，告知编译器和CPU不对屏障内部的load store指令进行重排。</p><p><strong>锁</strong></p><blockquote><p>it’s hard to reliably test whether code is free from locking errors and races.<br>很难通过可靠的测试来判断代码是否存在锁错误与竞态<br>Ultimately lock granularity decisions need to be driven by performance measurements as well as complexity considerations.<br>锁的粒度取决于性能需求与复杂度考量</p></blockquote><p><img src="https://img-blog.csdnimg.cn/b3c44c1405ba4d619b5f0eb0c88ddbf9.png" srcset="/img/loading.gif" lazyload><br>通过在代码中以相同顺序请求锁来避免死锁问题，锁粒度越小越容易发生死锁问题。</p><p>可重入锁也不能真正解决死锁问题，而且可能引入逻辑错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><span class="hljs-type">int</span> data = <span class="hljs-number">0</span>; <span class="hljs-comment">// protected by lock</span><br>f() &#123;<br>	acquire(&amp;lock);<br>	<span class="hljs-keyword">if</span>(data == <span class="hljs-number">0</span>)&#123;<br>		call_once();<br>		h();<br>		data = <span class="hljs-number">1</span>;<br>	&#125;<br>	release(&amp;lock);<br>&#125;<br>g() &#123;<br>	aquire(&amp;lock);<br>	<span class="hljs-keyword">if</span>(data == <span class="hljs-number">0</span>)&#123;<br>		call_once();<br>		data = <span class="hljs-number">1</span>;<br>	&#125;<br>	release(&amp;lock);<br>	&#125;<br></code></pre></td></tr></table></figure><p>如果h函数里面调用g函数，则call_once执行了两次。</p><blockquote><p>if a spinlock is used by an interrupt handler, a CPU must never hold that lock with interrupts enabled. Xv6 is more conservative: when a CPU acquires any lock, xv6 always disables interrupts on that CPU. Interrupts may still occur on other CPUs, so an interrupt’sacquire can wait for a thread to release a spinlock; just not on the same CPU.</p></blockquote><p>如果一个自旋锁同时也被中断处理程序使用，那么获取锁前需关闭中断，而xv6采用更加保守的方式：直接在申请自旋锁前关闭中断。中断处理程序可以与另一个CPU的进程竞争自旋锁</p><blockquote><p>Holding a spinlock that long would lead to waste if another process wanted to acquire it, since the acquiring process would waste CPU for a long time while spinning. Another drawback of spinlocks is that a process cannot yield the CPU while retaining a spinlock</p></blockquote><p>长时间持有自旋锁会浪费其他正在请求该锁的线程的CPU资源，并且一旦持有自旋锁该线程就不能让出CPU（调用休眠函数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">acquiresleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span><br>&#123;<br>  acquire(&amp;lk-&gt;lk);<br>  <span class="hljs-keyword">while</span> (lk-&gt;locked) &#123;<br>    sleep(lk, &amp;lk-&gt;lk);<br>  &#125;<br>  lk-&gt;locked = <span class="hljs-number">1</span>;<br>  lk-&gt;pid = myproc()-&gt;pid;<br>  release(&amp;lk-&gt;lk);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">releasesleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span><br>&#123;<br>  acquire(&amp;lk-&gt;lk);<br>  lk-&gt;locked = <span class="hljs-number">0</span>;<br>  lk-&gt;pid = <span class="hljs-number">0</span>;<br>  wakeup(lk);<br>  release(&amp;lk-&gt;lk);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可休眠锁不能在中断处理程序中使用，也不能在持有自旋锁时调用<br>总的来说，自旋锁适合短临界区，休眠锁适合长临界区。</p><blockquote><p>Lock-free programming is more complicated, however, than programming locks; for example, one must worry about instruction and memory reordering.</p></blockquote><p>无锁数据结构和算法非常复杂，需要考虑指令重排与内存操作重排序问题</p><p><strong>重回并发性问题</strong></p><blockquote><p>This is a common pattern: one lock for the set of items, plus one lock per item</p></blockquote><p>使用一个大锁对应于数据集合，小锁对应于单独的数据</p><blockquote><p>Ordinarily the same function that acquires a lock will release it. But a more precise way to view things is that a lock is acquired at the start of a sequence that must appear atomic, and released when that sequence ends</p></blockquote><p>加锁操作位于想要表现原子性的操作前，解锁操作位于想要表现原子性的操作后</p><blockquote><p>freeing the object implicitly frees the embedded lock, which will cause the waiting thread to malfunction.</p></blockquote><p>假如数据结构的释放也由其内嵌的锁控制的的话，一旦该数据结构释放，则其他同时请求该锁的线程则会‘失灵’，使用引用计数来解决该问题</p><blockquote><p>The file system uses struct inode reference counts as a kind of shared lock that can be held by multiple processes, in order to avoid deadlocks that would occur if the code used ordinary locks.</p></blockquote><p>就像iget函数操作一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Find the inode with number inum on device dev</span><br><span class="hljs-comment">// and return the in-memory copy. Does not lock</span><br><span class="hljs-comment">// the inode and does not read it from disk.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">iget</span><span class="hljs-params">(uint dev, uint inum)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">empty</span>;</span><br><br>  acquire(&amp;itable.lock);<br><br>  <span class="hljs-comment">// Is the inode already in the table?</span><br>  empty = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(ip = &amp;itable.inode[<span class="hljs-number">0</span>]; ip &lt; &amp;itable.inode[NINODE]; ip++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;ref &gt; <span class="hljs-number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;<br>      ip-&gt;ref++;<br>      release(&amp;itable.lock);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span> &amp;&amp; ip-&gt;ref == <span class="hljs-number">0</span>)    <span class="hljs-comment">// Remember empty slot.</span><br>      empty = ip;<br>  &#125;<br><br>  <span class="hljs-comment">// Recycle an inode entry.</span><br>  <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;iget: no inodes&quot;</span>);<br><br>  ip = empty;<br>  ip-&gt;dev = dev;<br>  ip-&gt;inum = inum;<br>  ip-&gt;ref = <span class="hljs-number">1</span>;<br>  ip-&gt;valid = <span class="hljs-number">0</span>;<br>  release(&amp;itable.lock);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>Some data items are protected by different mechanisms at different times<br>For example, when a physical page is free, it is protected by kmem.lock (kernel&#x2F;kalloc.c:24). If the page is then allocated as a pipe (kernel&#x2F;pipe.c:23), it is protected by a different lock (the embedded pi-&gt;lock).</p></blockquote><p>同一个数据结构可能在不同时刻由不同的锁保护，这实际上与它的使用方式有关</p><p><strong>物理内存分配</strong></p><blockquote><p>The allocator sometimes treats addresses as integers in order to perform arithmetic on them (e.g., traversing all pages in freerange), and sometimes uses addresses as pointers to read and write memory (e.g., manipulating the run structure stored in each page); this dual use of addresses is the main reason that the allocator code is full of C type casts. The other reason is that freeing and allocation inherently change the type of the memory.</p></blockquote><p><strong>文件系统缓存层</strong><br>The buffer cache layer caches disk blocks and synchronizes access to them, making sure that only one kernel process at a time can modify the data stored in any particular block.</p><p>The sleep-lock protects reads and writes of the block’s buffered content, while the bcache.lock protects information about which blocks are cached.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> &#123;</span><br>  <span class="hljs-type">int</span> valid;   <span class="hljs-comment">// has data been read from disk?</span><br>  <span class="hljs-type">int</span> disk;    <span class="hljs-comment">// does disk &quot;own&quot; buf?</span><br>  uint dev;<br>  uint blockno;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span><br>  uint refcnt;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">// LRU cache list</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">next</span>;</span><br>  uchar data[BSIZE];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; bcache;<br></code></pre></td></tr></table></figure><p>与上述锁模式相同，使用bcache.lock保护缓存集合，buf.lcok保护单个buffer的数据</p><h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><blockquote><p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. You must give all of your locks names that start with “kmem”. That is, you should call initlock for each of your locks, and pass a name that starts with “kmem”. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run usertests sbrkmuch. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in usertests pass. make grade should say that the kalloctests pass.</p></blockquote><p>该部分比较简单，原先的设计是所有CPU共同使用一个空闲页列表，在申请内存或释放内存时需请求同一个锁，造成锁争用问题。故修改数据结构，让每一个CPU都拥有自己的空闲页列表。在初始化时划分划分一定数目的物理页给各个CPU；在申请内存时，每个CPU首先从自己所属的空闲页列表获取内存，若为空则从其他CPU所属空闲页列表获取一定数目的空闲页；内存释放时则将页挂载到对应CPU的空闲页列表。实现比较简单，重点是steal_free_page函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Physical memory allocator, for user processes,</span><br><span class="hljs-comment">// kernel stacks, page-table pages,</span><br><span class="hljs-comment">// and pipe buffers. Allocates whole 4096-byte pages.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STEAL_NUMBER 200</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];  <span class="hljs-comment">// first address after kernel.</span><br>                    <span class="hljs-comment">// defined by kernel.ld.</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// 各个CPU的空闲页列表以及保护锁</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem[NCPU];<br><br><span class="hljs-comment">// 获取当前CPU id</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_cpuid</span><span class="hljs-params">()</span> &#123;<br>  push_off();<br>  <span class="hljs-type">int</span> id = cpuid();<br>  pop_off();<br>  <span class="hljs-keyword">return</span> id;<br>&#125;<br><br><span class="hljs-comment">// 从其他cpu获取一些空闲页，并返回一个空闲页</span><br><span class="hljs-comment">// （追加）实际上不返回一个空闲页比较好，可以让这个函数功能更加单一</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">steal_free_page</span><span class="hljs-params">(<span class="hljs-type">int</span> cur_id)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">old_head</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">new_head</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>; id &lt; NCPU; id++) &#123;<br>    <span class="hljs-keyword">if</span> (id == cur_id) <span class="hljs-keyword">continue</span>;<br>    acquire(&amp;kmem[id].lock);<br>    <span class="hljs-keyword">if</span> (kmem[id].freelist != <span class="hljs-number">0</span>) &#123;<br>      old_head = new_head = kmem[id].freelist;<br>      <span class="hljs-comment">// 最多获取STEAL_NUMBER页</span><br>      <span class="hljs-keyword">while</span> (new_head != <span class="hljs-number">0</span> &amp;&amp; cnt &lt; STEAL_NUMBER) &#123;<br>        new_head = new_head-&gt;next;<br>        cnt++;<br>      &#125;<br>      <span class="hljs-comment">// 更新受害者空闲页列表</span><br>      <span class="hljs-keyword">if</span> (new_head) &#123;<br>        kmem[id].freelist = new_head-&gt;next;<br>        new_head-&gt;next = <span class="hljs-number">0</span>;  <span class="hljs-comment">// （追加）取名有点问题，实际上此时new_head是截取链表的尾部，next置为0是将两链表断开连接</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        kmem[id].freelist = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>    release(&amp;kmem[id].lock);<br>    <span class="hljs-comment">// 获取到一些页，将第一页返回，其余页挂载在请求CPU的空闲页列表上</span><br>    <span class="hljs-keyword">if</span> (old_head != <span class="hljs-number">0</span>) &#123;<br>      acquire(&amp;kmem[cur_id].lock);<br>      <span class="hljs-comment">// （追加）存在竞态，有可能freelist不为0（kree），会导致遗失页，可以重构代码      </span><br>      <span class="hljs-comment">// 不使用new_head而使用steal_list_tail指向截取链表的尾部（不为0）,这样就可以将steal_list_tail-&gt;next置为freelist</span><br>      kmem[cur_id].freelist = old_head-&gt;next;  <br><br>      release(&amp;kmem[cur_id].lock);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> old_head;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">kinit</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++) &#123;<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;kmem-%d&quot;</span>, i);<br>    initlock(&amp;kmem[i].lock, buf);<br>    kmem[i].freelist = <span class="hljs-number">0</span>;<br>  &#125;<br>  freerange(end, (<span class="hljs-type">void</span> *)PHYSTOP);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span> &#123;<br>  uint64 page_start = PGROUNDUP((uint64)pa_start);<br>  uint64 page_end = PGROUNDDOWN((uint64)pa_end);<br>  uint64 cpu_size = PGROUNDDOWN((page_end - page_start) / NCPU);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;all page:%d  cpu page:%d\n&quot;</span>, (page_end - page_start) / PGSIZE, cpu_size / PGSIZE);<br>  <span class="hljs-comment">// 将物理页平均分配给各个CPU</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++) &#123;<br>    <span class="hljs-keyword">for</span> (uint64 pa = page_start + i * cpu_size; pa &lt; page_start + (i + <span class="hljs-number">1</span>) * cpu_size; pa += PGSIZE) &#123;<br>      <span class="hljs-keyword">if</span> ((pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br>      <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)pa, <span class="hljs-number">1</span>, PGSIZE);<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span> =</span> (<span class="hljs-keyword">struct</span> run *)pa;<br>      r-&gt;next = kmem[i].freelist;<br>      kmem[i].freelist = r;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将剩余页加入cpu0的空闲页列表</span><br>  <span class="hljs-keyword">for</span> (uint64 pa = page_start + NCPU * cpu_size; pa &lt; page_end; pa += PGSIZE) &#123;<br>    <span class="hljs-keyword">if</span> ((pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)pa, <span class="hljs-number">1</span>, PGSIZE);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span> =</span> (<span class="hljs-keyword">struct</span> run *)pa;<br>    r-&gt;next = kmem[<span class="hljs-number">0</span>].freelist;<br>    kmem[<span class="hljs-number">0</span>].freelist = r;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Free the page of physical memory pointed at by v,</span><br><span class="hljs-comment">// which normally should have been returned by a</span><br><span class="hljs-comment">// call to kalloc().  (The exception is when</span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run *)pa;<br>  <span class="hljs-comment">// 将页放回当前CPU所属空闲页列表</span><br>  <span class="hljs-type">int</span> id = get_cpuid();<br>  acquire(&amp;kmem[id].lock);<br>  r-&gt;next = kmem[id].freelist;<br>  kmem[id].freelist = r;<br>  release(&amp;kmem[id].lock);<br>&#125;<br><br><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  <span class="hljs-comment">// 尝试从当前CPU对应空闲页列表分配内存</span><br>  <span class="hljs-type">int</span> id = get_cpuid();<br>  acquire(&amp;kmem[id].lock);<br>  r = kmem[id].freelist;<br>  <span class="hljs-keyword">if</span> (r) kmem[id].freelist = r-&gt;next;<br>  release(&amp;kmem[id].lock);<br>  <span class="hljs-comment">// 若所属空闲页列表，从其他CPU空闲页列表获取一些页</span><br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) r = steal_free_page(id);<br><br>  <span class="hljs-keyword">if</span> (r) <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span> *)r, <span class="hljs-number">5</span>, PGSIZE);  <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)r;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><blockquote><p>Modify the block cache so that the number of acquire loop iterations for all locks in the bcache is close to zero when running bcachetest. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it’s OK if the sum is less than 500. Modify bget and brelse so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks (e.g., don’t all have to wait for bcache.lock). You must maintain the invariant that at most one copy of each block is cached. When you are done, your output should be similar to that shown below (though not identical). Make sure usertests still passes. make grade should pass all tests when you are done.</p></blockquote><p>这个实验还是比较难的，大致的思路是：<br>1：通过计算块号的哈希值（取余）将不同块请求分散至不同bucket<br>2：为每一个bucket配备一个锁，减少锁争用<br>3：记录最近访问时间，而不将节点移至链表首部<br>4：bucket可能会向其他bucket请求buffer，这可能造成死锁：a-&gt;b b-&gt;a。故借助一个大锁c，避免这种死锁情况：c-&gt;a-&gt;b c-&gt;b-&gt;a。<br>big lock-&gt; bucket a -&gt; bucket b<br>big lock-&gt; bucket b -&gt; bucket a<br>5: 为避免为同一个块分配多个buffer，分配前再次检查是否存在对应块<br>6：对属于本bucket的块与其他bucket的块进行分类处理</p><p>我当时一直没想到如何在各个bucket互相访问的情况下避免死锁，还是看了别人的实现才明白这一点。这篇博客写的挺不错的<a target="_blank" rel="noopener" href="https://juejin.cn/post/7021218568226209828">[mit6.s081] 笔记 Lab8: Locks | 锁优化</a></p><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> &#123;<br>  <span class="hljs-type">int</span> valid;  <span class="hljs-comment">// has data been read from disk?</span><br>  <span class="hljs-type">int</span> disk;   <span class="hljs-comment">// does disk &quot;own&quot; buf?</span><br>  uint dev;<br>  uint blockno;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sleeplock</span> lock;<br>  uint refcnt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *prev;  <span class="hljs-comment">// LRU cache list</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *next;<br>  uchar data[BSIZE];<br><br>  uint access_time;  <span class="hljs-comment">// 最近访问时间</span><br>  <span class="hljs-type">int</span> owner;         <span class="hljs-comment">// 所属的bucket</span><br>&#125;;<br><br><span class="hljs-comment">// Buffer cache.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The buffer cache is a linked list of buf structures holding</span><br><span class="hljs-comment">// cached copies of disk block contents.  Caching disk blocks</span><br><span class="hljs-comment">// in memory reduces the number of disk reads and also provides</span><br><span class="hljs-comment">// a synchronization point for disk blocks used by multiple processes.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Interface:</span><br><span class="hljs-comment">// * To get a buffer for a particular disk block, call bread.</span><br><span class="hljs-comment">// * After changing buffer data, call bwrite to write it to disk.</span><br><span class="hljs-comment">// * When done with the buffer, call brelse.</span><br><span class="hljs-comment">// * Do not use the buffer after calling brelse.</span><br><span class="hljs-comment">// * Only one process at a time can use a buffer,</span><br><span class="hljs-comment">//     so do not keep them longer than necessary.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sleeplock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;buf.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUCKET 13</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NONE -1</span><br><span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">spinlock</span> biglock;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> buf[NBUF];<br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-comment">// 不同桶对应的链表头节点与保护锁</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">spinlock</span> bucket_lock[BUCKET];<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> head[BUCKET];<br>&#125; bcache;<br><br><span class="hljs-comment">// 块号-&gt;桶号</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_bucket_index</span><span class="hljs-params">(uint blockno)</span> </span>&#123; <span class="hljs-keyword">return</span> blockno % BUCKET; &#125;<br><br><span class="hljs-comment">// 从双向链表中删除该节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delete_entry</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *p)</span> </span>&#123;<br>  p-&gt;next-&gt;prev = p-&gt;prev;<br>  p-&gt;prev-&gt;next = p-&gt;next;<br>&#125;<br><br><span class="hljs-comment">// 在双向链表中插入该节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_entry</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *head, <span class="hljs-keyword">struct</span> buf *b)</span> </span>&#123;<br>  b-&gt;prev = head;<br>  b-&gt;next = head-&gt;next;<br>  head-&gt;next-&gt;prev = b;<br>  head-&gt;next = b;<br>&#125;<br><br><span class="hljs-comment">// 选择最久未使用的buffer</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *<span class="hljs-built_in">least_recent_used_bufffer</span>() &#123;<br>  <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br>  uint min_tick = <span class="hljs-number">0xffffffff</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUF; i++) &#123;<br>    <span class="hljs-comment">// 该buffer未被使用</span><br>    <span class="hljs-keyword">if</span> (bcache.buf[i].owner == NONE) &#123;<br>      <span class="hljs-keyword">return</span> &amp;bcache.buf[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 选择引用计数为0且访问时间最小的buffer</span><br>    <span class="hljs-keyword">if</span> (bcache.buf[i].refcnt == <span class="hljs-number">0</span> &amp;&amp; bcache.buf[i].access_time &lt; min_tick) &#123;<br>      index = i;<br>      min_tick = bcache.buf[i].access_time;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &amp;bcache.buf[index];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">binit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *b;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>];<br>  <span class="hljs-built_in">initlock</span>(&amp;bcache.biglock, <span class="hljs-string">&quot;bcache-bigblock&quot;</span>);<br>  <span class="hljs-comment">// 初始化各桶的链表头部与保护锁</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BUCKET; i++) &#123;<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;bcache-%d&quot;</span>, i);<br>    <span class="hljs-built_in">initlock</span>(&amp;bcache.bucket_lock[i], buf);<br>    bcache.head[i].prev = &amp;bcache.head[i];<br>    bcache.head[i].next = &amp;bcache.head[i];<br>  &#125;<br>  <span class="hljs-comment">// 初始化各个buffer的拥有者与保护锁</span><br>  <span class="hljs-keyword">for</span> (b = bcache.buf; b &lt; bcache.buf + NBUF; b++) &#123;<br>    <span class="hljs-built_in">initsleeplock</span>(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>    b-&gt;owner = NONE;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// If not found, allocate a buffer.</span><br><span class="hljs-comment">// In either case, return locked buffer.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *<span class="hljs-built_in">bget</span>(uint dev, uint blockno) &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *b;<br>  <span class="hljs-type">int</span> index = <span class="hljs-built_in">get_bucket_index</span>(blockno);<br>  <span class="hljs-built_in">acquire</span>(&amp;bcache.bucket_lock[index]);<br>  <span class="hljs-comment">// 遍历该桶链表，查询是否缓存该块</span><br>  <span class="hljs-keyword">for</span> (b = bcache.head[index].next; b != &amp;bcache.head[index]; b = b-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;<br>      b-&gt;refcnt++;<br><br>      <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>      <span class="hljs-built_in">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>  <span class="hljs-comment">// 未缓存该块，分配新块存放对应数据</span><br>  <span class="hljs-comment">// 先获取大锁，再获取bucket锁，避免死锁发生</span><br>  <span class="hljs-built_in">acquire</span>(&amp;bcache.biglock);<br>  <span class="hljs-built_in">acquire</span>(&amp;bcache.bucket_lock[index]);<br>  <span class="hljs-comment">// 再次检查是否存在对应buffer，避免为同一个块分配两个buffer</span><br>  <span class="hljs-keyword">for</span> (b = bcache.head[index].next; b != &amp;bcache.head[index]; b = b-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;<br>      b-&gt;refcnt++;<br>      <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>      <span class="hljs-built_in">release</span>(&amp;bcache.biglock);<br>      <span class="hljs-built_in">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 分配一个buffer存放相应数据</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    b = <span class="hljs-built_in">least_recent_used_bufffer</span>();<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no buffer\n&quot;</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> old_owner = b-&gt;owner;<br>    <span class="hljs-comment">// 若拥有者就是本身或未使用则不需要加其他锁</span><br>    <span class="hljs-keyword">if</span> (old_owner == NONE || old_owner == index) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      b-&gt;owner = index;<br><br>      <span class="hljs-comment">// 之前未使用，需加入到对应链表</span><br>      <span class="hljs-keyword">if</span> (old_owner == NONE) <span class="hljs-built_in">add_entry</span>(&amp;bcache.head[index], b);<br><br>      <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>      <span class="hljs-built_in">release</span>(&amp;bcache.biglock);<br>      <span class="hljs-built_in">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 拥有者为其他bucket，需要加锁</span><br>      <span class="hljs-built_in">acquire</span>(&amp;bcache.bucket_lock[old_owner]);<br>      <span class="hljs-keyword">if</span> (b-&gt;refcnt != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 引用计数不为0，中途被改变，重新执行分配过程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;reference count change. b-&gt;refcnt:%d\n&quot;</span>, b-&gt;refcnt);<br>        <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[old_owner]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      b-&gt;owner = index;<br><br>      <span class="hljs-built_in">delete_entry</span>(b);                    <span class="hljs-comment">// 从原有链表中删除该节点</span><br>      <span class="hljs-built_in">add_entry</span>(&amp;bcache.head[index], b);  <span class="hljs-comment">// 在本桶链表中加入该节点</span><br><br>      <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[old_owner]);<br>      <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>      <span class="hljs-built_in">release</span>(&amp;bcache.biglock);<br>      <span class="hljs-built_in">acquiresleep</span>(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>  <span class="hljs-built_in">release</span>(&amp;bcache.biglock);<br>  <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *<span class="hljs-built_in">bread</span>(uint dev, uint blockno) &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">buf</span> *b;<br><br>  b = <span class="hljs-built_in">bget</span>(dev, blockno);<br>  <span class="hljs-keyword">if</span> (!b-&gt;valid) &#123;<br>    <span class="hljs-built_in">virtio_disk_rw</span>(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-comment">// Write b&#x27;s contents to disk.  Must be locked.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">holdingsleep</span>(&amp;b-&gt;lock)) <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>  <span class="hljs-built_in">virtio_disk_rw</span>(b, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// Release a locked buffer.</span><br><span class="hljs-comment">// Move to the head of the most-recently-used list.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">holdingsleep</span>(&amp;b-&gt;lock)) <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;brelse&quot;</span>);<br>  <span class="hljs-built_in">releasesleep</span>(&amp;b-&gt;lock);<br>  <span class="hljs-type">int</span> index = <span class="hljs-built_in">get_bucket_index</span>(b-&gt;blockno);<br>  <span class="hljs-built_in">acquire</span>(&amp;bcache.bucket_lock[index]);<br>  b-&gt;refcnt--;<br>  <span class="hljs-comment">// 引用计数为0时记录访问时间</span><br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    b-&gt;access_time = ticks;<br>  &#125;<br>  <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> </span>&#123;<br>  <span class="hljs-type">int</span> index = <span class="hljs-built_in">get_bucket_index</span>(b-&gt;blockno);<br>  <span class="hljs-built_in">acquire</span>(&amp;bcache.bucket_lock[index]);<br>  b-&gt;refcnt++;<br>  <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bunpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> </span>&#123;<br>  <span class="hljs-type">int</span> index = <span class="hljs-built_in">get_bucket_index</span>(b-&gt;blockno);<br>  <span class="hljs-built_in">acquire</span>(&amp;bcache.bucket_lock[index]);<br>  b-&gt;refcnt--;<br>  <span class="hljs-built_in">release</span>(&amp;bcache.bucket_lock[index]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过截图</strong><br><img src="https://img-blog.csdnimg.cn/86abbcad3a9e4e5fa02182f53ef29947.png" srcset="/img/loading.gif" lazyload></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%9B%BD%E5%A4%96%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/" class="category-chain-item">国外课程实验</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/6-081-locks/" class="print-no-link">#6.081 locks</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/blog/CMU15445%202020%20B+TREE%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95.html" title="CMU15445 2020 B+TREE简单记录"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">CMU15445 2020 B+TREE简单记录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/MIT6.S081%20Multithreading.html" title="MIT6.S081 Multithreading"><span class="hidden-mobile">MIT6.S081 Multithreading</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var e=Object.assign({appId:"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz",appKey:"0e2MMh7ddBCGGytOe9UEy5NP",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://uu0wegco.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>