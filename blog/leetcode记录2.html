<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/nano-1.jpg"><link rel="icon" href="/img/nano-1.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="推荐博客五大常用算法：分治、动态规划、贪心、回溯和分支界定刷题时注意边界条件&#x2F;特殊条件的处理leetcode记录1 树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 思路： 由于是树相关的题目，故大致思路就是使用递归解决，也意识到需要借助辅助函数实现，但一直无法确定辅助函数的写法与用"><meta property="og:type" content="article"><meta property="og:title" content="leetcode记录2"><meta property="og:url" content="https://www.jiasun.top/blog/leetcode%E8%AE%B0%E5%BD%952.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="推荐博客五大常用算法：分治、动态规划、贪心、回溯和分支界定刷题时注意边界条件&#x2F;特殊条件的处理leetcode记录1 树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 思路： 由于是树相关的题目，故大致思路就是使用递归解决，也意识到需要借助辅助函数实现，但一直无法确定辅助函数的写法与用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/71cbdd64cde7434897541ef3098eed59.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/c83e3a018bea4130a64693b514c37cf3.png"><meta property="article:published_time" content="2023-03-02T15:29:44.000Z"><meta property="article:modified_time" content="2023-10-31T14:45:59.172Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="leetcode 算法 数据结构"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/71cbdd64cde7434897541ef3098eed59.png"><title>leetcode记录2 - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="leetcode记录2"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-03-02 23:29" pubdate>2023年3月2日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 48k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 403 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">leetcode记录2</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><p>推荐博客<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yake827/article/details/52119469">五大常用算法：分治、动态规划、贪心、回溯和分支界定</a><br><mark>刷题时注意边界条件&#x2F;特殊条件的处理</mark><br><a href="https://www.jiasun.top/blog/leetcode%E8%AE%B0%E5%BD%95.html">leetcode记录1</a></p><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p><strong>思路：</strong> 由于是树相关的题目，故大致思路就是使用递归解决，也意识到需要借助辅助函数实现，但一直无法确定辅助函数的写法与用法。后面看到题解才知道咋写，记录在此。</p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solutions/791039/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">一篇文章带你吃透对称性递归(思路分析+解题模板+案例解读)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasSubStructure</span><span class="hljs-params">(TreeNode *A, TreeNode *B)</span> </span>&#123;  <span class="hljs-comment">// 从A根节点开始比对树结构</span><br>    <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">nullptr</span>) &#123;                             <span class="hljs-comment">// 空值默认匹配</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">nullptr</span> || A-&gt;val != B-&gt;val) &#123;  <span class="hljs-comment">// 值不匹配，判断失败</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasSubStructure</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">hasSubStructure</span>(A-&gt;right, B-&gt;right);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode *A, TreeNode *B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">nullptr</span> || B == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 如果A或B为空树，则判断失败</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasSubStructure</span>(A, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);  <span class="hljs-comment">// 判断当前根节点是否符合条件，而后判断子节点是否符合条件</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h2><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p><strong>思路：</strong> 使用哈希表统计出现次数，使用快排划分的方式找到出现频率最高的前k个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = arr[end].second;<br>    <span class="hljs-type">int</span> slow = start - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = start; fast &lt; end; fast++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[fast].second &gt;= p) &#123;  <span class="hljs-comment">// 逆序排布</span><br>        slow++;<br>        <span class="hljs-built_in">swap</span>(arr[slow], arr[fast]);<br>      &#125;<br>    &#125;<br>    slow++;<br>    <span class="hljs-built_in">swap</span>(arr[slow], arr[end]);<br>    <span class="hljs-keyword">return</span> slow;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getTopK</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">partition</span>(arr, start, end);<br>    <span class="hljs-keyword">if</span> (index &gt; k - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">getTopK</span>(arr, start, index - <span class="hljs-number">1</span>, k);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index &lt; k - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">getTopK</span>(arr, index + <span class="hljs-number">1</span>, end, k);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;  <span class="hljs-comment">// 记录各元素出现次数</span><br>      cnt[num]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">items</span>(cnt.<span class="hljs-built_in">begin</span>(), cnt.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 填入vector中</span><br>    <span class="hljs-built_in">getTopK</span>(items, <span class="hljs-number">0</span>, items.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>      ans.<span class="hljs-built_in">emplace_back</span>(items[i].first);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看了看题解，可以使用小顶堆（优先队列）的方式维持前k大的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m.second &gt; n.second;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; occurrences;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v : nums) &#123;<br>            occurrences[v]++;<br>        &#125;<br><br>        <span class="hljs-comment">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(&amp;cmp)&gt; <span class="hljs-built_in">q</span>(cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [num, count] : occurrences) &#123;<br>            <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() == k) &#123;<br>                <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">top</span>().second &lt; count) &#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">emplace</span>(num, count);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                q.<span class="hljs-built_in">emplace</span>(num, count);<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ret.<span class="hljs-built_in">emplace_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>思路：<br>我的思路是计算根节点到两节点的路径，然后取其公共的部分，由根节点执行公共路径，得到最近公共祖先</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNode</span><span class="hljs-params">(TreeNode* node, TreeNode* target, string&amp; path)</span> </span>&#123;  <span class="hljs-comment">// path:由根节点到达目标节点的路径，逆序</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node == target) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">findNode</span>(node-&gt;left, target, path)) &#123;<br>      path.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;l&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">findNode</span>(node-&gt;right, target, path)) &#123;<br>      path.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;r&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    string path1 = <span class="hljs-string">&quot;&quot;</span>;<br>    string path2 = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">findNode</span>(root, p, path1);<br>    <span class="hljs-built_in">findNode</span>(root, q, path2);<br>    <span class="hljs-type">int</span> min_len = <span class="hljs-built_in">min</span>(path1.<span class="hljs-built_in">length</span>(), path2.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">// 反转路径</span><br>    <span class="hljs-built_in">reverse</span>(path1.<span class="hljs-built_in">begin</span>(), path1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">reverse</span>(path2.<span class="hljs-built_in">begin</span>(), path2.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 找到第一个方向不同的位置</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; min_len; i++) &#123;<br>      <span class="hljs-keyword">if</span> (path1[i] != path2[i]) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 根据路径找到相应节点</span><br>    TreeNode* res = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>      <span class="hljs-keyword">if</span> (path1[j] == <span class="hljs-string">&#x27;l&#x27;</span>) &#123;<br>        res = res-&gt;left;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res = res-&gt;right;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>官方题解的方法比较巧妙，但不怎么容易想到<br><img src="https://img-blog.csdnimg.cn/71cbdd64cde7434897541ef3098eed59.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">existTargetNode</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (find_ancestor) &#123;  <span class="hljs-comment">// 已找到最近公共祖先，提前结束</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> lres = <span class="hljs-built_in">existTargetNode</span>(root-&gt;left, p, q);                       <span class="hljs-comment">// 左子树是否存在p或q</span><br>    <span class="hljs-type">bool</span> rres = <span class="hljs-built_in">existTargetNode</span>(root-&gt;right, p, q);                      <span class="hljs-comment">// 右子树是否存在p或q</span><br>    <span class="hljs-keyword">if</span> ((lres &amp;&amp; rres) || (root == p || root == q) &amp;&amp; (lres || rres)) &#123;  <span class="hljs-comment">// 两子树分别有p和q或当前节点即为p,q，子树存在另一个</span><br>      find_ancestor = <span class="hljs-literal">true</span>;<br>      ans = root;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root == p || root == q || lres || rres;  <span class="hljs-comment">// 当前节点或子树存在p或q</span><br>  &#125;<br><br>  <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    ans = <span class="hljs-literal">nullptr</span>;<br>    find_ancestor = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">existTargetNode</span>(root, p, q);<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  TreeNode* ans;<br>  <span class="hljs-type">bool</span> find_ancestor;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>思路：</strong><br>刚开始我的思路就是使用dfs计算连通分量，但当时我只访问两个方向，因为我觉得这样可以省去一些遍历，但忘了这个就是通过计算dfs的调用次数来得到连通分量的<br>错误方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1 1 1</span><br><span class="hljs-comment">0 1 0</span><br><span class="hljs-comment">1 1 1</span><br><span class="hljs-comment">连通分量为1，但结果为2，错误</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    visited[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 只遍历两个方向</span><br>    <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; grid[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; visited[x + <span class="hljs-number">1</span>][y] == <span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-built_in">dfs</span>(grid, visited, x + <span class="hljs-number">1</span>, y);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; visited[x][y + <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-built_in">dfs</span>(grid, visited, x, y + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; visited[i][j] == <span class="hljs-literal">false</span>) &#123;<br>          <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>          ans++;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    visited[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>      <span class="hljs-type">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];<br>      <span class="hljs-type">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[nx][ny] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; visited[nx][ny] == <span class="hljs-literal">false</span>) &#123;  <span class="hljs-comment">// 坐标合法，陆地，未被访问过</span><br>        <span class="hljs-built_in">dfs</span>(grid, visited, nx, ny);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));  <span class="hljs-comment">// 是否访问过</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;                                              <span class="hljs-comment">// 连通分量个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; visited[i][j] == <span class="hljs-literal">false</span>) &#123;<br>          <span class="hljs-built_in">dfs</span>(grid, visited, i, j);<br>          ans++;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>思路</strong><br>我的思路就是动态规划，两层遍历一遍即可<br>$P(i,j) &#x3D; P(i+1,j−1) ∧ (Si​&#x3D;&#x3D;Sj)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(len, <span class="hljs-literal">true</span>));<br>    <span class="hljs-type">int</span> string_len = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> string_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sub_len = <span class="hljs-number">2</span>; sub_len &lt;= len; sub_len++) &#123;                                           <span class="hljs-comment">// 以长度为外层循环</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt;= len - sub_len; start++) &#123;                                     <span class="hljs-comment">// 以起始位置为内层循环</span><br>        <span class="hljs-keyword">if</span> (s[start] == s[start + sub_len - <span class="hljs-number">1</span>] &amp;&amp; dp[start + <span class="hljs-number">1</span>][start + sub_len - <span class="hljs-number">2</span>] == <span class="hljs-literal">true</span>) &#123;  <span class="hljs-comment">// 两侧字符相等且内侧字符串为回文字符串</span><br>          dp[start][start + sub_len - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>          string_len = sub_len;<br>          string_start = start;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">/// 不为回文字符串</span><br>          dp[start][start + sub_len - <span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(string_start, string_len);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>官方题解采用的是中心扩散的方式，由一个字符或两个字符向两边扩散</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">expandBound</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;  <span class="hljs-comment">// 返回字符串开始位置与长度</span><br>    <span class="hljs-keyword">while</span> (s[start] == s[end]) &#123;                                     <span class="hljs-comment">// 字符相等，持续向两边扩散</span><br>      start--;<br>      end++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;start + <span class="hljs-number">1</span>, end - start - <span class="hljs-number">1</span>&#125;;<br>  &#125;<br>  <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    s = <span class="hljs-string">&quot;+&quot;</span> + s + <span class="hljs-string">&quot;-&quot;</span>;  <span class="hljs-comment">// 添加范围之外的字符，省去边界检查</span><br>    <span class="hljs-type">int</span> string_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> string_len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>      <span class="hljs-keyword">auto</span> [start1, len1] = <span class="hljs-built_in">expandBound</span>(s, i, i);<br>      <span class="hljs-keyword">auto</span> [start2, len2] = <span class="hljs-built_in">expandBound</span>(s, i, i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (len1 &gt; string_len) &#123;<br>        string_start = start1;<br>        string_len = len1;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (len2 &gt; string_len) &#123;<br>        string_start = start2;<br>        string_len = len2;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(string_start, string_len);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>思路</strong><br>使用队列实现层序遍历，我的实现是为节点添加层级信息，用于区分各层节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Node = pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt;;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    queue&lt;Node&gt; qu;<br>    <span class="hljs-type">int</span> curr_level = <span class="hljs-number">-1</span>;<br>    qu.<span class="hljs-built_in">emplace</span>(root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [node, level] = qu.<span class="hljs-built_in">front</span>();<br>      qu.<span class="hljs-built_in">pop</span>();<br><br>      <span class="hljs-keyword">if</span> (curr_level != level) &#123;  <span class="hljs-comment">// 当前层的第一个节点，创建一个新vector</span><br>        ans.<span class="hljs-built_in">emplace_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;node-&gt;val&#125;);<br>        curr_level = level;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans[level].<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>      &#125;<br><br>      <span class="hljs-comment">// 添加左子节点与右子节点</span><br>      <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>        qu.<span class="hljs-built_in">emplace</span>(node-&gt;left, level + <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>        qu.<span class="hljs-built_in">emplace</span>(node-&gt;right, level + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>官方题解直接按层级对节点进行操作，更加简洁一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode *root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    queue&lt;TreeNode *&gt; qu;<br>    <span class="hljs-type">int</span> curr_level = <span class="hljs-number">-1</span>;<br>    qu.<span class="hljs-built_in">emplace</span>(root);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>      ans.<span class="hljs-built_in">emplace_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;);<br>      <span class="hljs-type">int</span> level_size = qu.<span class="hljs-built_in">size</span>();  <span class="hljs-comment">// 当前层的节点数</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level_size; i++) &#123;<br>        TreeNode *node = qu.<span class="hljs-built_in">front</span>();<br>        qu.<span class="hljs-built_in">pop</span>();<br>        ans.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>        <span class="hljs-comment">// 加入子节点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>          qu.<span class="hljs-built_in">emplace</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>          qu.<span class="hljs-built_in">emplace</span>(node-&gt;right);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p><strong>思路</strong><br>经典的动态规划问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> len2 = text2.<span class="hljs-built_in">length</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>        <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// s1=s2，多一种状态转移可能</span><br>          max_len = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        dp[i][j] = <span class="hljs-built_in">max</span>(&#123;max_len, dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]&#125;);  <span class="hljs-comment">// 可由dp[i-1][j]  dp[i][j-1]得来</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>思路</strong><br>虽然指针操作有点复杂，但对着样例调整指针操作也不是很难，使用虚拟头节点避免对头部节点的特殊处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>  <span class="hljs-type">int</span> val;<br>  ListNode* next;<br>  <span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>  <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>  <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x, ListNode* next) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// k=1不用翻转</span><br>      <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function">ListNode <span class="hljs-title">virt_head</span><span class="hljs-params">(<span class="hljs-number">-1</span>, head)</span></span>;<br>    ListNode* prev_node = &amp;virt_head;  <span class="hljs-comment">// 指向各组前一个节点</span><br>    ListNode* next_node = head;        <span class="hljs-comment">// 指向各组后一个节点</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;  <span class="hljs-comment">// 找到下一个组的后一个节点</span><br>        <span class="hljs-keyword">if</span> (next_node == <span class="hljs-literal">nullptr</span>) &#123;<br>          <span class="hljs-keyword">return</span> virt_head.next;<br>        &#125;<br>        next_node = next_node-&gt;next;<br>      &#125;<br><br>      ListNode* prev = prev_node-&gt;next;        <span class="hljs-comment">// 该组第一个节点</span><br>      ListNode* curr = prev_node-&gt;next-&gt;next;  <span class="hljs-comment">// 该组第二个节点</span><br>      ListNode* next;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;<br>        next = curr-&gt;next;<br>        curr-&gt;next = prev;<br>        prev = curr;<br>        curr = next;<br>      &#125;<br>      <span class="hljs-comment">// prev为该组最后一个节点 curr next为下一组的第一个节点</span><br>      prev_node-&gt;next-&gt;next = next;  <span class="hljs-comment">// 第一个节点的next指向下一组的第一个节点</span><br>      ListNode* tmp = prev_node-&gt;next;<br>      prev_node-&gt;next = prev;  <span class="hljs-comment">// 上一组的最后一个节点指向该组最后一个节点</span><br>      prev_node = tmp;         <span class="hljs-comment">// 更新组前一个节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> virt_head.next;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p><strong>思路</strong><br>以0-2^n^-1的数字表示各个元素选择情况，n为数组长度，数字对应位为1则选择该位置元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; length; i++) &#123; <br>      vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>        <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 数字相应位为1则选取对应位置数字</span><br>          tmp.<span class="hljs-built_in">emplace_back</span>(nums[j]);<br>        &#125;<br>      &#125;<br>      ans.<span class="hljs-built_in">emplace_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h2><p>给定一个正整数 n ，输出外观数列的第 n 项。<br>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p><strong>思路</strong><br>比较简单，依次遍历模拟即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">string <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    string ans = <span class="hljs-string">&quot;1&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>      string tmp;<br>      ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;\0&#x27;</span>);<br>      <span class="hljs-type">char</span> last_char = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>      <span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : ans) &#123;<br>        <span class="hljs-keyword">if</span> (last_char == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;  <span class="hljs-comment">// 第一个字符</span><br>          last_char = c;<br>          times = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == last_char) &#123;  <span class="hljs-comment">// 字符相等，次数加一</span><br>          times++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 不同的字符，编码至结果</span><br>          tmp.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">to_string</span>(times));<br>          tmp.<span class="hljs-built_in">push_back</span>(last_char);<br>          last_char = c;<br>          times = <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>      ans = <span class="hljs-built_in">move</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p><strong>思路</strong><br>我的思路是将起点终点都放到数组中进行比较，记录当前经过的起点与终点数，若相等则将区间起点与终点加入结果集合，实现上起点附加值设为-1，终点附加值设为1，保证附加值为0时起点数与终点数相等，且起点与终点值相同时，起点在终点前面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Node = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>    vector&lt;Node&gt; numbers;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; vec : intervals) &#123;<br>      numbers.<span class="hljs-built_in">emplace_back</span>(vec[<span class="hljs-number">0</span>], <span class="hljs-number">-1</span>);  <span class="hljs-comment">// 起点-1小于终点1，使用pair默认比较函数，使得相同值的起点在终点前</span><br>      numbers.<span class="hljs-built_in">emplace_back</span>(vec[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; node : numbers) &#123;<br>      <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 记录区间起点</span><br>        start = node.first;<br>      &#125;<br>      cnt += node.second;<br>      <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 区间起点终点成对出现，记录区间起始</span><br>        ans.<span class="hljs-built_in">emplace_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;start, node.first&#125;);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>官方题解的思路更容易理解一点，按起点排序，持续扩大终点边界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v1, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v2) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> v1[<span class="hljs-number">0</span>] &lt; v2[<span class="hljs-number">0</span>]; &#125;;  <span class="hljs-comment">// 自定义比较函数</span><br>    <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>    ans.<span class="hljs-built_in">emplace_back</span>(intervals[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">auto</span>&amp; last = ans.<span class="hljs-built_in">back</span>();<br>      <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt; last[<span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 起点大于区间终点，加入区间</span><br>        ans.<span class="hljs-built_in">emplace_back</span>(intervals[i]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 更新区间终点</span><br>        last[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(last[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p><strong>思路</strong><br>刚开始我的思路是计算出n-1的所有括号对数，然后在前后各加一次括号，在两边加一次括号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">f1: ()<br>f2: f1 + ()  () + f1  ( + f1 + )<br></code></pre></td></tr></table></figure><p>但发现n&#x3D;4的时候结果就出错了，比对一下发现(())(())没有在结果集合中，f4不能全部由f3推导而来，也可以从f2+f2推导而来。<br>故换一种思路，枚举fi+fn-i，最后加上( + fn-1 + )</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">ans</span>(n + <span class="hljs-number">1</span>);<br>    ans[<span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;()&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>      unordered_set&lt;string&gt; tmp;        <span class="hljs-comment">// 使用set去重</span><br>      <span class="hljs-keyword">for</span> (string&amp; str : ans[i - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">// 可能情况1：两边加括号</span><br>        tmp.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">&quot;(&quot;</span> + str + <span class="hljs-string">&quot;)&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;  <span class="hljs-comment">// 可能情况2： 由不同个数的有效括号组合而来</span><br>        <span class="hljs-keyword">for</span> (string&amp; str1 : ans[j]) &#123;<br>          <span class="hljs-keyword">for</span> (string&amp; str2 : ans[i - j]) &#123;<br>            tmp.<span class="hljs-built_in">emplace</span>(str1 + str2);<br>          &#125;<br>        &#125;<br>      &#125;<br>      ans[i] = <span class="hljs-built_in">vector</span>&lt;string&gt;(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans[n];<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 错误思路：反例：f4并非全部由f3得来  忽略了2+2 (())(())</span><br><span class="hljs-comment">class Solution &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="hljs-comment">        vector&lt;vector&lt;string&gt;&gt; ans(n);</span><br><span class="hljs-comment">        ans[0].emplace_back(&quot;()&quot;);</span><br><span class="hljs-comment">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="hljs-comment">            for(string&amp; str:ans[i-1])&#123;</span><br><span class="hljs-comment">                ans[i].emplace_back(str+&quot;()&quot;);</span><br><span class="hljs-comment">                ans[i].emplace_back(&quot;()&quot;+str);</span><br><span class="hljs-comment">                ans[i].emplace_back(&quot;(&quot;+str+&quot;)&quot;);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        unordered_set&lt;string&gt; se(ans[n-1].begin(),ans[n-1].end());</span><br><span class="hljs-comment">        return vector&lt;string&gt;(se.begin(),se.end());</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>思路</strong><br>链表中非常常见的两个思路：<strong>虚拟头节点与双指针</strong><br>虚拟头节点一般用来避免对头节点的特殊处理，双指针利用指针的行进速度，位置关系巧妙地解决问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">ListNode <span class="hljs-title">virt_head</span><span class="hljs-params">(<span class="hljs-number">-1</span>, head)</span></span>;<br>    ListNode* slow = &amp;virt_head;<br>    ListNode* fast = &amp;virt_head;<br>    <span class="hljs-comment">// 相当于访问倒数n+1个节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;  <span class="hljs-comment">// fast比slow快n+1步</span><br>      fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>      slow = slow-&gt;next;<br>      fast = fast-&gt;next;<br>    &#125;<br>    slow-&gt;next = slow-&gt;next-&gt;next;  <span class="hljs-comment">// 删除倒数第n个节点</span><br>    <span class="hljs-keyword">return</span> virt_head.next;          <span class="hljs-comment">// 返回头节点</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/article/0akb5U/">十大排序算法(背诵版+动图)</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/96c0717e2ed849219748796956291a22">排序（基数排序 牛客网提交地址）</a><br><img src="https://img-blog.csdnimg.cn/c83e3a018bea4130a64693b514c37cf3.png" srcset="/img/loading.gif" lazyload><br>笔试选择题中天天考基数排序，就简单实现一下加深一下印象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max_num = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 得到最大数字</span><br>    <span class="hljs-type">int</span> bits = <span class="hljs-number">0</span>;                                          <span class="hljs-comment">// 最大数字位数</span><br>    <span class="hljs-keyword">while</span> (max_num != <span class="hljs-number">0</span>) &#123;<br>      max_num /= <span class="hljs-number">10</span>;<br>      bits++;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">bucket</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bits; i++) &#123;  <span class="hljs-comment">// 进行bits次放入放出操作</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-type">int</span> index = num / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, i)) % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 计算相应位置的数字</span><br>        bucket[index].<span class="hljs-built_in">emplace_back</span>(num);                      <span class="hljs-comment">// 压入桶中</span><br>      &#125;<br>      <span class="hljs-comment">// 放回数组中</span><br>      <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; items : bucket) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : items) &#123;<br>          nums[k++] = num;<br>        &#125;<br>        items.<span class="hljs-built_in">clear</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      cin &gt;&gt; data[i];<br>    &#125;<br>    Solution solution;<br>    <span class="hljs-keyword">auto</span> res = solution.<span class="hljs-built_in">sortArray</span>(data);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : res) &#123;<br>      cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="正经解法"><a href="#正经解法" class="headerlink" title="正经解法"></a>正经解法</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">写对二分查找不是套模板并往里面填空，需要仔细分析题意</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 等于</span><br>  <span class="hljs-comment">// 结果可能出现在[0,n-1]区间，不存在时返回-1</span><br>  <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> high = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>    <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 靠近low high都可以</span><br>    <span class="hljs-keyword">if</span> (data[mid] == target) &#123;<br>      <span class="hljs-keyword">return</span> mid;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[mid] &gt; target) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 压缩区间至[low,high], low==high</span><br>  <span class="hljs-keyword">if</span> (data[low] == target) &#123;<br>    <span class="hljs-keyword">return</span> low;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindFirstGreaterEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 第一次大于等于</span><br>  <span class="hljs-comment">// 结果可能落在[0,n]</span><br>  <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> high = data.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>    <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 靠近low</span><br>    <span class="hljs-keyword">if</span> (data[mid] &gt;= target) &#123;<br>      high = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 压缩区间至[low,high], low==high</span><br>  <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindFirstGreater</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 第一次大于</span><br>  <span class="hljs-comment">// 结果可能落在[0,n]</span><br>  <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> high = data.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>    <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 靠近low</span><br>    <span class="hljs-keyword">if</span> (data[mid] &gt; target) &#123;<br>      high = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 压缩区间至[low,high], low==high</span><br>  <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindLastLesserEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 最后一次小于等于</span><br>  <span class="hljs-comment">// 结果可能落在[-1,n-1]</span><br>  <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] &gt; target) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> high = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>    <span class="hljs-type">int</span> mid = (low + high + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 靠近high</span><br>    <span class="hljs-keyword">if</span> (data[mid] &gt; target) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 压缩区间至[low,high], low==high</span><br>  <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindLastLesser</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 最后一次小于</span><br>  <span class="hljs-comment">// 结果可能落在[-1,n-1]</span><br>  <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] &gt;= target) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> high = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>    <span class="hljs-type">int</span> mid = (low + high + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 靠近high</span><br>    <span class="hljs-keyword">if</span> (data[mid] &gt;= target) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 压缩区间至[low,high], low==high</span><br>  <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindFirstEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 第一次等于</span><br>  <span class="hljs-comment">// 结果可能落在[0,n-1]，不存在时返回-1</span><br>  <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> high = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>    <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 靠近low</span><br>    <span class="hljs-keyword">if</span> (data[mid] &gt; target) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[mid] &lt; target) &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      high = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 压缩区间至[low,high], low==high</span><br>  <span class="hljs-keyword">if</span> (data[low] == target) &#123;<br>    <span class="hljs-keyword">return</span> low;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindLastEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 最后一次等于</span><br>  <span class="hljs-comment">// 结果可能落在[0,n-1]，不存在时返回-1</span><br>  <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> high = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>    <span class="hljs-type">int</span> mid = (low + high + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// 靠近high</span><br>    <span class="hljs-keyword">if</span> (data[mid] &gt; target) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[mid] &lt; target) &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 压缩区间至[low,high], low==high</span><br>  <span class="hljs-keyword">if</span> (data[low] == target) &#123;<br>    <span class="hljs-keyword">return</span> low;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindEqualCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 返回第一次相等的下标</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (data[i] == target) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindFirstGreaterEqualCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (data[i] &gt;= target) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindFirstGreaterCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (data[i] &gt; target) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindLastLesserEqualCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span> (data[i] &lt;= target) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindLastLesserCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span> (data[i] &lt; target) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindFirstEqualCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (data[i] == target) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinaryFindLastEqualCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">if</span> (data[i] == target) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-keyword">using</span> FindFunc = function&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;, <span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestBinaryFind</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; targets, FindFunc test_fn, FindFunc right_fn, string testname)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> target : targets) &#123;<br>    <span class="hljs-type">int</span> res1 = <span class="hljs-built_in">test_fn</span>(data, target);<br>    <span class="hljs-type">int</span> res2 = <span class="hljs-built_in">right_fn</span>(data, target);<br>    <span class="hljs-keyword">if</span> (res1 != res2) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;wrong anwer.&quot;</span> &lt;&lt; endl;<br>      cout &lt;&lt; <span class="hljs-string">&quot;res1: &quot;</span> &lt;&lt; res1 &lt;&lt; <span class="hljs-string">&quot;  res2: &quot;</span> &lt;&lt; res2 &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; testname &lt;&lt; <span class="hljs-string">&quot; complete.&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; unique_data;<br>  default_random_engine e;<br>  <span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)</span></span>;<br>  e.<span class="hljs-built_in">seed</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; <span class="hljs-number">95</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">u</span>(e) &gt; <span class="hljs-number">50</span>) &#123;<br>      unique_data.<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125;<br>  &#125;<br>  vector&lt;<span class="hljs-type">int</span>&gt; targets;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    targets.<span class="hljs-built_in">emplace_back</span>(i);<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;unique data test:&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">TestBinaryFind</span>(unique_data, targets, BinaryFindEqual, BinaryFindEqualCompare, <span class="hljs-string">&quot;BinaryFindEqual&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(unique_data, targets, BinaryFindFirstGreaterEqual, BinaryFindFirstGreaterEqualCompare, <span class="hljs-string">&quot;BinaryFindFirstGreaterEqual&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(unique_data, targets, BinaryFindFirstGreater, BinaryFindFirstGreaterCompare, <span class="hljs-string">&quot;BinaryFindFirstGreater&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(unique_data, targets, BinaryFindLastLesserEqual, BinaryFindLastLesserEqualCompare, <span class="hljs-string">&quot;BinaryFindLastLesserEqual&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(unique_data, targets, BinaryFindLastLesser, BinaryFindLastLesserCompare, <span class="hljs-string">&quot;BinaryFindLastLesser&quot;</span>);<br><br>  vector&lt;<span class="hljs-type">int</span>&gt; repeat_data;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; <span class="hljs-number">95</span>; i++) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">u</span>(e) &gt; <span class="hljs-number">30</span>) &#123;<br>      repeat_data.<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;repeat data test:&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-built_in">TestBinaryFind</span>(repeat_data, targets, BinaryFindFirstGreaterEqual, BinaryFindFirstGreaterEqualCompare, <span class="hljs-string">&quot;BinaryFindFirstGreaterEqual&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(repeat_data, targets, BinaryFindFirstGreater, BinaryFindFirstGreaterCompare, <span class="hljs-string">&quot;BinaryFindFirstGreater&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(repeat_data, targets, BinaryFindLastLesserEqual, BinaryFindLastLesserEqualCompare, <span class="hljs-string">&quot;BinaryFindLastLesserEqual&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(repeat_data, targets, BinaryFindLastLesser, BinaryFindLastLesserCompare, <span class="hljs-string">&quot;BinaryFindLastLesser&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(repeat_data, targets, BinaryFindFirstEqual, BinaryFindFirstEqualCompare, <span class="hljs-string">&quot;BinaryFindFirstEqual&quot;</span>);<br>  <span class="hljs-built_in">TestBinaryFind</span>(repeat_data, targets, BinaryFindLastEqual, BinaryFindLastEqualCompare, <span class="hljs-string">&quot;BinaryFindLastEqual&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="取巧解法"><a href="#取巧解法" class="headerlink" title="取巧解法"></a>取巧解法</h3><p>相关leetcode题目<br>34. 在排序数组中查找元素的第一个和最后一个位置<br>35. 搜索插入位置<br>704. 二分查找</p><p>本来是比较基础的题目，面试时问到卡壳了，故在此记录一下二分查找变形的简单解法</p><p><strong>在排序数组中查找元素的第一个和最后一个位置</strong><br>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p><strong>思路</strong><br>显然解题并不需要实现两个函数，只需要找到任意一个等于然后向两边扩散即可，但我为了熟悉二分查找的变形，实现了两个函数，分别用来求第一个等于和最后一个等于。这其中就使用了一个技巧，<strong>对前一个或后一个值进行额外判断，这样就能将范围查找规约成单个满足条件的值的查找</strong>，这样就能避免一系列的死循环和边界条件了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_first_equal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 第一个等于的位置</span><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] != target) &#123;  <span class="hljs-comment">// 当前位置即为第一个等于</span><br>          <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 不存在等于target的位置</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_last_equal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 最后一个等于的位置</span><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mid == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] != target) &#123;  <span class="hljs-comment">// 当前位置即为最后一个等于的位置</span><br>          <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 不存在等于target的位置</span><br>  &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> first = <span class="hljs-built_in">find_first_equal</span>(nums, target);<br>    <span class="hljs-type">int</span> second = <span class="hljs-built_in">find_last_equal</span>(nums, target);<br>    <span class="hljs-keyword">return</span> &#123;first, second&#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>搜索插入位置</strong><br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p><p><strong>思路</strong><br>使用上述技巧即可，判断前一个值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;  <span class="hljs-comment">// 搜索第一个大于等于target的位置</span><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] &lt; target) &#123;  <span class="hljs-comment">// 当前位置即为第一个大于等于target的位置</span><br>          <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>(); <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>二分查找</strong><br>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="完成所有任务的最少时间"><a href="#完成所有任务的最少时间" class="headerlink" title="完成所有任务的最少时间"></a>完成所有任务的最少时间</h2><p>你有一台电脑，它可以 同时 运行无数个任务。给你一个二维整数数组 tasks ，其中 tasks[i] &#x3D; [starti, endi, durationi] 表示第 i 个任务需要在 闭区间 时间段 [starti, endi] 内运行 durationi 个整数时间点（但不需要连续）。<br>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。<br>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p><p><strong>思路：</strong><br>周赛的第四题，没思路，动态规划写多了，想不到贪心，而且这个非常像差分数组，但实际又不能用，就放弃了<br>参考别人的题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/solution/tan-xin-pythonjavacgo-by-endlesscheng-w3k3/">两种方法：暴力&#x2F;线段树（Python&#x2F;Java&#x2F;C++&#x2F;Go）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinimumTime</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; task1, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; task2) &#123; <span class="hljs-keyword">return</span> task1[<span class="hljs-number">1</span>] &lt; task2[<span class="hljs-number">1</span>]; &#125;;<br>    <span class="hljs-built_in">sort</span>(tasks.<span class="hljs-built_in">begin</span>(), tasks.<span class="hljs-built_in">end</span>(), cmp);  <span class="hljs-comment">// 按右端点排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-number">2001</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; task : tasks) &#123;<br>      <span class="hljs-type">int</span> start = task[<span class="hljs-number">0</span>];<br>      <span class="hljs-type">int</span> end = task[<span class="hljs-number">1</span>];<br>      <span class="hljs-type">int</span> duration = task[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;  <span class="hljs-comment">// 减去已运行的任务数</span><br>        duration -= run[i];<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = end; duration &gt; <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 尽可能安排在区间后缀</span><br>        <span class="hljs-keyword">if</span> (run[i] == <span class="hljs-number">0</span>) &#123;<br>          run[i] = <span class="hljs-number">1</span>;<br>          duration--;<br>          ans++;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="统计美丽子数组数目"><a href="#统计美丽子数组数目" class="headerlink" title="统计美丽子数组数目"></a>统计美丽子数组数目</h2><p>给你一个下标从 0 开始的整数数组nums 。每次操作中，你可以：</p><p>选择两个满足 0 &lt;&#x3D; i, j &lt; nums.length 的不同下标 i 和 j 。<br>选择一个非负整数 k ，满足 nums[i] 和 nums[j] 在二进制下的第 k 位（下标编号从 0 开始）是 1 。<br>将 nums[i] 和 nums[j] 都减去 2k 。<br>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 0 的数组，那么我们称它是一个 美丽 的子数组。</p><p>请你返回数组 nums 中 美丽子数组 的数目。<br>子数组是一个数组中一段连续 非空 的元素序列。</p><p><strong>思路：</strong><br>周赛的第三题，使用两层循环枚举超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">beautifulSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dp = nums;  <span class="hljs-comment">// dp[i][j]表示长度为i，末尾为j的序列的异或和，由于dp[i][j]只和dp[i-1][j]有关，省略i</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;  <span class="hljs-comment">// 计算dp[1][j]为0的个数</span><br>      <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>        ans++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= nums.<span class="hljs-built_in">size</span>(); len++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; end &gt;= len - <span class="hljs-number">1</span>; end--) &#123;  <span class="hljs-comment">// 逆序更新，保证为上一次的结果</span><br>        dp[end] = dp[end - <span class="hljs-number">1</span>] ^ nums[end];<br>        <span class="hljs-keyword">if</span> (dp[end] == <span class="hljs-number">0</span>) &#123;<br>          ans++;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>而题解使用了前缀和与异或的性质<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/solution/tao-lu-qian-zhui-he-ha-xi-biao-pythonjav-3fna/">【套路】前缀和+哈希表（Python&#x2F;Java&#x2F;C++&#x2F;Go）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">异或</span><br><span class="hljs-comment">归零律：a ^ a = 0</span><br><span class="hljs-comment">恒等律：a ^ 0 = a</span><br><span class="hljs-comment">a  b  a ^ b</span><br><span class="hljs-comment">0  0  0</span><br><span class="hljs-comment">0  1  1</span><br><span class="hljs-comment">1  0  1</span><br><span class="hljs-comment">1  1  0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">beautifulSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// prefix[0] = 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 异或前缀和</span><br>      prefix[i + <span class="hljs-number">1</span>] = prefix[i] ^ nums[i];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 注意为long long</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s : prefix) &#123;<br>      <span class="hljs-comment">// 若此时cnt[s]!=0，设当前位置为j，存在cnt[s]个位置的前缀为s，其位置设为i，[i...j]的区间异或和为0</span><br>      <span class="hljs-comment">// 额外加入prefix[0] = 0，便于计算nums[i]==0的情况</span><br>      ans += cnt[s];<br>      cnt[s]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="航班预订统计"><a href="#航班预订统计" class="headerlink" title="航班预订统计"></a>航班预订统计</h2><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。<br>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] &#x3D; [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。<br>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p><strong>思路：</strong><br>差分数组模板题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">corpFlightBookings</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bookings, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; booking : bookings) &#123;<br>      ans[booking[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>] += booking[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">if</span> (booking[<span class="hljs-number">1</span>] &lt; n) &#123;<br>        ans[booking[<span class="hljs-number">1</span>]] -= booking[<span class="hljs-number">2</span>];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 对差分数组求前缀和即为原数组</span><br>      ans[i] += ans[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><p>硬套双指针做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">index</span>(nums.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 数值+索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      index[i] = &#123;nums[i], i&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(index.<span class="hljs-built_in">begin</span>(), index.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 排序</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;  <span class="hljs-comment">// 使用双指针解决两数之和</span><br>      <span class="hljs-keyword">if</span> (index[i].first + index[j].first == target) &#123;<br>        <span class="hljs-keyword">return</span> &#123;index[i].second, index[j].second&#125;;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index[i].first + index[j].first &gt; target) &#123;<br>        j--;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        i++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用map加速查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">auto</span> iter = hash_map.<span class="hljs-built_in">find</span>(target - nums[i]);  <span class="hljs-comment">// 查找之前元素</span><br>      <span class="hljs-keyword">if</span> (iter != hash_map.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>      &#125;<br>      hash_map[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请<br>你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p><p>直接使用set去重，使用最简单的两数之和方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; se;  <span class="hljs-comment">// 直接用set去重</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>      <span class="hljs-type">int</span> target = -nums[i];<br>      <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] + nums[k] == target) &#123;<br>          se.<span class="hljs-built_in">emplace</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[j], nums[k]&#125;);<br>          j++;<br>          k--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;<br>          k--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          j++;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(se.<span class="hljs-built_in">begin</span>(), se.<span class="hljs-built_in">end</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>逻辑去重，跳过相同字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-type">int</span> target = -nums[i];<br>      <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] + nums[k] == target) &#123;<br>          ans.<span class="hljs-built_in">emplace_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[j], nums[k]&#125;);<br>          <span class="hljs-type">int</span> value_j = nums[j];<br>          <span class="hljs-type">int</span> vlaue_k = nums[k];<br>          <span class="hljs-comment">// 跳过相同字符</span><br>          <span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[j] == value_j) &#123;<br>            j++;<br>          &#125;<br>          <span class="hljs-keyword">while</span> (k &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[k] == vlaue_k) &#123;<br>            k--;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] + nums[k] &gt; target) &#123;<br>          k--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          j++;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 跳过相同字符</span><br>      <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] == -target) &#123;<br>        i++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="连接所有点的最小费用"><a href="#连接所有点的最小费用" class="headerlink" title="连接所有点的最小费用"></a>连接所有点的最小费用</h2><p>给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] &#x3D; [xi, yi] 。<br>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。<br>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><p>最小生成树模板题</p><p>还是用visit数组标记是否已加入集合比较好，注意优先队列自定义比较函数的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kInf = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, kInf)</span></span>;<br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p1, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p2) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> p1.second &gt; p2.second; &#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">qu</span>(cmp);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>    qu.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [node, node_dist] = qu.<span class="hljs-built_in">top</span>();<br>      qu.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">if</span> (visit[node]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      visit[node] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-type">int</span> x1 = points[node][<span class="hljs-number">0</span>];<br>      <span class="hljs-type">int</span> y1 = points[node][<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i != node &amp;&amp; !visit[i]) &#123;<br>          <span class="hljs-type">int</span> x2 = points[i][<span class="hljs-number">0</span>];<br>          <span class="hljs-type">int</span> y2 = points[i][<span class="hljs-number">1</span>];<br>          <span class="hljs-type">int</span> manhan_dist = <span class="hljs-built_in">abs</span>(x1 - x2) + <span class="hljs-built_in">abs</span>(y1 - y2);<br>          <span class="hljs-keyword">if</span> (dist[i] &gt; manhan_dist) &#123;  <span class="hljs-comment">// 松弛操作与Dijkstra算法不同</span><br>            dist[i] = manhan_dist;<br>            qu.<span class="hljs-built_in">emplace</span>(i, manhan_dist);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dist.<span class="hljs-built_in">begin</span>(), dist.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 计算距离总和</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。<br>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。<br>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。<br>返回矩阵中 省份 的数量。<br><strong>思路：</strong><br>union-find模题，单纯用来熟悉union-find算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (vec_[k] == k) &#123;<br>      <span class="hljs-keyword">return</span> k;<br>    &#125;<br>    vec_[k] = <span class="hljs-built_in">findOperation</span>(vec_[k]);  <span class="hljs-comment">// 压缩树结构</span><br>    <span class="hljs-keyword">return</span> vec_[k];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>    <span class="hljs-type">int</span> proot = <span class="hljs-built_in">findOperation</span>(p);<br>    <span class="hljs-type">int</span> qroot = <span class="hljs-built_in">findOperation</span>(q);<br>    vec_[proot] = qroot;  <span class="hljs-comment">// 合并连通分量</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = isConnected.<span class="hljs-built_in">size</span>();<br>    vec_ = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 初始化连通分量数组</span><br>      vec_[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (isConnected[i][j] == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 将两城市相连</span><br>          <span class="hljs-built_in">unionOperation</span>(i, j);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">// 计算连通分量数目</span><br>      <span class="hljs-keyword">if</span> (vec_[i] == i) &#123;<br>        cnt++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-type">int</span>&gt; vec_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="概率最大的路径"><a href="#概率最大的路径" class="headerlink" title="概率最大的路径"></a>概率最大的路径</h2><p>给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] &#x3D; [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。<br>指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。<br>如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。<br><strong>思路：</strong><br>Dijkstra算法变种大多采用不同的松弛操作，若需要优化算法性能，可使用优先队列<br>第一个版本：不使用优先队列，超时，中间一个bug是max_dist使用了int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> to;<br>  <span class="hljs-type">double</span> prob;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="hljs-type">double</span>&gt;&amp; succProb, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    vector&lt;vector&lt;Edge&gt;&gt; <span class="hljs-built_in">mat</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>(); i++) &#123;  <span class="hljs-comment">// 构建邻接矩阵</span><br>      mat[edges[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(Edge&#123;edges[i][<span class="hljs-number">1</span>], succProb[i]&#125;);<br>      mat[edges[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(Edge&#123;edges[i][<span class="hljs-number">0</span>], succProb[i]&#125;);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 标记数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 与起点距离</span><br>    dist[start] = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 起点值为1</span><br>    <span class="hljs-type">int</span> node = start;<br>    visit[node] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> times = <span class="hljs-number">0</span>; times &lt; n; times++) &#123;<br>      <span class="hljs-keyword">for</span> (Edge e : mat[node]) &#123;<br>        <span class="hljs-keyword">if</span> (dist[e.to] &lt; dist[node] * e.prob) &#123;  <span class="hljs-comment">// 松弛操作，乘法</span><br>          dist[e.to] = dist[node] * e.prob;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 找到最大的边</span><br>      <span class="hljs-type">double</span> max_dist = <span class="hljs-number">0</span>;  <span class="hljs-comment">// double类型</span><br>      <span class="hljs-type">int</span> max_index = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visit[i] &amp;&amp; dist[i] &gt; max_dist) &#123;<br>          max_dist = dist[i];<br>          max_index = i;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (max_index == end) &#123;<br>        <span class="hljs-keyword">return</span> dist[end];<br>      &#125;<br>      <span class="hljs-keyword">if</span> (max_index == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>      visit[max_index] = <span class="hljs-literal">true</span>;<br>      node = max_index;<br>    &#125;<br>    <span class="hljs-keyword">return</span> visit[end];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第二个版本：借助优先队列，但仍然使用了标记数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> to;<br>  <span class="hljs-type">double</span> prob;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge&amp; e) &#123; <span class="hljs-keyword">return</span> prob &lt; e.prob; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="hljs-type">double</span>&gt;&amp; succProb, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    vector&lt;vector&lt;Edge&gt;&gt; <span class="hljs-built_in">mat</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>(); i++) &#123;  <span class="hljs-comment">// 构建邻接矩阵</span><br>      mat[edges[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(Edge&#123;edges[i][<span class="hljs-number">1</span>], succProb[i]&#125;);<br>      mat[edges[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(Edge&#123;edges[i][<span class="hljs-number">0</span>], succProb[i]&#125;);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// 标记数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;     <span class="hljs-comment">// 与起点距离</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; qu;<br>    dist[start] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点值为1</span><br>    qu.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1.0</span>, start);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [prob, node] = qu.<span class="hljs-built_in">top</span>();<br>      qu.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">if</span> (node == end) &#123;<br>        <span class="hljs-keyword">return</span> dist[end];<br>      &#125;<br>      <span class="hljs-keyword">if</span> (visit[node]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      visit[node] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">for</span> (Edge e : mat[node]) &#123;<br>        <span class="hljs-keyword">if</span> (dist[e.to] &lt; dist[node] * e.prob) &#123;  <span class="hljs-comment">// 松弛操作，乘法</span><br>          dist[e.to] = dist[node] * e.prob;<br>          qu.<span class="hljs-built_in">emplace</span>(dist[e.to], e.to);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> visit[end];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第三个版本：借助优先队列，但不需要标记数组，可以多看几遍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="hljs-type">double</span>&gt;&amp; succProb, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;&gt;&gt; <span class="hljs-built_in">mat</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>(); i++) &#123;  <span class="hljs-comment">// 构建邻接矩阵</span><br>      mat[edges[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(edges[i][<span class="hljs-number">1</span>], succProb[i]);<br>      mat[edges[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace_back</span>(edges[i][<span class="hljs-number">0</span>], succProb[i]);<br>    &#125;<br><br>    priority_queue&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; qu;  <span class="hljs-comment">// 借助优先队列找到最大概率路径</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    dist[start] = <span class="hljs-number">1</span>;<br>    qu.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1</span>, start);<br>    <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [prob, node] = qu.<span class="hljs-built_in">top</span>();<br>      qu.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">if</span> (prob &lt; dist[node]) &#123;  <span class="hljs-comment">// 无用信息，node已被更新过</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (node == end) &#123;  <span class="hljs-comment">// 提前返回结果</span><br>        <span class="hljs-keyword">return</span> dist[end];<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [next_node, edge_prob] : mat[node]) &#123;  <span class="hljs-comment">// 松弛操作</span><br>        <span class="hljs-keyword">if</span> (dist[next_node] &lt; dist[node] * edge_prob) &#123;<br>          dist[next_node] = dist[node] * edge_prob;<br>          qu.<span class="hljs-built_in">emplace</span>(dist[next_node], next_node);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[end];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现-Trie-前缀树"><a href="#实现-Trie-前缀树" class="headerlink" title="实现 Trie (前缀树)"></a>实现 Trie (前缀树)</h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><p><strong>思路：</strong><br>了解了节点组成之后还是挺简单的，<strong>子节点指针数组与结束标志</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Trie</span>() &#123;<br>    <span class="hljs-built_in">memset</span>(children_, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(children_));  <span class="hljs-comment">// 将子节点指针置为空</span><br>    is_end_ = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>    Trie* node = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;<br>      <span class="hljs-keyword">if</span> (node-&gt;children_[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 若子节点不存在则创建</span><br>        node-&gt;children_[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>      &#125;<br>      node = node-&gt;children_[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    node-&gt;is_end_ = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 字符串结束位置</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>    Trie* node = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;<br>      <span class="hljs-keyword">if</span> (node-&gt;children_[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 子节点为空，搜索失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      node = node-&gt;children_[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> node-&gt;is_end_;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>    Trie* node = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : prefix) &#123;<br>      <span class="hljs-keyword">if</span> (node-&gt;children_[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// 子节点为空，搜索失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      node = node-&gt;children_[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  Trie* children_[<span class="hljs-number">26</span>];  <span class="hljs-comment">// 字节点指针</span><br>  <span class="hljs-type">bool</span> is_end_;         <span class="hljs-comment">// 是否为字符串结尾</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h2><p>请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p><strong>思路：</strong><br>与15445的LRU类似，注意size的更新与淘汰操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">capacity_</span>(capacity), <span class="hljs-built_in">size_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> map_iter = speed_map_.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (map_iter == speed_map_.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// key不存在</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> list_iter = map_iter-&gt;second;<br>    <span class="hljs-type">int</span> value = list_iter-&gt;second;<br><br>    <span class="hljs-keyword">if</span> (list_iter != data_.<span class="hljs-built_in">begin</span>()) &#123;  <span class="hljs-comment">// 移至队首</span><br>      data_.<span class="hljs-built_in">erase</span>(list_iter);<br>      data_.<span class="hljs-built_in">emplace_front</span>(key, value);<br>      speed_map_[key] = data_.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> map_iter = speed_map_.<span class="hljs-built_in">find</span>(key);<br>    <span class="hljs-keyword">if</span> (map_iter == speed_map_.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 插入key-value对</span><br>      <span class="hljs-keyword">if</span> (size_ == capacity_) &#123;          <span class="hljs-comment">// 淘汰队尾数据</span><br>        speed_map_.<span class="hljs-built_in">erase</span>(data_.<span class="hljs-built_in">back</span>().first);<br>        data_.<span class="hljs-built_in">pop_back</span>();<br>        size_--;  <span class="hljs-comment">// 当前大小减一</span><br>      &#125;<br>      <span class="hljs-comment">// 插入队首</span><br>      data_.<span class="hljs-built_in">emplace_front</span>(key, value);<br>      speed_map_.<span class="hljs-built_in">insert</span>(&#123;key, data_.<span class="hljs-built_in">begin</span>()&#125;);<br>      size_++;  <span class="hljs-comment">// 当前大小加一</span><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 更新key-value对</span><br>      <span class="hljs-keyword">auto</span> list_iter = map_iter-&gt;second;<br>      list_iter-&gt;second = value;<br><br>      <span class="hljs-keyword">if</span> (list_iter != data_.<span class="hljs-built_in">begin</span>()) &#123;  <span class="hljs-comment">// 移至队首</span><br>        data_.<span class="hljs-built_in">erase</span>(list_iter);<br>        data_.<span class="hljs-built_in">emplace_front</span>(key, value);<br>        speed_map_[key] = data_.<span class="hljs-built_in">begin</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> capacity_;                                                  <span class="hljs-comment">// 容量</span><br>  <span class="hljs-type">int</span> size_;                                                      <span class="hljs-comment">// 当前大小</span><br>  unordered_map&lt;<span class="hljs-type">int</span>, list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; speed_map_;  <span class="hljs-comment">// key与list迭代器</span><br>  list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; data_;                                     <span class="hljs-comment">// 存储key-value对</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>代码化简，while循环改成for循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>    <span class="hljs-function">ListNode <span class="hljs-title">virt_head</span><span class="hljs-params">(<span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>)</span></span>;<br>    <span class="hljs-comment">// ListNode* cur = &amp;virt_head;</span><br>    <span class="hljs-comment">// while (list1 != nullptr &amp;&amp; list2 != nullptr) &#123;</span><br>    <span class="hljs-comment">//   if (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br>    <span class="hljs-comment">//     cur-&gt;next = list1;</span><br>    <span class="hljs-comment">//     cur = cur-&gt;next;</span><br>    <span class="hljs-comment">//     list1 = list1-&gt;next;</span><br>    <span class="hljs-comment">//   &#125; else &#123;</span><br>    <span class="hljs-comment">//     cur-&gt;next = list2;</span><br>    <span class="hljs-comment">//     cur = cur-&gt;next;</span><br>    <span class="hljs-comment">//     list2 = list2-&gt;next;</span><br>    <span class="hljs-comment">//   &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    ListNode* cur;<br>    <span class="hljs-keyword">for</span> (cur = &amp;virt_head; list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>; cur = cur-&gt;next) &#123;<br>      <span class="hljs-keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;<br>        cur-&gt;next = list1;<br>        list1 = list1-&gt;next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        cur-&gt;next = list2;<br>        list2 = list2-&gt;next;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">nullptr</span>) &#123;<br>      cur-&gt;next = list1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list2 != <span class="hljs-literal">nullptr</span>) &#123;<br>      cur-&gt;next = list2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> virt_head.next;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数组中的第-k-大的数字"><a href="#数组中的第-k-大的数字" class="headerlink" title="数组中的第 k 大的数字"></a>数组中的第 k 大的数字</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br><strong>思路：</strong><br>利用快排的划分函数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = nums[end];<br>    <span class="hljs-type">int</span> slow = start - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = start; fast &lt; end; fast++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[fast] &lt; p) &#123;<br>        slow++;<br>        <span class="hljs-built_in">swap</span>(nums[slow], nums[fast]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums[slow + <span class="hljs-number">1</span>], nums[end]);<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= end) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partition</span>(nums, start, end);<br>    <span class="hljs-keyword">if</span> (mid &gt; target) &#123;<br>      <span class="hljs-built_in">sort</span>(nums, start, mid - <span class="hljs-number">1</span>, target);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid &lt; target) &#123;<br>      <span class="hljs-built_in">sort</span>(nums, mid + <span class="hljs-number">1</span>, end, target);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h2><p>快排：以前都只看过双指针格式的代码，看了看leetcode单指针的代码，比较易懂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 选择随机元素作为基准值</span><br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">rand</span>() % (end - start + <span class="hljs-number">1</span>) + start;<br>    <span class="hljs-built_in">swap</span>(nums[index], nums[end]);<br>    <span class="hljs-comment">// 单边循环，完成基准值排定</span><br>    <span class="hljs-type">int</span> p = nums[end];<br>    <span class="hljs-type">int</span> slow = start - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = start; fast &lt; end; fast++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[fast] &lt; p) &#123;  <span class="hljs-comment">// 保证左半边小于p，右半边大于等于</span><br>        slow++;<br>        <span class="hljs-built_in">swap</span>(nums[slow], nums[fast]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums[slow + <span class="hljs-number">1</span>], nums[end]);<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (end &gt; start) &#123;<br>      <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partition</span>(nums, start, end);<br>      <span class="hljs-built_in">quickSort</span>(nums, start, mid - <span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">quickSort</span>(nums, mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>归并：不怎么喜欢用夹带++i或i++的表达式，总觉得不好看，非递归的实现忘了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= end) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(nums, start, mid);<br>    <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-type">int</span> i = start;<br>    <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k = start;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>        tmp_vec_[k] = nums[i];<br>        i++;<br>        k++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        tmp_vec_[k] = nums[j];<br>        j++;<br>        k++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>      tmp_vec_[k] = nums[i];<br>      i++;<br>      k++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= end) &#123;<br>      tmp_vec_[k] = nums[j];<br>      j++;<br>      k++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;<br>      nums[i] = tmp_vec_[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    tmp_vec_.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-type">int</span>&gt; tmp_vec_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>堆排序，记住下沉操作即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> largest = i;<br>    <span class="hljs-comment">// 若子节点值大于父节点，找到较大者</span><br>    <span class="hljs-keyword">if</span> (left &lt;= len &amp;&amp; nums[left] &gt; nums[largest]) &#123;<br>      largest = left;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (right &lt;= len &amp;&amp; nums[right] &gt; nums[largest]) &#123;<br>      largest = right;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (largest != i) &#123;  <span class="hljs-comment">// 与较大者交换，继续下沉操作</span><br>      <span class="hljs-built_in">swap</span>(nums[i], nums[largest]);<br>      <span class="hljs-built_in">maxHeapify</span>(nums, largest, len);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <span class="hljs-comment">// 将父节点依次下沉</span><br>      <span class="hljs-built_in">maxHeapify</span>(nums, i, len);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    heap_size_ = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">buildMaxHeap</span>(nums, heap_size_);  <span class="hljs-comment">// 建立大顶堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-built_in">swap</span>(nums[i], nums[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 将最大值移至末尾</span><br>      heap_size_--;<br>      <span class="hljs-built_in">maxHeapify</span>(nums, <span class="hljs-number">0</span>, heap_size_);  <span class="hljs-comment">// 进行下沉操作，维持大顶堆性质</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">heapSort</span>(nums);<br>    <span class="hljs-keyword">return</span> nums;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> heap_size_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LABULADONG-动态规划专题"><a href="#LABULADONG-动态规划专题" class="headerlink" title="LABULADONG 动态规划专题"></a>LABULADONG 动态规划专题</h2><p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/">LABULADONG 的算法网站</a></p><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMax = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">28</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, kMax)</span></span>;  <span class="hljs-comment">// dp[i]表示凑成金额i的最少次数</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>        <span class="hljs-keyword">if</span> (i - coin &gt;= <span class="hljs-number">0</span>) &#123;<br>          dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] == kMax ? <span class="hljs-number">-1</span> : dp[amount];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>变换次序，去掉条件判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kMax = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">28</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, kMax)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=coin;i&lt;=amount;i++)&#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] == kMax ? <span class="hljs-number">-1</span> : dp[amount];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">总结一下如何找到动态规划的状态转移关系：</span><br><span class="hljs-comment">1、明确dp数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</span><br><span class="hljs-comment">2、根据dp数组的定义，运用数学归纳法的思想，假设dp[0...i-1]都已知，想办法求出dp[i]，一旦这一步完成，整个题目基本就解决了。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// dp[i]表示以nums[i]结尾的最长递增子序列的长度</span><br>    <span class="hljs-type">int</span> longest = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>          dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>      &#125;<br>      longest = <span class="hljs-built_in">max</span>(longest, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> longest;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>思路：</strong><br>0-1背包模板题，若压缩空间，则需要逆序更新保证为dp数组上一次更新的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 计算数组总和</span><br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span> || sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;             <span class="hljs-comment">// 只有一个数或总和为奇数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">// dp[i][j]表示前i个数是否能构成j，由于dp[i]只与dp[i-1]有关，状态压缩，仅仅保存dp[j]</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) &#123;  <span class="hljs-comment">// 逆序遍历，保证为i-1时的结果</span><br>        dp[j] = dp[j] | dp[j - nums[i]];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h3><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。<br>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。<br>假设每一种面额的硬币有无限个。<br>题目数据保证结果符合 32 位带符号整数。</p><p><strong>思路：</strong><br>代码很简单，但通过调换次序避免重复却很巧妙<br>通过将coin设为主序，确定了内层循环的末尾硬币一定为当前coin，且组合序列一定遵从coins数组排序，即coin为1 2 5，则序列一定为1 1 2 之类的序列，而不会出现2 1 1的序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// dp[i]表示构成i的组合次数</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = coin; i &lt;= amount; i++) &#123;<br>        dp[i] += dp[i - coin];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/leetcode-%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#leetcode 算法 数据结构</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/blog/NVMe%E9%A9%B1%E5%8A%A8%E6%B3%A8%E9%87%8A%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.html" title="NVMe驱动注释（持续更新）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">NVMe驱动注释（持续更新）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/leveldb%E7%AC%AC%E4%BA%8C%E5%B9%95%20%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html" title="leveldb第二幕 代码阅读笔记"><span class="hidden-mobile">leveldb第二幕 代码阅读笔记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var e=Object.assign({appId:"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz",appKey:"0e2MMh7ddBCGGytOe9UEy5NP",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://uu0wegco.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>