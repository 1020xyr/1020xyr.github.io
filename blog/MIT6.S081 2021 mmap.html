<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/main.jpg"><link rel="icon" href="/img/main.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="You should implement enough mmap and munmap functionality to make the mmaptest test program work. If mmaptest doesn’t use a mmap feature, you don’t need to implement that feature.  这个实验还是比较复杂的，用gd"><meta property="og:type" content="article"><meta property="og:title" content="MIT6.S081 2021 mmap"><meta property="og:url" content="https://www.jiasun.top/blog/MIT6.S081%202021%20mmap.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="You should implement enough mmap and munmap functionality to make the mmaptest test program work. If mmaptest doesn’t use a mmap feature, you don’t need to implement that feature.  这个实验还是比较复杂的，用gd"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/3947e7fde7ae400d89106ec81bc9ae6c.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/366e36b2dc4942b8ab3b940a5c6dc925.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/8b9db43881dc4eb682d729ea43bcbf3b.png"><meta property="article:published_time" content="2022-08-27T14:02:08.000Z"><meta property="article:modified_time" content="2023-10-31T14:45:58.933Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="6.081 mmap"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/3947e7fde7ae400d89106ec81bc9ae6c.png"><title>MIT6.S081 2021 mmap - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="MIT6.S081 2021 mmap"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-27 22:02" pubdate>2022年8月27日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 18k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 149 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">MIT6.S081 2021 mmap</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><blockquote><p>You should implement enough mmap and munmap functionality to make the mmaptest test program work. If mmaptest doesn’t use a mmap feature, you don’t need to implement that feature.</p></blockquote><p>这个实验还是比较复杂的，用gdb调了很多次才最终通过所有测试，当然通过测试不代表程序就是对的。</p><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><p>首先简要地翻译一下hints</p><blockquote><p>Start by adding _mmaptest to UPROGS, and mmap and munmap system calls, in order to get user&#x2F;mmaptest.c to compile. For now, just return errors from mmap and munmap. We defined PROT_READ etc for you in kernel&#x2F;fcntl.h. Run mmaptest, which will fail at the first mmap call.</p></blockquote><p>补全mmap和munmap两个系统调用路径，并将_mmaptest加入用户程序</p><blockquote><p>Fill in the page table lazily, in response to page faults. That is, mmap should not allocate physical memory or read the file. Instead, do that in page fault handling code in (or called by) usertrap, as in the lazy page allocation lab. The reason to be lazy is to ensure that mmap of a large file is fast, and that mmap of a file larger than physical memory is possible.</p></blockquote><p>在mmap中并不实际分配物理页，而是在页错误处理代码（usertrap）中进行处理，以便快速处理大文件的mmap调用</p><blockquote><p>Keep track of what mmap has mapped for each process. Define a structure corresponding to the VMA (virtual memory area) described in Lecture 15, recording the address, length, permissions, file, etc. for a virtual memory range created by mmap. Since the xv6 kernel doesn’t have a memory allocator in the kernel, it’s OK to declare a fixed-size array of VMAs and allocate from that array as needed. A size of 16 should be sufficient.</p></blockquote><p>创建一个结构体来描述mmap映射的内存区域，阅读《linux内核设计与实现》第15章进程地址空间，定义一个vm_area_struct类似的结构体，由于不能动态分配内存，故使用静态数组的方式来分配内存区域。</p><blockquote><p>Implement mmap: find an unused region in the process’s address space in which to map the file, and add a VMA to the process’s table of mapped regions. The VMA should contain a pointer to a struct file for the file being mapped; mmap should increase the file’s reference count so that the structure doesn’t disappear when the file is closed (hint: see filedup). Run mmaptest: the first mmap should succeed, but the first access to the mmap-ed memory will cause a page fault and kill mmaptest.</p></blockquote><p>在mmap的实现中分配一个vm_area结构体记录mmap信息，将文件映射到一个未使用的地址空间，并增加文件的引用次数</p><blockquote><p>Add code to cause a page-fault in a mmap-ed region to allocate a page of physical memory, read 4096 bytes of the relevant file into that page, and map it into the user address space. Read the file with readi, which takes an offset argument at which to read in the file (but you will have to lock&#x2F;unlock the inode passed to readi). Don’t forget to set the permissions correctly on the page. Run mmaptest; it should get to the first munmap.</p></blockquote><p>在usertrap函数中对映射区域发生的load&#x2F;store page fault进行处理，分配物理页并读入文件内容。注意读入文件内容需加inode锁并正确设置页权限。</p><blockquote><p>Implement munmap: find the VMA for the address range and unmap the specified pages (hint: use uvmunmap). If munmap removes all pages of a previous mmap, it should decrement the reference count of the corresponding struct file. If an unmapped page has been modified and the file is mapped MAP_SHARED, write the page back to the file. Look at filewrite for inspiration.</p></blockquote><p>找到unmap对应的区域并修改其地址范围，取消相应的映射。如果将mmap映射的区域全部移除则降低文件的引用计数并且将内容写入文件</p><blockquote><p>Ideally your implementation would only write back MAP_SHARED pages that the program actually modified. The dirty bit (D) in the RISC-V PTE indicates whether a page has been written. However, mmaptest does not check that non-dirty pages are not written back; thus you can get away with writing pages back without looking at D bits.</p></blockquote><p>页表项中记录了该物理页是否被修改，最好的解决方案应该只在该页被修改时才进行文件写入操作。</p><blockquote><p>Modify exit to unmap the process’s mapped regions as if munmap had been called. Run mmaptest; mmap_test should pass, but probably not fork_test.</p></blockquote><p>修改exit函数，在进程退出时unmap所有已经映射的内存区域</p><blockquote><p>Modify fork to ensure that the child has the same mapped regions as the parent. Don’t forget to increment the reference count for a VMA’s struct file. In the page fault handler of the child, it is OK to allocate a new physical page instead of sharing a page with the parent. The latter would be cooler, but it would require more implementation work. Run mmaptest; it should pass both mmap_test and fork_test.</p></blockquote><p>修改fork函数，使子进程拥有父进程拥有的内存区域，同时增加文件的引用计数，在页错误处理部分可以分配新的物理页</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><mark>以下代码仅做简单的参考，注意处理好头文件</mark><br>按照hints编写程序，第一步不思考如何实现mmap，而是读懂测试代码<br><strong>补全系统调用路径</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用户空间调用</span><br><span class="hljs-type">char</span> *p = mmap(<span class="hljs-number">0</span>, PGSIZE * <span class="hljs-number">2</span>, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (p == MAP_FAILED) err(<span class="hljs-string">&quot;mmap (1)&quot;</span>);<br>_v1(p);<br><span class="hljs-keyword">if</span> (munmap(p, PGSIZE * <span class="hljs-number">2</span>) == <span class="hljs-number">-1</span>) err(<span class="hljs-string">&quot;munmap (1)&quot;</span>);<br><span class="hljs-comment">// user.h中添加函数声明</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">int</span>)</span>;<br><span class="hljs-comment">// syscall.h中加入调用号</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_mmap 22</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_munmap 23</span><br><span class="hljs-comment">// usys.pl加入函数入口点</span><br>entry(<span class="hljs-string">&quot;mmap&quot;</span>);<br>entry(<span class="hljs-string">&quot;munmap&quot;</span>);<br>生成代码：<br>.global mmap<br>mmap:<br> li a7, SYS_mmap<br> ecall<br> ret<br>.global munmap<br>munmap:<br> li a7, SYS_munmap<br> ecall<br> ret<br><span class="hljs-comment">// syscall.c中加入系统调用函数项</span><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br>[SYS_mmap]    sys_mmap,<br>[SYS_munmap]  sys_munmap,<br>&#125;;<br><span class="hljs-comment">// 在sysfile.c中添加空函数</span><br>uint64 <span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>uint64 <span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">// 修改Makefile</span><br>UPROGS=\<br>	$U/_cat\<br>	$U/_echo\<br>	$U/_forktest\<br>	$U/_grep\<br>	$U/_init\<br>	$U/_kill\<br>	$U/_ln\<br>	$U/_ls\<br>	$U/_mkdir\<br>	$U/_rm\<br>	$U/_sh\<br>	$U/_stressfs\<br>	$U/_usertests\<br>	$U/_grind\<br>	$U/_wc\<br>	$U/_zombie\<br>	$U/_mmaptest\<br></code></pre></td></tr></table></figure><p>在本实验中我定义了两个结构体，struct shared_memory和struct vm_area，其中shared_memory为共享物理页，分配给MAP_SHARED模式的mmap系统调用，vm_area描述文件映射的区域信息。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_type.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> &#123;</span><br>  <span class="hljs-type">char</span> *page;         <span class="hljs-comment">// 物理页地址</span><br>  <span class="hljs-type">int</span> ref_cnt;        <span class="hljs-comment">// 物理页引用次数</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span>  <span class="hljs-comment">// 物理页对应的文件</span><br>  <span class="hljs-type">int</span> length;         <span class="hljs-comment">// 文件长度</span><br>  uint inum;          <span class="hljs-comment">// inode号与文件偏移，用来作为共享物理页的唯一标识</span><br>  <span class="hljs-type">int</span> offset;<br>  <span class="hljs-type">int</span> is_dirty;  <span class="hljs-comment">// 该物理页是否被修改过</span><br>  <span class="hljs-type">int</span> used;      <span class="hljs-comment">// 该共享页是否正在被使用</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> &#123;</span><br>  uint64 va_start;    <span class="hljs-comment">// 虚拟区域起始地址</span><br>  uint64 va_end;      <span class="hljs-comment">// 虚拟区域结束地址</span><br>  uint64 file_start;  <span class="hljs-comment">// 文件开始的虚拟地址</span><br>  <span class="hljs-type">int</span> prot;           <span class="hljs-comment">// 文件权限</span><br>  <span class="hljs-type">int</span> flags;          <span class="hljs-comment">// mmap模式</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span>  <span class="hljs-comment">// 映射的文件</span><br>  uint inum;          <span class="hljs-comment">// inode号</span><br>  <span class="hljs-type">int</span> size;           <span class="hljs-comment">// 文件大小</span><br>  <span class="hljs-type">int</span> used;           <span class="hljs-comment">// 是否正在被使用</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>先不看这些结构体的相关操作，着眼于sys_mmap sys_munmap fork exit函数的修改<br>在这里我是从MAXVA递减分配空闲地址的，每次分配完更新一下分配点，避免多个mmap映射到同一块区域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc.h </span><br><span class="hljs-comment">// 修改proc结构体，增加vm_area数组和内存分配点</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMAP_SIZE 16</span><br><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> <span class="hljs-title">mmap</span>[<span class="hljs-title">MMAP_SIZE</span>];</span>  <span class="hljs-comment">// 内存区域数组</span><br>  uint64 free_memory_start;        <span class="hljs-comment">// 空闲地址分配点</span><br>&#125;;<br><span class="hljs-comment">// proc.c</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc *<span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>found:<br>  <span class="hljs-comment">// 初始化内存区域数组以及空闲地址分配点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MMAP_SIZE; i++) &#123;<br>    p-&gt;mmap[i].used = <span class="hljs-number">0</span>;<br>  &#125;<br>  p-&gt;free_memory_start = MAXVA - <span class="hljs-number">2</span> * PGSIZE;		<span class="hljs-comment">// 除去TRAMPOLINE和TRAPFRAME</span><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">// 分配空闲地址</span><br>uint64 <span class="hljs-title function_">find_unused_region</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p, <span class="hljs-type">int</span> npages)</span> &#123;<br>  uint64 va;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> find_slot = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">pagetable_t</span> pagetable = p-&gt;pagetable;<br>  <span class="hljs-keyword">for</span> (va = p-&gt;free_memory_start - npages * PGSIZE; va &gt; <span class="hljs-number">0</span>; va -= PGSIZE) &#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<br>      <span class="hljs-keyword">if</span> (walkaddr(pagetable, va + i * PGSIZE) != <span class="hljs-number">0</span>) &#123;<br>        find_slot = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (find_slot == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;virtual address:%p \n&quot;</span>, va);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MAXVA distance:%dth page npages:%d\n&quot;</span>, (MAXVA - va) / PGSIZE, npages);<br>      p-&gt;free_memory_start = va;		<span class="hljs-comment">// 更新分配点</span><br>      <span class="hljs-keyword">return</span> va;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>uint64 <span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> length;<br>  <span class="hljs-type">int</span> prot;<br>  <span class="hljs-type">int</span> flags;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br><br>  <span class="hljs-comment">// 读取需要的参数</span><br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (argfd(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">// 检验参数</span><br>  <span class="hljs-keyword">if</span> (flags == MAP_SHARED) &#123;<br>    <span class="hljs-keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; (f-&gt;readable != <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> ((prot &amp; PROT_WRITE) &amp;&amp; (f-&gt;writable != <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 分配未使用的vm_area和内存地址</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-type">int</span> npages = (length - <span class="hljs-number">1</span>) / PGSIZE + <span class="hljs-number">1</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> *<span class="hljs-title">area</span> =</span> alloc_area(p);<br>  uint64 va = find_unused_region(p, npages);<br>  <span class="hljs-keyword">if</span> (area == <span class="hljs-number">0</span> || va == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">// 读取文件信息</span><br>  ilock(f-&gt;ip);<br>  area-&gt;inum = f-&gt;ip-&gt;inum;<br>  area-&gt;size = f-&gt;ip-&gt;size;<br>  iunlock(f-&gt;ip);<br>  <span class="hljs-comment">// 对该虚拟区域进行赋值并增加文件引用计数</span><br>  area-&gt;va_start = va;<br>  area-&gt;va_end = va + length;<br>  area-&gt;file_start = va;<br>  area-&gt;prot = prot;<br>  area-&gt;flags = flags;<br>  area-&gt;file = f;<br>  filedup(f);  <span class="hljs-comment">// 增加文件引用计数</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;map start-end:%p-%p\n&quot;</span>, area-&gt;va_start, area-&gt;va_end);<br>  <span class="hljs-keyword">return</span> va;<br>&#125;<br>uint64 <span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  uint64 addr;<br>  <span class="hljs-type">int</span> length;<br>  <span class="hljs-comment">// 读取相关参数</span><br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;munmap start-end:%p-%p\n&quot;</span>, addr, addr + length);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">return</span> delete_area(p, addr, addr + length);<br>&#125;<br></code></pre></td></tr></table></figure><p>在sysmap函数中检验参数步骤是由mmaptest中的测试得来的，单独记录file_start是因为unmap可能取消部分映射，所以文件的偏移量就不能从va_start计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// should be able to map file opened read-only with private writable</span><br><span class="hljs-comment">// mapping</span><br><br><span class="hljs-comment">// check that mmap doesn&#x27;t allow read/write mapping of a</span><br><span class="hljs-comment">// file opened read-only.</span><br></code></pre></td></tr></table></figure><p>页错误处理函，scause&#x3D;13&#x2F;15为读写页错误，修改usertrap函数<br><img src="https://img-blog.csdnimg.cn/3947e7fde7ae400d89106ec81bc9ae6c.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((which_dev = devintr()) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// ok</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>  uint64 va = r_stval();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">if</span> (process_mmap_page(p, va) != <span class="hljs-number">0</span>) &#123;<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125; <br><br><span class="hljs-comment">// proc.c</span><br><span class="hljs-comment">// 首先检查是否需要分配页，然后对不同模式的mmap进行处理，记录文件部分的长度是为了保持文件原本的大小</span><br><span class="hljs-comment">// 映射页时确保PTE_U位置位</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">process_mmap_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p, uint64 va)</span> &#123;  <span class="hljs-comment">// page fault时调用</span><br>  va = PGROUNDDOWN(va);<br>  <span class="hljs-type">char</span> *page = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 物理页地址</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> *<span class="hljs-title">area</span> =</span> find_area(p, va);<br>  <span class="hljs-keyword">if</span> (area == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;va:%p no such area\n&quot;</span>, va);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (walkaddr(p-&gt;pagetable, va) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;va:%p already mapped\n&quot;</span>, va);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-type">int</span> offset = va - area-&gt;file_start;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> area-&gt;file;<br>  <span class="hljs-type">int</span> length;<br>  <span class="hljs-keyword">if</span> (area-&gt;flags == MAP_SHARED) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">memory</span> =</span> reuse_shared_memory(area-&gt;inum, offset);    <span class="hljs-comment">// 尝试复用已经存在的共享页</span><br>    <span class="hljs-keyword">if</span> (memory == <span class="hljs-number">0</span>) &#123;                                                         <span class="hljs-comment">// 不存在相同文件文件的映射</span><br>      length = (offset + PGSIZE &gt; area-&gt;size) ? area-&gt;size - offset : PGSIZE;  <span class="hljs-comment">// 文件部分长度（unmap不应该扩大文件大小）</span><br>      memory = alloc_shared_memory(f, area-&gt;inum, offset, length);             <span class="hljs-comment">// 分配共享物理页并设置文件信息</span><br>      kernel_fileread(f, (uint64)memory-&gt;page, offset, PGSIZE);                <span class="hljs-comment">// 从文件中读取相应数据至物理页</span><br>    &#125;<br>    page = memory-&gt;page;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (area-&gt;flags == MAP_PRIVATE) &#123;<br>    page = kalloc();<br>    <span class="hljs-built_in">memset</span>(page, <span class="hljs-number">0</span>, PGSIZE);<br>    kernel_fileread(f, (uint64)page, offset, PGSIZE);  <span class="hljs-comment">// 从文件中读取相应数据至物理页</span><br>  &#125;<br><br>  <span class="hljs-type">int</span> prot = PTE_U;  <span class="hljs-comment">// 页权限</span><br>  <span class="hljs-keyword">if</span> (area-&gt;prot &amp; PROT_EXEC) &#123;<br>    prot |= PTE_X;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((area-&gt;prot &amp; PROT_READ)) &#123;<br>    prot |= PTE_R;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((area-&gt;prot &amp; PROT_WRITE)) &#123;<br>    prot |= PTE_W;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, (uint64)page, prot) != <span class="hljs-number">0</span>) &#123;<br>    kfree(page);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;map failed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;map va:%p to pa:%p\n&quot;</span>, va, (uint64)page);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;file offset:%d\n&quot;</span>, offset);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process id is %d\n&quot;</span>, p-&gt;pid);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改exit函数，在进程退出时unmap使用映射区域（调用free_all_area函数即可）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Exit the current process.  Does not return.</span><br><span class="hljs-comment">// An exited process remains in the zombie state</span><br><span class="hljs-comment">// until its parent calls wait().</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span> (p == initproc) panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;ofile[fd]) &#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 释放所有内存区域</span><br>  free_all_area(p);<br>  <br>  begin_op();<br>  iput(p-&gt;cwd);<br>  end_op();<br>  p-&gt;cwd = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Give any children to init.</span><br>  reparent(p);<br><br>  <span class="hljs-comment">// Parent might be sleeping in wait().</span><br>  wakeup(p-&gt;parent);<br><br>  acquire(&amp;p-&gt;lock);<br><br>  p-&gt;xstate = status;<br>  p-&gt;state = ZOMBIE;<br><br>  release(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Jump into the scheduler, never to return.</span><br>  sched();<br>  panic(<span class="hljs-string">&quot;zombie exit&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意free_all_area函数一定要在acquire(&amp;p-&gt;lock);语句之前，不然会发生重复请求锁错误<br><img src="https://img-blog.csdnimg.cn/366e36b2dc4942b8ab3b940a5c6dc925.png" srcset="/img/loading.gif" lazyload><br>这是因为unmap内存区域时有可能会进行文件写入操作，在进行文件写入时调用bwrite函数，其中调用了sleep函数，该函数再次请求p-&gt;lock</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Atomically release lock and sleep on chan.</span><br><span class="hljs-comment">// Reacquires lock when awakened.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);  <span class="hljs-comment">// DOC: sleeplock1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改fork函数，复制父进程的内存区域并增加文件引用计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-comment">// 复制内存区域并增加文件计数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MMAP_SIZE; i++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;mmap[i].used == <span class="hljs-number">1</span>) &#123;<br>      np-&gt;mmap[i] = p-&gt;mmap[i];<br>      filedup(np-&gt;mmap[i].file);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 复制空闲地址分配点</span><br>  np-&gt;free_memory_start = p-&gt;free_memory_start;<br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>辅助的文件读写操作定义在file.c，传入的地址为内核地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kernel_fileread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> size)</span> &#123;<br>  ilock(f-&gt;ip);<br>  <span class="hljs-keyword">if</span> ((readi(f-&gt;ip, <span class="hljs-number">0</span>, addr, offset, size)) &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read file error\n&quot;</span>);<br>    iunlock(f-&gt;ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  iunlock(f-&gt;ip);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kernel_filewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> n)</span> &#123;<br>  <span class="hljs-comment">// write a few blocks at a time to avoid exceeding</span><br>  <span class="hljs-comment">// the maximum log transaction size, including</span><br>  <span class="hljs-comment">// i-node, indirect block, allocation blocks,</span><br>  <span class="hljs-comment">// and 2 blocks of slop for non-aligned writes.</span><br>  <span class="hljs-comment">// this really belongs lower down, since writei()</span><br>  <span class="hljs-comment">// might be writing a device like the console.</span><br>  <span class="hljs-type">int</span> r, ret = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> max = ((MAXOPBLOCKS - <span class="hljs-number">1</span> - <span class="hljs-number">1</span> - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>) * BSIZE;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  f-&gt;off = offset;<br>  <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>    <span class="hljs-type">int</span> n1 = n - i;<br>    <span class="hljs-keyword">if</span> (n1 &gt; max) n1 = max;<br><br>    begin_op();<br>    ilock(f-&gt;ip);<br>    <span class="hljs-keyword">if</span> ((r = writei(f-&gt;ip, <span class="hljs-number">0</span>, addr + i, f-&gt;off, n1)) &gt; <span class="hljs-number">0</span>) f-&gt;off += r;<br>    iunlock(f-&gt;ip);<br>    end_op();<br><br>    <span class="hljs-keyword">if</span> (r != n1) &#123;<br>      <span class="hljs-comment">// error from writei</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    i += r;<br>  &#125;<br>  ret = (i == n ? n : <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>与shared_memory相关的操作定义在kalloc.c文件中，由于不能动态分配内存，使用静态数组的方式分配链表节点，共享物理页以单向链表的形式连接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kinit</span><span class="hljs-params">()</span> &#123;<br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  freerange(end, (<span class="hljs-type">void</span> *)PHYSTOP);<br>  <span class="hljs-comment">// 增加链表数组初始化与共享物理页链表初始化函数</span><br>  resource_init();<br>  init_shared_memory();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RESOURCE_SIZE 16</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> <span class="hljs-title">resource</span>[<span class="hljs-title">RESOURCE_SIZE</span>];</span>  <span class="hljs-comment">// 共享物理页链表数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">resource_init</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; RESOURCE_SIZE; i++) &#123;<br>    resource[i].used = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> shared_memory *<span class="hljs-title function_">find_unused_resource</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; RESOURCE_SIZE; i++) &#123;<br>    <span class="hljs-keyword">if</span> (resource[i].used == <span class="hljs-number">0</span>) &#123;<br>      resource[i].used = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> &amp;resource[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">head</span>;</span>           <span class="hljs-comment">// 共享物理页链表头指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">shared_memory_lock</span>;</span>  <span class="hljs-comment">// 共享物理页链表锁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_shared_memory</span><span class="hljs-params">()</span> &#123;           <span class="hljs-comment">// 初始化共享物理页链表</span><br>  head = find_unused_resource();<br>  head-&gt;next = <span class="hljs-number">0</span>;<br>  initsleeplock(&amp;shared_memory_lock, <span class="hljs-string">&quot;shared_memory&quot;</span>);<br>&#125;<br><span class="hljs-keyword">struct</span> shared_memory *<span class="hljs-title function_">alloc_shared_memory</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, uint inum, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;  <span class="hljs-comment">// 分配新的共享物理页节点</span><br>  acquiresleep(&amp;shared_memory_lock);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">node</span> =</span> find_unused_resource();<br>  <span class="hljs-keyword">if</span> (node == <span class="hljs-number">0</span>) &#123;<br>    releasesleep(&amp;shared_memory_lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  node-&gt;page = kalloc();  <span class="hljs-comment">// 申请物理页并清零</span><br>  <span class="hljs-keyword">if</span> (node-&gt;page == <span class="hljs-number">0</span>) &#123;<br>    releasesleep(&amp;shared_memory_lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-built_in">memset</span>(node-&gt;page, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-comment">// 加入链表</span><br>  node-&gt;next = head-&gt;next;<br>  head-&gt;next = node;<br>  <span class="hljs-comment">// 设置属性</span><br>  node-&gt;file = file;<br>  node-&gt;offset = offset;<br>  node-&gt;length = length;<br>  node-&gt;inum = inum;<br>  node-&gt;ref_cnt = <span class="hljs-number">1</span>;<br>  node-&gt;is_dirty = <span class="hljs-number">0</span>;<br>  releasesleep(&amp;shared_memory_lock);<br>  <span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-comment">// 以inode号与文件偏移作为索引寻找共享物理页</span><br><span class="hljs-keyword">struct</span> shared_memory *<span class="hljs-title function_">find_shared_memory</span><span class="hljs-params">(uint inum, <span class="hljs-type">int</span> offset, <span class="hljs-keyword">struct</span> shared_memory **parent)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">p</span> =</span> head;<br>  <span class="hljs-keyword">while</span> (p-&gt;next != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;next-&gt;inum == inum &amp;&amp; p-&gt;next-&gt;offset == offset) &#123;<br>      <span class="hljs-keyword">if</span> (parent != <span class="hljs-number">0</span>) &#123;<br>        *parent = p;<br>      &#125;<br>      <span class="hljs-keyword">return</span> p-&gt;next;<br>    &#125;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 尝试重用现有的共享物理页，失败返回0</span><br><span class="hljs-keyword">struct</span> shared_memory *<span class="hljs-title function_">reuse_shared_memory</span><span class="hljs-params">(uint inum, <span class="hljs-type">int</span> offset)</span> &#123;<br>  acquiresleep(&amp;shared_memory_lock);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">p</span> =</span> find_shared_memory(inum, offset, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-number">0</span>) &#123;<br>    releasesleep(&amp;shared_memory_lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  p-&gt;ref_cnt++;<br>  releasesleep(&amp;shared_memory_lock);<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">// 降低共享物理页引用次数，引用次数为0则删除该物理页</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_shared_memory</span><span class="hljs-params">(uint inum, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> is_dirty)</span> &#123;<br>  acquiresleep(&amp;shared_memory_lock);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">parent</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_memory</span> *<span class="hljs-title">memory</span> =</span> find_shared_memory(inum, offset, &amp;parent);<br>  <span class="hljs-keyword">if</span> (memory == <span class="hljs-number">0</span>) &#123;<br>    releasesleep(&amp;shared_memory_lock);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  memory-&gt;ref_cnt--;<br>  <span class="hljs-keyword">if</span> (is_dirty != <span class="hljs-number">0</span>) &#123;<br>    memory-&gt;is_dirty = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (memory-&gt;ref_cnt == <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">// 引用次数为0</span><br>    <span class="hljs-keyword">if</span> (memory-&gt;is_dirty == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 内容被修改，写入文件</span><br>      kernel_filewrite(memory-&gt;file, (uint64)memory-&gt;page, memory-&gt;offset, memory-&gt;length);<br>    &#125;<br>    kfree(memory-&gt;page);<br>    memory-&gt;used = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 在链表中删除该节点</span><br>    parent-&gt;next = memory-&gt;next;<br>  &#125;<br>  releasesleep(&amp;shared_memory_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里使用的sleeplock，如果使用spinlock，在kernel_filewrite中会调用sleep函数，导致sched locks错误。<br>也就是说<mark>自旋锁中不能调用休眠函数</mark><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liaojunwu/article/details/120398320">为什么拥有自旋锁的代码段不能睡眠？</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  push_off(); <span class="hljs-comment">// disable interrupts to avoid deadlock.</span><br>&#125;<br><span class="hljs-comment">// 调用完acquire函数后，mycpu()-&gt;noff!=1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span> &#123;<br>  sched();<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> intena;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span> (!holding(&amp;p-&gt;lock)) panic(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br>  <span class="hljs-keyword">if</span> (mycpu()-&gt;noff != <span class="hljs-number">1</span>) panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>  <span class="hljs-keyword">if</span> (p-&gt;state == RUNNING) panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br>  <span class="hljs-keyword">if</span> (intr_get()) panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = mycpu()-&gt;intena;<br>  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br>  mycpu()-&gt;intena = intena;<br>&#125;<br></code></pre></td></tr></table></figure><p>与vm_area相关的操作定义在proc.c，同样是使用proc中的静态数组分配结构体，注意在delete_area时有可能一些区域从头到尾都没有被访问，也就没有分配对应的物理页，故不需要释放物理页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> vm_area *<span class="hljs-title function_">alloc_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span> &#123;  <span class="hljs-comment">// 分配未使用的内存区域</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> *<span class="hljs-title">area</span>;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MMAP_SIZE; i++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;mmap[i].used == <span class="hljs-number">0</span>) &#123;<br>      area = &amp;p-&gt;mmap[i];<br>      area-&gt;used = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> area;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> vm_area *<span class="hljs-title function_">find_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p, uint64 va)</span> &#123;  <span class="hljs-comment">// 找到虚拟地址对应的内存区域</span><br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> *<span class="hljs-title">area</span>;</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MMAP_SIZE; i++) &#123;<br>    area = &amp;p-&gt;mmap[i];<br>    <span class="hljs-keyword">if</span> (area-&gt;used == <span class="hljs-number">1</span> &amp;&amp; va &gt;= area-&gt;va_start &amp;&amp; va &lt; area-&gt;va_end) &#123;<br>      <span class="hljs-keyword">return</span> area;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">delete_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p, uint64 va_start, uint64 va_end)</span> &#123;  <span class="hljs-comment">// 删除该段地址空间</span><br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-type">int</span> is_dirty;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> *<span class="hljs-title">area</span> =</span> find_area(p, va_start);<br>  <span class="hljs-keyword">if</span> (area == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">for</span> (uint64 va = va_start; va &lt; va_end; va += PGSIZE) &#123;<br>    <span class="hljs-keyword">if</span> (walkaddr(p-&gt;pagetable, va) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this page is not map,ignored. address:%p\n&quot;</span>, va);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (area-&gt;flags == MAP_SHARED) &#123;<br>      pte = walk(p-&gt;pagetable, va, <span class="hljs-number">0</span>);<br>      is_dirty = *pte &amp; PTE_D;                                            <span class="hljs-comment">// 获取dirty bit</span><br>      delete_shared_memory(area-&gt;inum, va - area-&gt;file_start, is_dirty);  <span class="hljs-comment">// 删除共享物理页（减小引用计数）</span><br>      uvmunmap(p-&gt;pagetable, va, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                                   <span class="hljs-comment">// 取消映射，但不释放物理页</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (area-&gt;flags == MAP_PRIVATE) &#123;<br>      uvmunmap(p-&gt;pagetable, va, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 取消映射同时释放物理页</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unmap address:%p\n&quot;</span>, va);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((area-&gt;va_start = va_start) &amp;&amp; (area-&gt;va_end == va_end)) &#123;  <span class="hljs-comment">// 完全删除</span><br>    fileclose(area-&gt;file);                                        <span class="hljs-comment">// 减小文件引用计数</span><br>    area-&gt;used = <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 部分删除，修改虚拟内存区域</span><br>    <span class="hljs-keyword">if</span> (area-&gt;va_start == va_start) &#123;<br>      area-&gt;va_start = va_end;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (area-&gt;va_end == va_end) &#123;<br>      area-&gt;va_end = va_start;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">free_all_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span> &#123;  <span class="hljs-comment">// 释放所有内存区域，在exit时调用</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area</span> *<span class="hljs-title">area</span>;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MMAP_SIZE; i++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;mmap[i].used == <span class="hljs-number">1</span>) &#123;<br>      area = &amp;p-&gt;mmap[i];<br>      delete_area(p, area-&gt;va_start, area-&gt;va_end);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>gdb时输出变量显示optimized out，修改Makefile中的优化等级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">CFLAGS = -Wall -Werror -O0 -fno-omit-frame-pointer -ggdb<br></code></pre></td></tr></table></figure><p><strong>通过截图</strong><br><img src="https://img-blog.csdnimg.cn/8b9db43881dc4eb682d729ea43bcbf3b.png" srcset="/img/loading.gif" lazyload></p><p><mark>若有遗漏的地方，望请告知</mark></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%9B%BD%E5%A4%96%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/" class="category-chain-item">国外课程实验</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/6-081-mmap/" class="print-no-link">#6.081 mmap</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/blog/MIT6.S081%20Multithreading.html" title="MIT6.S081 Multithreading"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MIT6.S081 Multithreading</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/MIT6.S081%202021%20file%20system.html" title="MIT6.S081 2021 file system"><span class="hidden-mobile">MIT6.S081 2021 file system</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz","appKey":"0e2MMh7ddBCGGytOe9UEy5NP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://uu0wegco.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>