

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/nano-1.jpg">
  <link rel="icon" href="/img/nano-1.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="最佳损友1020">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考源码地址：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kernel&#x2F;v4.x&#x2F;linux-4.19.90.tar.gz      linux-4.19.90\drivers\nvme\host  源码阅读环境：Windows 搭建 opengrok|极客教程 (geek-docs.com) 书籍：《LINUX设备驱动程序》 初始化参考链接：linux里的nv">
<meta property="og:type" content="article">
<meta property="og:title" content="NVMe驱动学习记录-2">
<meta property="og:url" content="https://www.jiasun.top/blog/NVMe%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2.html">
<meta property="og:site_name" content="最佳损友1020’s Blog">
<meta property="og:description" content="参考源码地址：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kernel&#x2F;v4.x&#x2F;linux-4.19.90.tar.gz      linux-4.19.90\drivers\nvme\host  源码阅读环境：Windows 搭建 opengrok|极客教程 (geek-docs.com) 书籍：《LINUX设备驱动程序》 初始化参考链接：linux里的nv">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4ecd7c7deba418d2d5ceba1203f15d13.png">
<meta property="og:image" content="https://img-blog.csdn.net/20160604114927706">
<meta property="article:published_time" content="2022-05-12T08:34:08.000Z">
<meta property="article:modified_time" content="2023-10-31T14:45:58.994Z">
<meta property="article:author" content="最佳损友1020">
<meta property="article:tag" content="学习 linux 驱动开发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/4ecd7c7deba418d2d5ceba1203f15d13.png">
  
  
  
  <title>NVMe驱动学习记录-2 - 最佳损友1020’s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/csdn.css">
<link rel="stylesheet" href="/css/top.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.jiasun.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz","app_key":"ljkRZDiTtVmjn5mpaQmpFqgv","server_url":"https://n227fxnj.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>最佳损友1020</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="NVMe驱动学习记录-2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-12 16:34" pubdate>
          2022年5月12日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          39k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          322 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">NVMe驱动学习记录-2</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer" />


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>源码地址：<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-4.19.90.tar.gz">https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-4.19.90.tar.gz</a>    </p>
<blockquote>
<p>linux-4.19.90\drivers\nvme\host</p>
</blockquote>
<p>源码阅读环境：<a target="_blank" rel="noopener" href="https://geek-docs.com/personal/obama/windows-setup-opengrok.html">Windows 搭建 opengrok|极客教程 (geek-docs.com)</a></p>
<p>书籍：<a target="_blank" rel="noopener" href="https://github.com/1020xyr/books/blob/main/LINUX%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F(%E7%AC%AC3%E7%89%88).pdf">《LINUX设备驱动程序》</a></p>
<p>初始化参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/panzhenjie/article/details/51581063">linux里的nvme驱动代码分析（加载初始化） </a> nvme_reset_work()函数后的代码大致相同</p>
<p>IO入口点：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72234187">NVMe的Linux内核驱动分析</a></p>
<p>块设备层相关数据结构：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32740107/article/details/106302376?spm=1001.2014.3001.5501">Block multi-queue 架构解析（一）数据结构</a></p>
<p>块设备层文档：<a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/block_device_drivers.html#block-device-drivers">Block Device Drivers</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tolimit/p/8779876.html">linux内核源码分析 - nvme设备的初始化</a></p>
<p>函数查询：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/ident">identifier - Linux source code (v5.14.9) - Bootlin</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4ecd7c7deba418d2d5ceba1203f15d13.png" srcset="/img/loading.gif" lazyload alt="preview"></p>
<p>其他博客</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/daocaokafei/article/details/108071589">手把手教Linux驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaojiang1025/category/918665.html?page=2">linux驱动开发</a></p>
<p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/karenchan/topics/1006006">nvme kernel driver 阅读笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1338070478725480449">nvme协议详解</a></p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><h2 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">nvme_core模块初始化<br>	nvme_core_init():创建工作队列，类；申请设备号<br>nvme模块初始化<br>	nvme_init():注册pci_driver结构体<br>	nvme_probe()<br>		nvme_dev_map():申请IO内存并进行映射<br>		nvme_setup_prp_pools():创建DMA池<br>		nvme_init_ctrl():填充nvme_ctrl结构体，创建字符设备<br>		nvme_reset_ctrl():修改nvme_ctrl结构体状态，将nvme_reset_work加入工作队列nvme_reset_wq<br>    <br>	<span class="hljs-title function_">nvme_reset_work</span><span class="hljs-params">()</span>:重启设备，涉及许多nvme协议相关知识，还有设备各阶段对寄存器的操作，没太仔细看，就对照博客看一下功能即可<br>    	<span class="hljs-title function_">nvme_dev_disable</span><span class="hljs-params">(dev, <span class="hljs-literal">false</span>)</span>:正常关机<br>		<span class="hljs-title function_">nvme_pci_enable</span><span class="hljs-params">()</span>:初始化pci设备（BAR寄存器，MSI-X中断，CMB等)<br>  		<span class="hljs-title function_">nvme_pci_configure_admin_queue</span><span class="hljs-params">()</span>:映射bar寄存器，申请并初始化admin队列<br>		<span class="hljs-title function_">nvme_alloc_admin_tags</span><span class="hljs-params">()</span>:初始化dev-&gt;admin_tagset结构体，并创建请求队列<br>    	<span class="hljs-title function_">nvme_init_identify</span><span class="hljs-params">()</span>: 向NVMe设备发送identify命令<br>    	<span class="hljs-title function_">nvme_setup_io_queues</span><span class="hljs-params">()</span>:向NVMe设备发送<span class="hljs-built_in">set</span> feature命令，再次申请中断号，注册中断函数 申请空间，创建IO队列<br>    	<span class="hljs-title function_">nvme_dev_add</span><span class="hljs-params">()</span>:填充dev-&gt;tagset <br>    	<span class="hljs-title function_">nvme_start_ctrl</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title function_">nvme_queue_scan</span><span class="hljs-params">()</span>-&gt;ctrl-&gt;scan_work-&gt;<span class="hljs-title function_">nvme_scan_work</span><span class="hljs-params">()</span><br>    <br>    <span class="hljs-title function_">nvme_scan_work</span><span class="hljs-params">()</span>: 发送一系列identify命令，创建块设备<br>    只需看<span class="hljs-title function_">nvme_scan_ns_list</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title function_">nvme_validate_ns</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title function_">nvme_alloc_ns</span><span class="hljs-params">()</span><br>    	<span class="hljs-title function_">nvme_alloc_ns</span><span class="hljs-params">()</span>:填充ns，创建块设备<br><br></code></pre></td></tr></table></figure>

<h2 id="不了解的函数-概念"><a href="#不了解的函数-概念" class="headerlink" title="不了解的函数&#x2F;概念"></a>不了解的函数&#x2F;概念</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">一个模块mod1中定义一个函数func1；在另外一个模块mod2中定义一个函数func2，func2调用func1。<br>在模块mod1中，EXPORT_SYMBOL(func1);<br>在模块mod2中，<span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>;<br>就可以在mod2中调用func1了。<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vedic/p/11069249.html">workqueue</a></p>
<p>workqueue是对内核线程封装的用于处理各种工作项的一种处理方法， 由于处理对象是用链表拼接一个个工作项， 依次取出来处理， 然后从链表删除，就像一个队列排好队依次处理一样， 所以也称工作队列</p>
<p>所谓封装可以简单理解一个中转站， 一边指向“合适”的内核线程， 一边接受你丢过来的工作项， 用结构体 workqueue_srtuct表示， 而所谓工作项也是个结构体 –  work_struct， 里面有个成员指针， 指向你最终要实现的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">workqueue_struct</span> *<span class="hljs-title">workqueue_test</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work_test</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">work_test_func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;%s()\n&quot;</span>, __func__);<br><br>    <span class="hljs-comment">//mdelay(1000);</span><br>    <span class="hljs-comment">//queue_work(workqueue_test, &amp;work_test);</span><br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;Hello,world!\n&quot;</span>);<br><br>    <span class="hljs-comment">/* 1. 自己创建一个workqueue， 中间参数为0，默认配置 */</span><br>    workqueue_test = alloc_workqueue(<span class="hljs-string">&quot;workqueue_test&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* 2. 初始化一个工作项，并添加自己实现的函数 */</span><br>    INIT_WORK(&amp;work_test, work_test_func);<br><br>    <span class="hljs-comment">/* 3. 将自己的工作项添加到指定的工作队列去， 同时唤醒相应线程处理 */</span><br>    queue_work(workqueue_test, &amp;work_test);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>alloc_chrdev_region</p>
</blockquote>
<p>alloc_chrdev_region是让内核分配给我们一个尚未使用的主设备号，不是由我们自己指定的，该函数的四个参数意义如下：</p>
<p>dev :alloc_chrdev_region函数向内核申请下来的设备号</p>
<p>baseminor :次设备号的起始</p>
<p>count: 申请次设备号的个数</p>
<p>name :执行 cat &#x2F;proc&#x2F;devices显示的名称</p>
<blockquote>
<p>class_create</p>
</blockquote>
<p>内核中定义了struct class结构体，一个struct class 结构体类型变量对应一个类，内核同时提供了 class_create () 函数 ，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建了这个类，再调用device_create () 函数 在&#x2F;dev目录下创建相应的设备节点（&#x2F;sys&#x2F;class&#x2F;类名&#x2F;设备名）</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Cqlismy/p/11507216.html">struct device</a></p>
<p>Linux内核中的设备驱动模型，是建立在sysfs设备文件系统和kobject上的，由总线（bus）、设备（device）、驱动（driver）和类（class）所组成的关系结构，在底层，Linux系统中的每个设备都有一个device结构体的实例</p>
<p>dev_to_node：返回struct device中的numa_node变量，即所属的内存节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>	<span class="hljs-type">int</span>		numa_node;	<span class="hljs-comment">/* NUMA node this device is close to */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dev_to_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> dev-&gt;numa_node;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>kzalloc_node：从特定的内存节点分配零内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kzalloc_node - allocate zeroed memory from a particular memory node.</span><br><span class="hljs-comment"> * @size: how many bytes of memory are required.</span><br><span class="hljs-comment"> * @flags: the type of memory to allocate (see kmalloc).</span><br><span class="hljs-comment"> * @node: memory node from which to allocate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">kzalloc_node</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> kmalloc_node(size, flags | __GFP_ZERO, node);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/596648">kcalloc_node</a></p>
<p>驱动中的队列，通过函数kcalloc_node创建，可以看到队列数量是和系统中所拥有的cpu数量有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dev-&gt;queues = kcalloc_node(num_possible_cpus() + <span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> nvme_queue), GFP_KERNEL, node);<br></code></pre></td></tr></table></figure>

<p>Queue有的概念，那就是队列深度,表示其能够放多少个成员。在NVMe中，这个队列深度是由NVMe SSD决定的，存储在NVMe设备的BAR空间里。</p>
<p>队列用来存放NVMe Command，NVMe Command是主机与SSD控制器交流的基本单元，应用的I&#x2F;O请求也要转化成NVMe Command。</p>
<p>不过需要注意的是，就算有很多CPU发送请求，但是块层并不能保证都能处理完，将来可能要绕过IO栈的块层，不然瓶颈就是操作系统本身了。</p>
<p>当前Linux内核提供了blk_queue_make_request函数，调用这个函数注册自定义的队列处理方法，可以绕过io调度和io队列，从而缩短io延时。Block层收到上层发送的IO请求，就会选择该方法处理</p>
<p><a target="_blank" rel="noopener" href="https://deepinout.com/linux-kernel-api/device-driver-and-device-management/linux-kernel-api-get_device.html">get_device</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> device *<span class="hljs-title function_">get_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br></code></pre></td></tr></table></figure>

<p>get_device输入参数说明<br>函数get_device()的输入参数是struct device结构体类型的指针，代表增加计数的逻辑设备<br>get_device返回参数说明<br>函数get_device()的返回结果是struct device结构体类型的变量，返回的结果与传入的参数代表的是同一个变量，只是此时变量的引用计数器的值增大了1。</p>
<blockquote>
<p>pci_set_drvdata</p>
</blockquote>
<p>pci_set_drvdata() 为pci_dev设置私有数据指针,把设备指针地址放入PCI设备中的设备指针中，便于后面调用pci_get_drvdata</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">pci_set_drvdata</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *pdev, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>	dev_set_drvdata(&amp;pdev-&gt;dev, data);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dev_set_drvdata</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>	dev-&gt;driver_data = data;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p>to_pci_dev</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">dev-&gt;dev = get_device(&amp;pdev-&gt;dev);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span> *<span class="hljs-title">pdev</span> =</span> to_pci_dev(dev-&gt;dev);<br></code></pre></td></tr></table></figure>

<p>to_pci_dev应该是对container_of宏的封装，根据成员地址获得结构体地址。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyflying2012/article/details/8672011">pci_request_mem_regions</a></p>
<p>pci_request_mem_regions应该是对request_mem_region的封装，</p>
<p>几乎每一种外设都是通过读写设备上的寄存器来进行的，通常包括控制寄存器、状态寄存器和数据寄存器三大类，外设的寄存器通常被连续地编址。根据CPU体系结构的不同，CPU对IO端口的编址方式有两种：</p>
<p>　　（1）I&#x2F;O映射方式（I&#x2F;O-mapped）</p>
<p>　　典型地，如X86处理器为外设专门实现了一个单独的地址空间，称为”I&#x2F;O地址空间”或者”I&#x2F;O端口空间”，CPU通过专门的I&#x2F;O指令（如X86的IN和OUT指令）来访问这一空间中的地址单元。</p>
<p>　　（2）内存映射方式（Memory-mapped）</p>
<p>　　RISC指令系统的CPU（如MIPS ARM PowerPC等）通常只实现一个物理地址空间，像这种情况,外设的I&#x2F;O端口的物理地址就被映射到内存地址空间中，外设I&#x2F;O端口成为内存的一部分。此时，CPU可以象访问一个内存单元那样访问外设I&#x2F;O端口，而不需要设立专门的外设I&#x2F;O指令。</p>
<p>　　但是，这两者在硬件实现上的差异对于软件来说是完全透明的，驱动程序开发人员可以将内存映射方式的I&#x2F;O端口和外设内存统一看作是”I&#x2F;O内存”资源。</p>
<p>　　一般来说，在系统运行时，外设的I&#x2F;O内存资源的物理地址是已知的，由硬件的设计决定。但是CPU通常并没有为这些已知的外设I&#x2F;O内存资源的物理地址预定义虚拟地址范围，驱动程序并不能直接通过物理地址访问I&#x2F;O内存资源，而必须将它们映射到核心虚地址空间内（通过页表），然后才能根据映射所得到的核心虚地址范围，通过访内指令访问这些I&#x2F;O内存资源。Linux在io.h头文件中声明了函数ioremap（），用来将I&#x2F;O内存资源的物理地址映射到核心虚地址空间。</p>
<p>但要使用I&#x2F;O内存首先要申请,然后才能映射,使用I&#x2F;O端口首先要申请,或者叫请求,对于I&#x2F;O端口的请求意思是让内核知道你要访问这个端口,这样内核知道了以后它就不会再让别人也访问这个端口了.毕竟这个世界僧多粥少啊.申请I&#x2F;O端口的函数是request_region, 申请I&#x2F;O内存的函数是request_mem_region， 来自include&#x2F;linux&#x2F;ioport.h</p>
<p>说白了，request_mem_region函数并没有做实际性的映射工作，只是告诉内核要使用一块内存地址，声明占有，也方便内核管理这些资源。</p>
<p>重要的还是ioremap函数，ioremap主要是检查传入地址的合法性，建立页表（包括访问权限），完成物理地址到虚拟地址的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">ioremap</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phys_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span>;<br><br>iounmap函数用于取消ioremap（）所做的映射，原型如下：<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">iounmap</span><span class="hljs-params">(<span class="hljs-type">void</span> * addr)</span>;<br></code></pre></td></tr></table></figure>

<p>在将I&#x2F;O内存资源的物理地址映射成核心虚地址后，理论上讲我们就可以像读写RAM那样直接读写I&#x2F;O内存资源了。为了保证驱动程序的跨平台的可移植性，我们应该使用Linux中特定的函数来访问I&#x2F;O内存资源，而不应该通过指向核心虚地址的指针来访问。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/390998915">pci_resource_start</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> pci_resource_start(dev,bar) ((dev)-&gt;resource[(bar)].start)</span><br></code></pre></td></tr></table></figure>



<p>在硬件加电初始化时，BIOS固件同统一检查了所有的PCI设备， 并统一为他们分配了一个和其他互不冲突的地址，让他们的驱动程序可以向这些地址映射他们的寄存器，这些地址被BIOS写进了各个设备的配置空间，因为这个 活动是一个PCI的标准的活动，所以自然写到各个设备的配置空间里而不是他们风格各异的控制寄存器空间里。当然只有BIOS可以访问配置空间。当操作系统 初始化时，他为每个PCI设备分配了pci_dev结构，并且把BIOS获得的并写到了配置空间中的地址读出来写到了pci_dev中的resource 字段中。这样以后我们在读这些地址就不需要在访问配置空间了，直接跟pci_dev要就可以了，我们这里的四个函数就是直接从pci_dev读出了相关数 据，代码在include&#x2F;linux&#x2F;pci.h中。定义如下：</p>
<p>#define pci_resource_start(dev,bar) ((dev)-&gt;resource[(bar)].start)<br>#define pci_resource_end(dev,bar) ((dev)-&gt;resource[(bar)].end)</p>
<p>这里需要说明一下，每个PCI设备有0-5一共6个地址空间，我们通常只使用前两个，这里我们把参数1传给了bar就是使用内存映射的地址空间。</p>
<p>如果要更具体，查看pci_dev结构的初始化过程</p>
<p>调用pci_resource_flags函数来判断PCI是内存映射模式，还是IO模式</p>
<p>调用pci_resource_len函数来判断内存空间是否小于设备所需要的内存空间，如果小于，明显出错</p>
<p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2011-10/44625p3.htm">init_completion</a></p>
<p>首先是struct completion的结构，由一个计数值和一个等待队列组成。</p>
<p>1、unsigned int done;</p>
<p>指示等待的事件是否完成。初始化时为0。如果为0，则表示等待的事件未完成。大于0表示等待的事件已经完成。</p>
<p>2、wait_queue_head_t wait;</p>
<p>存放等待该事件完成的进程队列</p>
<p>completion是类似于信号量的东西，用completion.done来表示资源是否可用，获取不到的线程会阻塞在completion.wait的等待队列上，直到其它线程释放completion</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/renlonggg/article/details/82684407">物理地址、虚拟地址、总线地址</a></p>
<p>所有的地址都可以称为总线地址，因为开发环境下所有的设备都是接在总线上，如AXI总线，APB总线，PCI总线 I2C总线 SPI总线。也就会存在很多种地址空间。</p>
<p>大部分情况下，总线地址&#x3D;物理地址，为什么呢，物理地址是处理器在该系统总线上发出的地址，因此处理器发出的物理地址完全可以理解为处理器地址空间的总线地址，这肯定是相等的。</p>
<p>大部分程序操作都是处理器作为主设备，根据指令，来发出地址，读写数据。这时总线地址&#x3D;物理地址</p>
<p>有一种情况下不是处理器做主设备，DMA，DMA controller操作RAM是不需要经过处理器的，这是DMA controller是主设备，但是因为DMA controller也是挂接在系统总线上，也就是处理器的地址空间中。</p>
<p>所以这时DMA controller发出的地址也是物理地址。</p>
<p><strong>有一种特殊情况下，总线地址与物理地址不同，就是PCI总线。</strong></p>
<p>因为PCI总线存在地址映射，这是因为PCI控制器内部有桥接电路，桥接电路会将I&#x2F;O地址映射为不同的物理地址。</p>
<p>可以想象，PCI控制器挂接在处理器的系统总线上，而另一端的PCI总线上外扩了一些PCI设备。</p>
<p>假如某个PCI设备具有DMA能力，要去操作RAM，这时该设备看到的RAM的地址就应该是由系统总线映射到PCI总线上的总线地址。</p>
<p>映射关系由PCI控制器地址窗口来配置，一般是一个偏移量，所以这时映射到PCI总线上的RAM的总线地址就不是RAM在处理器系统地址空间上的物理地址（也可以称为系统总线地址）了。</p>
<p>因此总线地址  ！&#x3D;  物理地址</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/51089088">dma_pool_create</a></p>
<p> 许多驱动程序需要又多又小的一致映射内存区域给DMA描述子或I&#x2F;O缓存buffer，这使用DMA池比用dma_alloc_coherent分配的一页或多页内存区域好，DMA池用函数dma_pool_create创建，用函数dma_pool_alloc从DMA池中分配一块一致内存，用函数dmp_pool_free放内存回到DMA池中，使用函数dma_pool_destory释放DMA池的资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_pool</span> &#123;</span>	<span class="hljs-comment">/* the pool */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">page_list</span>;</span><span class="hljs-comment">//页链表</span><br>	<span class="hljs-type">spinlock_t</span>		lock;<br>	<span class="hljs-type">size_t</span>			blocks_per_page;　<span class="hljs-comment">//每页的块数</span><br>	<span class="hljs-type">size_t</span>			size;     <span class="hljs-comment">//DMA池里的一致内存块的大小</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>		*<span class="hljs-title">dev</span>;</span> <span class="hljs-comment">//将做DMA的设备</span><br>	<span class="hljs-type">size_t</span>			allocation; <span class="hljs-comment">//分配的没有跨越边界的块数，是size的整数倍</span><br>	<span class="hljs-type">char</span>			name [<span class="hljs-number">32</span>];　<span class="hljs-comment">//池的名字</span><br>	<span class="hljs-type">wait_queue_head_t</span>	waitq;  <span class="hljs-comment">//等待队列</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">pools</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> dma_pool *<span class="hljs-title function_">dma_pool_create</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-keyword">struct</span> device *dev,</span><br><span class="hljs-params">	　　　　　　　　　　<span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> align, <span class="hljs-type">size_t</span> allocation)</span><br></code></pre></td></tr></table></figure>



<p> 函数<strong>dma_pool_create</strong>给DMA创建一个一致内存块池，其参数name是DMA池的名字，用于诊断用，参数dev是将做DMA的设备，参数size是DMA池里的块的大小，参数align是块的对齐要求，是2的幂，参数allocation返回没有跨越边界的块数（或0）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaohua0877/article/details/78515472">WARN_ON_ONCE</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">而WARN_ON则是调用dump_stack，打印堆栈信息，不会OOPS<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WARN_ON(condition) do &#123; </span><br><br>    <span class="hljs-keyword">if</span> (unlikely((condition)!=<span class="hljs-number">0</span>)) &#123; <br><br>        printk(<span class="hljs-string">&quot;Badness in %s at %s:%d/n&quot;</span>, __FUNCTION__, __FILE__,__LINE__); <br><br>        dump_stack(); <br><br>    &#125; <br><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_22338935/article/details/118719738#:~:text=mempool_,it_node%EF%BC%9A">mempool_create_node</a></p>
<p>内存池(Memery Pool)技术是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。 不仅在用户态应用程序中被广泛使用，同时在Linux内核也被广泛使用，在内核中有不少地方内存分配不允许失败。作为一个在这些情况下确保分配的方式，内核开发者创建了一个已知为内存池(或者是 “mempool” )的抽象，内核中内存池真实地只是相当于后备缓存，它尽力一直保持一个空闲内存列表给紧急时使用，而在通常情况下有内存需求时还是从公共的内存中直接分配，这样的做法虽然有点霸占内存的嫌疑，但是可以从根本上保证关键应用在内存紧张时申请内存仍然能够成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mempool_s</span> &#123;</span><br>	<span class="hljs-type">spinlock_t</span> lock;<span class="hljs-comment">//防止多处理器并发而引入的锁</span><br>	<span class="hljs-type">int</span> min_nr;	<span class="hljs-comment">//elements数组中的成员数量</span><br>	<span class="hljs-type">int</span> curr_nr;<span class="hljs-comment">//当前elements数组中空闲的成员数量</span><br>	<span class="hljs-type">void</span> **elements;<span class="hljs-comment">//用来存放内存成员的二维数组，等于elements[min_nr][内存对象的长度]</span><br><br>	<span class="hljs-comment">//内存池与内核缓冲区结合使用的指针(这个指针专门用来指向这种内存对象对应的缓存区的指针)</span><br>	<span class="hljs-type">void</span> *pool_data;<br>	<span class="hljs-type">mempool_alloc_t</span> *alloc;<span class="hljs-comment">//内存分配函数</span><br>	<span class="hljs-type">mempool_free_t</span> *<span class="hljs-built_in">free</span>;<span class="hljs-comment">//内存释放函数</span><br>	<span class="hljs-type">wait_queue_head_t</span> wait;<span class="hljs-comment">//任务等待队列</span><br>&#125; <span class="hljs-type">mempool_t</span>;<br><span class="hljs-type">mempool_t</span> *<span class="hljs-title function_">mempool_create</span><span class="hljs-params">(<span class="hljs-type">int</span> min_nr, <span class="hljs-type">mempool_alloc_t</span> *alloc_fn,</span><br><span class="hljs-params">				<span class="hljs-type">mempool_free_t</span> *free_fn, <span class="hljs-type">void</span> *pool_data)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> mempool_create_node(min_nr,alloc_fn,free_fn, pool_data,<br>				   GFP_KERNEL, NUMA_NO_NODE);<br>&#125;<br>EXPORT_SYMBOL(mempool_create);<br><br><span class="hljs-comment">/******************</span><br><span class="hljs-comment">创建一个内存池对象</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">min_nr ： 	为内存池分配的最小内存成员数量</span><br><span class="hljs-comment">alloc_fn ： 用户自定义内存分配函数(可以使用系统定义函数)</span><br><span class="hljs-comment">free_fn :	用户自定义内存释放函数(可以使用系统定义函数)</span><br><span class="hljs-comment">pool.data ：根据用户自定义内存分配函数所提供的可选私有数据，一般是缓存区指针</span><br><span class="hljs-comment">gfp_mask ： 内存分配掩码</span><br><span class="hljs-comment">node_id ： 	内存节点的id</span><br><span class="hljs-comment">******************/</span><br><span class="hljs-type">mempool_t</span> *<span class="hljs-title function_">mempool_create_node</span><span class="hljs-params">(<span class="hljs-type">int</span> min_nr, <span class="hljs-type">mempool_alloc_t</span> *alloc_fn,</span><br><span class="hljs-params">			       <span class="hljs-type">mempool_free_t</span> *free_fn, <span class="hljs-type">void</span> *pool_data,</span><br><span class="hljs-params">			       <span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">int</span> node_id)</span><br>&#123;<br>	<span class="hljs-type">mempool_t</span> *pool;<br><br>	<span class="hljs-comment">//为内存池对象分配内存</span><br>	pool = kzalloc_node(<span class="hljs-keyword">sizeof</span>(*pool), gfp_mask, node_id);<br>	<span class="hljs-keyword">if</span> (!pool)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">//初始化内存池</span><br>	<span class="hljs-keyword">if</span> (mempool_init_node(pool, min_nr, alloc_fn, free_fn, pool_data,<br>			      gfp_mask, node_id)) &#123;<br>		kfree(pool);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> pool;<span class="hljs-comment">//返回内存池结构体</span><br>&#125;<br>EXPORT_SYMBOL(mempool_create_node);<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaostudy/p/10161229.html">alloc_page</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://biscuitos.github.io/blog/IDA_ida_simple_get/#:~:text=ida_simple_get%28%29%20%E5%87%BD%E6%95%B0%E7%94%A8%E4%BA%8E%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%20ID%E3%80%82%20%E6%8C%87%E5%AE%9A%E8%B5%B7%E5%A7%8B%20ID%EF%BC%9B%E5%8F%82%E6%95%B0,end%20%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9D%9F%20ID%EF%BC%9B%E5%8F%82%E6%95%B0%20gfp%20%E6%8C%87%E5%90%91%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%97%B6%E7%9A%84%E6%A0%87%E5%BF%97%E3%80%82%20%E5%87%BD%E6%95%B0">ida_simple_get</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ida_simple_get(ida, start, end, gfp)    \</span><br><span class="hljs-meta">                        ida_alloc_range(ida, start, (end) - 1, gfp)</span><br></code></pre></td></tr></table></figure>

<p>ida_simple_get() 函数用于获得一个未使用的 ID。ida 参数对应 IDA；参数 start 指定起始 ID；参数 end 指定结束 ID，end为0应该就是最大值；参数 gfp 指向内存分配时的标志。函数 最终调用 ida_alloc_range() 函数进行分配。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Cqlismy/p/11507216.html#:~:text=device_initialize%20%28%29%E5%87%BD%E6%95%B0%E6%98%AF%E8%AE%BE%E5%A4%87%E5%9C%A8sysfs%E4%B8%AD%E6%B3%A8%E5%86%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%B0%86struct,device%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%88%90%E5%91%98%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%B5%8C%E7%9A%84kobject%E4%B8%8B%E7%9A%84kset%E9%85%8D%E7%BD%AE%E4%B8%BAdevices_kset%EF%BC%8C%E8%B0%83%E7%94%A8kobject_init%20%28%29%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AEdevice_ktype%E5%92%8Csysfs_ops%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E5%92%8Cdevice_release%20%28%29%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%A6%E5%A4%96%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E7%89%B9%E5%AE%9A%E8%B5%84%E6%BA%90%E9%9C%80%E8%A6%81%E7%9A%84%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82">Linux内核device结构体分析</a></p>
<p>device_initialize()函数是设备在sysfs中注册的第一个阶段，用于将struct device结构体进行初始化，主要是对结构体内的一些成员进行初始化，结构体内嵌的kobject下的kset配置为devices_kset，调用kobject_init()函数设置device_ktype和sysfs_ops结构中的两个函数和device_release()函数，另外还有一些特定资源需要的成员的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">Linux 内核的MKDEV 宏定义<br><br>定义位置：&lt;linux/cdev.h&gt;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MKDEV(major,minor) (((major) &lt;&lt; MINORBITS) | (minor))</span><br><br>宏作用： 获取设备在设备表中的位置<br><br>major 主设备号<br><br>minor 次设备号<br><br>执行成功后返回<span class="hljs-type">dev_t</span>类型的设备编号<br></code></pre></td></tr></table></figure>

<p>device_add()会在&#x2F;sys目录对应设备目录下创建uevent属性节点，应用层的udev则会根据uevent来创建&#x2F;dev目录下的设备节点，cdev_add()注册字符设备。</p>
<p>字符设备的设备号已经在nvme_core模块初始化时申请</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">result = alloc_chrdev_region(&amp;nvme_chr_devt, <span class="hljs-number">0</span>, NVME_MINORS, <span class="hljs-string">&quot;nvme&quot;</span>);<br><span class="hljs-number">3778</span>  	<span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p>nvme模块初始化负责创建字符设备</p>
<p>正常关机：</p>
<ol>
<li>Host停止提交新的I&#x2F;O命令，但允许未完成的命令继续完成；</li>
<li>Host删除所有I&#x2F;O SQ，删除所有SQ队列后，所有未完成的命令将被撤销；</li>
<li>Host删除所有I&#x2F;O CQ；</li>
<li>Host将CC.SHN置01b，表示正常关机；关机程序完成时，将CSTS.SHST置10b。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bryanwang_3099/article/details/106794149">pci_enable_device_mem</a></p>
<p>PCI&#x2F;PCIE的BAR有两种类型，memory和IO。pci_enable_device_mem()只初始化memory类型的BAR，pci_enable_device()同时初始化memory和IO类型的BAR。如果要驱动的PCI&#x2F;PCIE设备包含IO空间，那么必须使用pci_enable_device()</p>
<p> pci_set_master：</p>
<p>调用pci_set_master(pdev)函数，设置设备具有获得总线的能力，即调用这个函数，使设备具备申请使用PCI总线的能力</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1628161#:~:text=%E5%85%B6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%20dma_set_mask_and_coherent%20%28%29%20%E7%94%A8%E4%BA%8E%E5%AF%B9%20dma_mask%20%E5%92%8C,coherent_dma_mask%20%E8%B5%8B%E5%80%BC%E3%80%82%20dma_mask%20%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%98%AF%E8%AF%A5%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87DMA%E6%96%B9%E5%BC%8F%E5%8F%AF%E5%AF%BB%E5%9D%80%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4%EF%BC%8C%20coherent_dma_mask%20%E8%A1%A8%E7%A4%BA%E6%89%80%E6%9C%89%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87DMA%E6%96%B9%E5%BC%8F%E5%8F%AF%E5%AF%BB%E5%9D%80%E7%9A%84%E5%85%AC%E5%85%B1%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4%EF%BC%8C%20%E5%9B%A0%E4%B8%BA%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E9%83%BD%E8%83%BD%E5%A4%9F%E6%94%AF%E6%8C%8164bit%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AE%BD%E5%BA%A6%E3%80%82">dma_set_mask_and_coherent</a></p>
<p>函数<code>dma_set_mask_and_coherent()</code>用于对<code>dma_mask</code>和<code>coherent_dma_mask</code>赋值。</p>
<p><code>dma_mask</code>表示的是该设备通过DMA方式可寻址的物理地址范围，<code>coherent_dma_mask</code>表示所有设备通过DMA方式可寻址的公共的物理地址范围，</p>
<p>因为不是所有的硬件设备都能够支持64bit的地址宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Set both the DMA mask and the coherent DMA mask to the same thing.</span><br><span class="hljs-comment"> * Note that we don&#x27;t check the return value from dma_set_coherent_mask()</span><br><span class="hljs-comment"> * as the DMA API guarantees that the coherent DMA mask can be set to</span><br><span class="hljs-comment"> * the same or smaller than the streaming DMA mask.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_mask_and_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span><br>&#123;<br>    <span class="hljs-type">int</span> rc = dma_set_mask(dev, mask);<br>    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>        dma_set_coherent_mask(dev, mask);<br>    <span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>rc&#x3D;&#x3D;0表示该设备的<code>dma_mask</code>赋值成功，所以可以接着对<code>coherent_dma_mask</code>赋同样的值。</p>
<p>控制寄存器：</p>
<p><img src="https://img-blog.csdn.net/20160604114927706" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdn.net/20160604114927706"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yhb1047818384/article/details/106676560">MSI&#x2F;MSI-x中断</a></p>
<p>传统中断在系统初始化扫描PCI bus tree时就已自动为设备分配好中断号, 但是如果设备需要使用MSI，驱动需要进行一些额外的配置。<br>当前linux内核提供pci_alloc_irq_vectors来进行MSI&#x2F;MSI-X capablity的初始化配置以及中断号分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pci_alloc_irq_vectors</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> min_vecs,</span><br><span class="hljs-params">                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_vecs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>;<br><br>函数的返回值为该PCI设备分配的中断向量个数。<br>min_vecs是设备对中断向量数目的最小要求，如果小于该值，会返回错误。<br>max_vecs是期望分配的中断向量最大个数。<br>flags用于区分设备和驱动能够使用的中断类型<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PCI_IRQ_LEGACY		(1 &lt;&lt; 0) <span class="hljs-comment">/* Allow legacy interrupts */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PCI_IRQ_MSI		(1 &lt;&lt; 1) <span class="hljs-comment">/* Allow MSI interrupts */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PCI_IRQ_MSIX		(1 &lt;&lt; 2) <span class="hljs-comment">/* Allow MSI-X interrupts */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PCI_IRQ_ALL_TYPES   (PCI_IRQ_LEGACY | PCI_IRQ_MSI | PCI_IRQ_MSIX)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> __u64 <span class="hljs-title function_">lo_hi_readq</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span><br>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> u32 __iomem *p = addr;<br>	u32 low, high;<br><br>	low = readl(p);<br>	high = readl(p + <span class="hljs-number">1</span>);<br><br>	<span class="hljs-keyword">return</span> low + ((u64)high &lt;&lt; <span class="hljs-number">32</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lo_hi_writeq</span><span class="hljs-params">(__u64 val, <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span><br>&#123;<br>	writel(val, addr);<br>	writel(val &gt;&gt; <span class="hljs-number">32</span>, addr + <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TV8MbnO2Y2RfU/article/details/78103780">CMB</a></p>
<p> 但是如果CPU将整条指令而不是指针直接写到SSD端的DRAM的话，并不耗费太多资源，此时能够节省一次PCIE往返及一次SSD控制器内部的中断处理。于是，人们就想将SSD控制器上的一小段DRAM空间映射到host物理地址空间从而可以让驱动直接写指令进去，甚至写一些数据进去也是可以的。这块被映射到host物理地址空间的DRAM空间便被称为CMB了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/student456852/article/details/116868447">ioremap_wc</a></p>
<p>ioremap_wc用来映射memory type为<strong>normal memory</strong>的设备，同时不使用cache</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qb_2008/article/details/6846412">sysfs API总结</a></p>
<p>sysfs_add_file_to_group()将一个属性attr加入kobj目录下已存在的的属性集合group。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiao_zz/article/details/53287749">PCI驱动使用函数</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pci_enable_pcie_error_reporting</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *dev)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">pci_enable_pcie_error_reporting enables the device to send error messages to root port when an error is detected. Note that devices don’t enable the error reporting by default, so device drivers need call this function to enable it.</span><br><span class="hljs-comment">*/</span><br><br><br>The <span class="hljs-title function_">pci_save_state</span><span class="hljs-params">()</span> and <span class="hljs-title function_">pci_restore_state</span><span class="hljs-params">()</span> functions can be used by a device driver to save and restore standard PCI config registers.  The <span class="hljs-title function_">pci_save_state</span><span class="hljs-params">()</span> function must be invoked <span class="hljs-keyword">while</span> the device has valid state before <span class="hljs-title function_">pci_restore_state</span><span class="hljs-params">()</span> can be used.  If the device is not in the fully-powered <span class="hljs-title function_">state</span> <span class="hljs-params">(PCI_POWERSTATE_D0)</span> when <span class="hljs-title function_">pci_restore_state</span><span class="hljs-params">()</span> is  invoked, then the device will be transitioned to PCI_POWERSTATE_D0 before any config registers are restored.<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lialong1st/p/7756675.html">readl</a></p>
<p>byte word long</p>
<p>readb readw readl：从虚拟地址读取1 2 4字节数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">writel</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> data, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr)</span>;<br></code></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">result = nvme_alloc_queue(dev, <span class="hljs-number">0</span>, NVME_AQ_DEPTH); <span class="hljs-comment">//为admin queue申请空间</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sky-heaven/p/9579742.html">dma_zalloc_coherent</a></p>
<p>dma_alloc_coherent() – 获取物理页，并将该物理页的总线地址保存于dma_handle，返回该物理页的虚拟地址</p>
<p>DMA映射建立了一个新的结构类型———dma_addr_t来表示总线地址。dma_addr_t类型的变量对驱动程序是不透明的；唯一允许的操作是将它们传递给DMA支持例程以及设备本身。作为一个总线地址，如果CPU直接使用了dma_addr_t，将会导致发生不可预期的后果！</p>
<p>一致性DMA映射存在与驱动程序的生命周期中，它的缓冲区必须可同时被CPU和外围设备访问！因此一致性映射必须保存在一致性缓存中。建立和使用一致性映射的开销是很大的！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">dma_alloc_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev,    <span class="hljs-type">size_t</span> size, <span class="hljs-type">dma_addr_t</span>  *dma_handle, <span class="hljs-type">gfp_t</span> gfp)</span><br></code></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ctrl_ops</span> <span class="hljs-title">nvme_pci_ctrl_ops</span> =</span> &#123;<br>	.name			= <span class="hljs-string">&quot;pcie&quot;</span>,<br>	.module			= THIS_MODULE,<br>	.flags			= NVME_F_METADATA_SUPPORTED,<br>	.reg_read32		= nvme_pci_reg_read32,<br>	.reg_write32		= nvme_pci_reg_write32,<br>	.reg_read64		= nvme_pci_reg_read64,<br>	.free_ctrl		= nvme_pci_free_ctrl,<br>	.submit_async_event	= nvme_pci_submit_async_event,<br>	.get_address		= nvme_pci_get_address,<br>&#125;;<br>ctrl-&gt;ops-&gt;reg_write32等价于nvme_pci_reg_write32<br></code></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c">blk_mq_alloc_tag_set: Alloc a tag <span class="hljs-built_in">set</span> to be associated with one or more request queues<br><span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_mq_init_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> blk_mq_init_queue_data(<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> request_queue *<span class="hljs-title function_">blk_mq_init_queue_data</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">		<span class="hljs-type">void</span> *queuedata)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span>;</span><br>	<span class="hljs-type">int</span> ret;<br><br>	q = blk_alloc_queue(<span class="hljs-built_in">set</span>-&gt;numa_node);<br>	<span class="hljs-keyword">if</span> (!q)<br>		<span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br>	q-&gt;queuedata = queuedata;<br>	ret = blk_mq_init_allocated_queue(<span class="hljs-built_in">set</span>, q);<br>	<span class="hljs-keyword">if</span> (ret) &#123;<br>		blk_cleanup_queue(q);<br>		<span class="hljs-keyword">return</span> ERR_PTR(ret);<br>	&#125;<br>	<span class="hljs-keyword">return</span> q;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">blk_mq_init_allocated_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>,</span><br><span class="hljs-params">		<span class="hljs-keyword">struct</span> request_queue *q)</span><br>&#123;<br>	<span class="hljs-comment">/* mark the queue as mq asap */</span><br>	q-&gt;mq_ops = <span class="hljs-built_in">set</span>-&gt;ops;<br><br>	q-&gt;poll_cb = blk_stat_alloc_callback(blk_mq_poll_stats_fn,<br>					     blk_mq_poll_stats_bkt,<br>					     BLK_MQ_POLL_STATS_BKTS, q);<br>	<span class="hljs-keyword">if</span> (!q-&gt;poll_cb)<br>		<span class="hljs-keyword">goto</span> err_exit;<br><br>	<span class="hljs-keyword">if</span> (blk_mq_alloc_ctxs(q))<br>		<span class="hljs-keyword">goto</span> err_poll;<br><br>	<span class="hljs-comment">/* init q-&gt;mq_kobj and sw queues&#x27; kobjects */</span><br>	blk_mq_sysfs_init(q);<br><br>	INIT_LIST_HEAD(&amp;q-&gt;unused_hctx_list);<br>	spin_lock_init(&amp;q-&gt;unused_hctx_lock);<br><br>	blk_mq_realloc_hw_ctxs(<span class="hljs-built_in">set</span>, q);<br>	<span class="hljs-keyword">if</span> (!q-&gt;nr_hw_queues)<br>		<span class="hljs-keyword">goto</span> err_hctxs;<br><br>	INIT_WORK(&amp;q-&gt;timeout_work, blk_mq_timeout_work);<br>	blk_queue_rq_timeout(q, <span class="hljs-built_in">set</span>-&gt;timeout ? <span class="hljs-built_in">set</span>-&gt;timeout : <span class="hljs-number">30</span> * HZ);<br><br>	q-&gt;tag_set = <span class="hljs-built_in">set</span>;<br><br>	q-&gt;queue_flags |= QUEUE_FLAG_MQ_DEFAULT;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">set</span>-&gt;nr_maps &gt; HCTX_TYPE_POLL &amp;&amp;<br>	    <span class="hljs-built_in">set</span>-&gt;<span class="hljs-built_in">map</span>[HCTX_TYPE_POLL].nr_queues)<br>		blk_queue_flag_set(QUEUE_FLAG_POLL, q);<br><br>	q-&gt;sg_reserved_size = INT_MAX;<br><br>	INIT_DELAYED_WORK(&amp;q-&gt;requeue_work, blk_mq_requeue_work);<br>	INIT_LIST_HEAD(&amp;q-&gt;requeue_list);<br>	spin_lock_init(&amp;q-&gt;requeue_lock);<br><br>	q-&gt;nr_requests = <span class="hljs-built_in">set</span>-&gt;queue_depth;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Default to classic polling</span><br><span class="hljs-comment">	 */</span><br>	q-&gt;poll_nsec = BLK_MQ_POLL_CLASSIC;<br><br>	blk_mq_init_cpu_queues(q, <span class="hljs-built_in">set</span>-&gt;nr_hw_queues);<br>	blk_mq_add_queue_tag_set(<span class="hljs-built_in">set</span>, q);<br>	blk_mq_map_swqueue(q);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err_hctxs:<br>	kfree(q-&gt;queue_hw_ctx);<br>	q-&gt;nr_hw_queues = <span class="hljs-number">0</span>;<br>	blk_mq_sysfs_deinit(q);<br>err_poll:<br>	blk_stat_free_callback(q-&gt;poll_cb);<br>	q-&gt;poll_cb = <span class="hljs-literal">NULL</span>;<br>err_exit:<br>	q-&gt;mq_ops = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><span class="hljs-comment">// q-&gt;mq_ops = set-&gt;ops; 请求队列继承tag_set的操作符集合</span><br></code></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu_to_le32<br>le32_to_cpu  cpu&lt;---&gt;小端<span class="hljs-number">32</span>位数（little endian）<br>cpu_to_be32 <br>be32_to_cpu  cpu&lt;---&gt;大端<span class="hljs-number">32</span>位数（big endian）<br></code></pre></td></tr></table></figure>



<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>字符设备操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">nvme_dev_fops</span> =</span> &#123;<br>	.owner		= THIS_MODULE,<br>	.open		= nvme_dev_open,<br>	.unlocked_ioctl	= nvme_dev_ioctl,<br>	.compat_ioctl	= nvme_dev_ioctl,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>块设备操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device_operations</span> <span class="hljs-title">nvme_fops</span> =</span> &#123;<br>	.owner		= THIS_MODULE,<br>	.ioctl		= nvme_ioctl,<br>	.compat_ioctl	= nvme_ioctl,<br>	.open		= nvme_open,<br>	.release	= nvme_release,<br>	.getgeo		= nvme_getgeo,<br>	.revalidate_disk= nvme_revalidate_disk,<br>	.pr_ops		= &amp;nvme_pr_ops,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>请求队列操作函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span> <span class="hljs-title">nvme_mq_admin_ops</span> =</span> &#123;<br>	.queue_rq	= nvme_queue_rq,<br>	.complete	= nvme_pci_complete_rq,<br>	.init_hctx	= nvme_admin_init_hctx,<br>	.exit_hctx      = nvme_admin_exit_hctx,<br>	.init_request	= nvme_init_request,<br>	.timeout	= nvme_timeout,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span> <span class="hljs-title">nvme_mq_ops</span> =</span> &#123;<br>	.queue_rq	= nvme_queue_rq,<br>	.complete	= nvme_pci_complete_rq,<br>	.init_hctx	= nvme_init_hctx,<br>	.init_request	= nvme_init_request,<br>	.map_queues	= nvme_pci_map_queues,<br>	.timeout	= nvme_timeout,<br>	.poll		= nvme_poll,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>struct pci_driver</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> <span class="hljs-title">nvme_driver</span> =</span> &#123;<br>	.name		= <span class="hljs-string">&quot;nvme&quot;</span>,<br>	.id_table	= nvme_id_table,<br>	.probe		= nvme_probe,<br>	.remove		= nvme_remove,<br>	.shutdown	= nvme_shutdown,<br>	.driver		= &#123;<br>		.pm	= &amp;nvme_dev_pm_ops,<br>	&#125;,<br>	.sriov_configure = pci_sriov_configure_simple,<br>	.err_handler	= &amp;nvme_err_handler,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>id_tables</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> <span class="hljs-title">nvme_id_table</span>[] =</span> &#123;<br>	&#123; PCI_VDEVICE(INTEL, <span class="hljs-number">0x0953</span>),<br>		.driver_data = NVME_QUIRK_STRIPE_SIZE |<br>				NVME_QUIRK_DEALLOCATE_ZEROES, &#125;,<br>	&#123; PCI_VDEVICE(INTEL, <span class="hljs-number">0x0a53</span>),<br>		.driver_data = NVME_QUIRK_STRIPE_SIZE |<br>				NVME_QUIRK_DEALLOCATE_ZEROES, &#125;,<br>	&#123; PCI_VDEVICE(INTEL, <span class="hljs-number">0x0a54</span>),<br>		.driver_data = NVME_QUIRK_STRIPE_SIZE |<br>				NVME_QUIRK_DEALLOCATE_ZEROES, &#125;,<br>	&#123; PCI_VDEVICE(INTEL, <span class="hljs-number">0x0a55</span>),<br>		.driver_data = NVME_QUIRK_STRIPE_SIZE |<br>				NVME_QUIRK_DEALLOCATE_ZEROES, &#125;,<br>	&#123; PCI_VDEVICE(INTEL, <span class="hljs-number">0xf1a5</span>),	<span class="hljs-comment">/* Intel 600P/P3100 */</span><br>		.driver_data = NVME_QUIRK_NO_DEEPEST_PS |<br>				NVME_QUIRK_MEDIUM_PRIO_SQ &#125;,<br>	&#123; PCI_VDEVICE(INTEL, <span class="hljs-number">0x5845</span>),	<span class="hljs-comment">/* Qemu emulated controller */</span><br>		.driver_data = NVME_QUIRK_IDENTIFY_CNS, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x1bb1</span>, <span class="hljs-number">0x0100</span>),   <span class="hljs-comment">/* Seagate Nytro Flash Storage */</span><br>		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x1c58</span>, <span class="hljs-number">0x0003</span>),	<span class="hljs-comment">/* HGST adapter */</span><br>		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x1c58</span>, <span class="hljs-number">0x0023</span>),	<span class="hljs-comment">/* WDC SN200 adapter */</span><br>		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x1c5f</span>, <span class="hljs-number">0x0540</span>),	<span class="hljs-comment">/* Memblaze Pblaze4 adapter */</span><br>		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x144d</span>, <span class="hljs-number">0xa821</span>),   <span class="hljs-comment">/* Samsung PM1725 */</span><br>		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x144d</span>, <span class="hljs-number">0xa822</span>),   <span class="hljs-comment">/* Samsung PM1725a */</span><br>		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x1d1d</span>, <span class="hljs-number">0x1f1f</span>),	<span class="hljs-comment">/* LighNVM qemu device */</span><br>		.driver_data = NVME_QUIRK_LIGHTNVM, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x1d1d</span>, <span class="hljs-number">0x2807</span>),	<span class="hljs-comment">/* CNEX WL */</span><br>		.driver_data = NVME_QUIRK_LIGHTNVM, &#125;,<br>	&#123; PCI_DEVICE(<span class="hljs-number">0x1d1d</span>, <span class="hljs-number">0x2601</span>),	<span class="hljs-comment">/* CNEX Granby */</span><br>		.driver_data = NVME_QUIRK_LIGHTNVM, &#125;,<br>	&#123; PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_EXPRESS, <span class="hljs-number">0xffffff</span>) &#125;,<br>	&#123; PCI_DEVICE(PCI_VENDOR_ID_APPLE, <span class="hljs-number">0x2001</span>) &#125;,<br>	&#123; PCI_DEVICE(PCI_VENDOR_ID_APPLE, <span class="hljs-number">0x2003</span>) &#125;,<br>	&#123; <span class="hljs-number">0</span>, &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>nvme_pci_ctrl_ops</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ctrl_ops</span> <span class="hljs-title">nvme_pci_ctrl_ops</span> =</span> &#123;<br>	.name			= <span class="hljs-string">&quot;pcie&quot;</span>,<br>	.module			= THIS_MODULE,<br>	.flags			= NVME_F_METADATA_SUPPORTED,<br>	.reg_read32		= nvme_pci_reg_read32,<br>	.reg_write32		= nvme_pci_reg_write32,<br>	.reg_read64		= nvme_pci_reg_read64,<br>	.free_ctrl		= nvme_pci_free_ctrl,<br>	.submit_async_event	= nvme_pci_submit_async_event,<br>	.get_address		= nvme_pci_get_address,<br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>请求队列处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * <span class="hljs-doctag">NOTE:</span> ns is NULL when called on the admin queue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">blk_status_t</span> <span class="hljs-title function_">nvme_queue_rq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *hctx,</span><br><span class="hljs-params">			 <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> blk_mq_queue_data *bd)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ns</span> *<span class="hljs-title">ns</span> =</span> hctx-&gt;<span class="hljs-built_in">queue</span>-&gt;queuedata;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">nvmeq</span> =</span> hctx-&gt;driver_data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_dev</span> *<span class="hljs-title">dev</span> =</span> nvmeq-&gt;dev;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">req</span> =</span> bd-&gt;rq;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_command</span> <span class="hljs-title">cmnd</span>;</span><br>	<span class="hljs-type">blk_status_t</span> ret;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * We should not need to do this, but we&#x27;re still using this to</span><br><span class="hljs-comment">	 * ensure we can drain requests on a dying queue.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (unlikely(nvmeq-&gt;cq_vector &lt; <span class="hljs-number">0</span>))<br>		<span class="hljs-keyword">return</span> BLK_STS_IOERR;<br><br>	ret = nvme_setup_cmd(ns, req, &amp;cmnd);<br>	<span class="hljs-keyword">if</span> (ret)<br>		<span class="hljs-keyword">return</span> ret;<br><br>	ret = nvme_init_iod(req, dev);<br>	<span class="hljs-keyword">if</span> (ret)<br>		<span class="hljs-keyword">goto</span> out_free_cmd;<br><br>	<span class="hljs-keyword">if</span> (blk_rq_nr_phys_segments(req)) &#123;<br>		ret = nvme_map_data(dev, req, &amp;cmnd);<br>		<span class="hljs-keyword">if</span> (ret)<br>			<span class="hljs-keyword">goto</span> out_cleanup_iod;<br>	&#125;<br><br>	blk_mq_start_request(req);<br>	nvme_submit_cmd(nvmeq, &amp;cmnd);<br>	<span class="hljs-keyword">return</span> BLK_STS_OK;<br>out_cleanup_iod:<br>	nvme_free_iod(dev, req);<br>out_free_cmd:<br>	nvme_cleanup_cmd(req);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">nvme_complete_rq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req)</span><br>&#123;<br>	<span class="hljs-type">blk_status_t</span> status = nvme_error_status(req);<br><br>	trace_nvme_complete_rq(req);<br><br>	<span class="hljs-keyword">if</span> (unlikely(status != BLK_STS_OK &amp;&amp; nvme_req_needs_retry(req))) &#123;<br>		<span class="hljs-keyword">if</span> ((req-&gt;cmd_flags &amp; REQ_NVME_MPATH) &amp;&amp;<br>		    blk_path_error(status)) &#123;<br>			nvme_failover_req(req);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (!blk_queue_dying(req-&gt;q)) &#123;<br>			nvme_req(req)-&gt;retries++;<br>			blk_mq_requeue_request(req, <span class="hljs-literal">true</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>	&#125;<br>	blk_mq_end_request(req, status);<br>&#125;<br>EXPORT_SYMBOL_GPL(nvme_complete_rq);<br></code></pre></td></tr></table></figure>

<p>中断处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">nvme_irq</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">nvmeq</span> =</span> data;<br>	<span class="hljs-type">irqreturn_t</span> ret = IRQ_NONE;<br>	u16 start, end;<br><br>	spin_lock(&amp;nvmeq-&gt;cq_lock);<br>	<span class="hljs-keyword">if</span> (nvmeq-&gt;cq_head != nvmeq-&gt;last_cq_head)<br>		ret = IRQ_HANDLED;<br>	nvme_process_cq(nvmeq, &amp;start, &amp;end, <span class="hljs-number">-1</span>);<br>	nvmeq-&gt;last_cq_head = nvmeq-&gt;cq_head;<br>	spin_unlock(&amp;nvmeq-&gt;cq_lock);<br><br>	<span class="hljs-keyword">if</span> (start != end) &#123;<br>		nvme_complete_cqes(nvmeq, start, end);<br>		<span class="hljs-keyword">return</span> IRQ_HANDLED;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>blk_mq_rq_from_pdu与blk_mq_rq_to_pdu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * blk_mq_rq_from_pdu - cast a PDU to a request</span><br><span class="hljs-comment"> * @pdu: the PDU (Protocol Data Unit) to be casted</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: request</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Driver command data is immediately after the request. So subtract request</span><br><span class="hljs-comment"> * size to get back to the original request.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> request *<span class="hljs-title function_">blk_mq_rq_from_pdu</span><span class="hljs-params">(<span class="hljs-type">void</span> *pdu)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> pdu - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> request);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * blk_mq_rq_to_pdu - cast a request to a PDU</span><br><span class="hljs-comment"> * @rq: the request to be casted</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: pointer to the PDU</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Driver command data is immediately after the request. So add request to get</span><br><span class="hljs-comment"> * the PDU.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">blk_mq_rq_to_pdu</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *rq)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> rq + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p><strong>pci_device_id</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> &#123;</span><br>	__u32 vendor, device;		<span class="hljs-comment">/* 厂商和设备ID，Vendor and device ID or PCI_ANY_ID*/</span><br>	__u32 subvendor, subdevice;	<span class="hljs-comment">/* 子系统和设备ID，Subsystem ID&#x27;s or PCI_ANY_ID */</span><br>	__u32 <span class="hljs-class"><span class="hljs-keyword">class</span>, <span class="hljs-title">class_mask</span>;</span>	<span class="hljs-comment">/* 类、子类、prog-if三元组，(class,subclass,prog-if) triplet */</span><br>	<span class="hljs-type">kernel_ulong_t</span> driver_data;	<span class="hljs-comment">/* 驱动私有数据，Data private to the driver */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>



<p><strong>pci_dev</strong></p>
<p>每种类的PCI设备都可以用结构类型pci_dev来描述。更为准确地说，应该是每一个PCI功能，即PCI逻辑设备都唯一地对应有一个pci_dev设备描述符。该数据结构的定义如下（include&#x2F;linux&#x2F;pci.h）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">global_list</span>;</span><br><br><span class="hljs-comment">/* 全局链表元素global_list：每一个pci_dev结构都通过该成员连接到全局pci设备链表pci_devices中*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">bus_list</span>;</span><br><br> <span class="hljs-comment">/* 总线设备链表元素bus_list：每一个pci_dev结构除了链接到全局设备链表中外，还会通过这个成员连接到其所属PCI总线的设备链表中。每一条PCI总线都维护一条它自己的设备链表视图，以便描述所有连接在该PCI总线上的设备，其表头由PCI总线的pci_bus结构中的 devices成员所描述t*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_bus</span> *<span class="hljs-title">bus</span>;</span><br><br><span class="hljs-comment">/* 总线指针bus：指向这个PCI设备所在的PCI总线的pci_bus结构。因此，对于桥设备而言，bus指针将指向桥设备的主总线（primary bus），也即指向桥设备所在的PCI总线*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_bus</span> *<span class="hljs-title">subordinate</span>;</span><br><br><span class="hljs-comment">/* 指针subordinate：指向这个PCI设备所桥接的下级总线。这个指针成员仅对桥设备才有意义，而对于一般的非桥PCI设备而言，该指针成员总是为NULL*/</span><br><span class="hljs-type">void</span> *sysdata;<br><br><span class="hljs-comment">/* 无类型指针sysdata：指向一片特定于系统的扩展数据*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_dir_entry</span> *<span class="hljs-title">procent</span>;</span><br><br><span class="hljs-comment">/* 指针procent：指向该PCI设备在／proc文件系统中对应的目录项*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> devfn;<br><br><span class="hljs-comment">/* devfn：这个PCI设备的设备功能号，也成为PCI逻辑设备号（0－255）。其中bit[7:3]是物理设备号（取值范围0－31），bit[2:0]是功能号（取值范围0－7）。 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> vendor;<br><br><br><span class="hljs-comment">/* vendor：这是一个16无符号整数，表示PCI设备的厂商ID*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> device;<br><br><br><span class="hljs-comment">/*device：这是一个16无符号整数，表示PCI设备的设备ID */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> subsystem_vendor;<br><br><span class="hljs-comment">/* subsystem_vendor：这是一个16无符号整数，表示PCI设备的子系统厂商ID*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> subsystem_device;<br><br><span class="hljs-comment">/* subsystem_device：这是一个16无符号整数，表示PCI设备的子系统设备ID。*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br><br><span class="hljs-comment">/* class：32位的无符号整数，表示该PCI设备的类别，其中，bit［7：0］为编程接口，bit［15：8］为子类别代码，bit ［23：16］为基类别代码，bit［31：24］无意义。显然，class成员的低3字节刚好对应与PCI配置空间中的类代码*/</span><br>u8 hdr_type;<br><br><span class="hljs-comment">/* hdr_type：8位符号整数，表示PCI配置空间头部的类型。其中，bit［7］＝1表示这是一个多功能设备，bit［7］＝0表示这是一个单功能设备。Bit［6：0］则表示PCI配置空间头部的布局类型，值00h表示这是一个一般PCI设备的配置空间头部，值01h表示这是一个PCI-to-PCI桥的配置空间头部，值02h表示CardBus桥的配置空间头部*/</span><br>u8 rom_base_reg;<br><br><span class="hljs-comment">/* rom_base_reg：8位无符号整数，表示PCI配置空间中的ROM基地址寄存器在PCI配置空间中的位置。ROM基地址寄存器在不同类型的PCI配置空间头部的位置是不一样的，对于type 0的配置空间布局，ROM基地址寄存器的起始位置是30h，而对于PCI-to-PCI桥所用的type 1配置空间布局，ROM基地址寄存器的起始位置是38h*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> *<span class="hljs-title">driver</span>;</span><br><br><span class="hljs-comment">/* 指针driver：指向这个PCI设备所对应的驱动程序定义的pci_driver结构。每一个pci设备驱动程序都必须定义它自己的pci_driver结构来描述它自己。*/</span><br>u64 dma_mask;<br><br><span class="hljs-comment">/*dma_mask：用于DMA的总线地址掩码，一般来说，这个成员的值是0xffffffff。数据类型dma_addr_t定义在include/asm/types.h中，在x86平台上，dma_addr_t类型就是u32类型*/</span><br><br><span class="hljs-type">pci_power_t</span>  current_state;<br><br> <span class="hljs-comment">/* 当前操作状态 */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> <span class="hljs-title">dev</span>;</span><br><br><span class="hljs-comment">/* 通用的设备接口*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> vendor_compatible[DEVICE_COUNT_COMPATIBLE];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> device_compatible[DEVICE_COUNT_COMPATIBLE];<br><span class="hljs-comment">/*定义这个PCI设备与哪些设备相兼容!/</span><br><span class="hljs-comment">unsigned int irq;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/* 无符号的整数irq：表示这个PCI设备通过哪根IRQ输入线产生中断，一般为0－15之间的某个值 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">resource</span>[<span class="hljs-title">DEVICE_COUNT_RESOURCE</span>];</span><br><br><span class="hljs-comment">/*表示该设备可能用到的资源，包括：I/O断口区域、设备内存地址区域以及扩展ROM地址区域。*/</span><br><span class="hljs-type">int</span> cfg_size;<br><br><span class="hljs-comment">/* 配置空间的大小 */</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> transparent:<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* 透明 PCI 桥 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> multifunction:<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* 多功能设备*/</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_enabled:<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* pci_enable_device已经被调用*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> is_busmaster:<span class="hljs-number">1</span>;<br><br> <span class="hljs-comment">/* 设备是主设备*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> no_msi:<span class="hljs-number">1</span>;<br><br> <span class="hljs-comment">/* 设备不使用msi*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block_ucfg_access:<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/* 配置空间访问形式用块的形式 */</span><br>u32 saved_config_space[<span class="hljs-number">16</span>];<br><br><span class="hljs-comment">/* 在挂起时保存配置空间*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> *<span class="hljs-title">rom_attr</span>;</span><br><br><span class="hljs-comment">/* sysfs ROM入口的属性描述*/</span><br><span class="hljs-type">int</span> rom_attr_enabled;<br><br><span class="hljs-comment">/* 能显示rom 属性*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bin_attribute</span> *<span class="hljs-title">res_attr</span>[<span class="hljs-title">DEVICE_COUNT_RESOURCE</span>];</span><br><br> <span class="hljs-comment">/* 资源的sysfs文件*/</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>nvme_dev</strong></p>
<p>内核使用一个nvme_dev结构体来描述一个nvme设备, 一个nvme设备对应一个nvme_dev</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Represents an NVM Express device.  Each nvme_dev is a PCI function.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_dev</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">queues</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_tag_set</span> <span class="hljs-title">tagset</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_tag_set</span> <span class="hljs-title">admin_tagset</span>;</span><br>	u32 __iomem *dbs;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_pool</span> *<span class="hljs-title">prp_page_pool</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_pool</span> *<span class="hljs-title">prp_small_pool</span>;</span><br>	<span class="hljs-type">unsigned</span> online_queues;<br>	<span class="hljs-type">unsigned</span> max_qid;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_vecs;<br>	<span class="hljs-type">int</span> q_depth;<br>	u32 db_stride;<br>	<span class="hljs-type">void</span> __iomem *bar;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bar_mapped_size;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">remove_work</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">shutdown_lock</span>;</span><br>	<span class="hljs-type">bool</span> subsystem;<br>	<span class="hljs-type">void</span> __iomem *cmb;<br>	<span class="hljs-type">pci_bus_addr_t</span> cmb_bus_addr;<br>	u64 cmb_size;<br>	u32 cmbsz;<br>	u32 cmbloc;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ctrl</span> <span class="hljs-title">ctrl</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> <span class="hljs-title">ioq_wait</span>;</span><br><br>	<span class="hljs-type">mempool_t</span> *iod_mempool;<br><br>	<span class="hljs-comment">/* shadow doorbell buffer support: */</span><br>	u32 *dbbuf_dbs;<br>	<span class="hljs-type">dma_addr_t</span> dbbuf_dbs_dma_addr;<br>	u32 *dbbuf_eis;<br>	<span class="hljs-type">dma_addr_t</span> dbbuf_eis_dma_addr;<br><br>	<span class="hljs-comment">/* host memory buffer support: */</span><br>	u64 host_mem_size;<br>	u32 nr_host_mem_descs;<br>	<span class="hljs-type">dma_addr_t</span> host_mem_descs_dma;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_host_mem_buf_desc</span> *<span class="hljs-title">host_mem_descs</span>;</span><br>	<span class="hljs-type">void</span> **host_mem_desc_bufs;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p><strong>nvme_ctrl_ops</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ctrl_ops</span> &#123;</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">module</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_F_FABRICS			(1 &lt;&lt; 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_F_METADATA_SUPPORTED	(1 &lt;&lt; 1)</span><br>	<span class="hljs-type">int</span> (*reg_read32)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, u32 off, u32 *val);<br>	<span class="hljs-type">int</span> (*reg_write32)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, u32 off, u32 val);<br>	<span class="hljs-type">int</span> (*reg_read64)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, u32 off, u64 *val);<br>	<span class="hljs-type">void</span> (*free_ctrl)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl);<br>	<span class="hljs-type">void</span> (*submit_async_event)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl);<br>	<span class="hljs-type">void</span> (*delete_ctrl)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl);<br>	<span class="hljs-type">int</span> (*get_address)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> size);<br>	<span class="hljs-type">void</span> (*stop_ctrl)(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>enum nvme_ctrl_state</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">nvme_ctrl_state</span> &#123;</span><br>	NVME_CTRL_NEW,<br>	NVME_CTRL_LIVE,<br>	NVME_CTRL_ADMIN_ONLY,    <span class="hljs-comment">/* Only admin queue live */</span><br>	NVME_CTRL_RESETTING,<br>	NVME_CTRL_CONNECTING,<br>	NVME_CTRL_DELETING,<br>	NVME_CTRL_DEAD,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>struct blk_mq_tag_set</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_tag_set</span> &#123;</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * map[] holds ctx -&gt; hctx mappings, one map exists for each type</span><br><span class="hljs-comment">	 * that the driver wishes to support. There are no restrictions</span><br><span class="hljs-comment">	 * on maps being of the same size, and it&#x27;s perfectly legal to</span><br><span class="hljs-comment">	 * share maps between types.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_queue_map</span>	<span class="hljs-title">map</span>[<span class="hljs-title">HCTX_MAX_TYPES</span>];</span>        <span class="hljs-comment">//软硬件队列映射表</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		nr_maps;	<span class="hljs-comment">/* nr entries in map[] */</span>    <span class="hljs-comment">//映射表数量</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span>	*<span class="hljs-title">ops</span>;</span>        <span class="hljs-comment">//驱动实现的操作集合，会被request_queue继承</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		nr_hw_queues;	<span class="hljs-comment">/* nr hw queues across maps */</span>    <span class="hljs-comment">//硬件队列数量</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		queue_depth;	<span class="hljs-comment">/* max hw supported */</span>       <span class="hljs-comment">//硬件队列深度</span><br>    ...<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_tags</span>	**<span class="hljs-title">tags</span>;</span>           <span class="hljs-comment">//为每个硬件队列分配一个rq集合</span><br> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>		<span class="hljs-title">tag_list_lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">tag_list</span>;</span>        <span class="hljs-comment">//使用该tag_set的request_queue 链表</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>struct request_queue</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span>		*<span class="hljs-title">last_merge</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elevator_queue</span>	*<span class="hljs-title">elevator</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">percpu_ref</span>	<span class="hljs-title">q_usage_counter</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_queue_stats</span>	*<span class="hljs-title">stats</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq_qos</span>		*<span class="hljs-title">rq_qos</span>;</span><br><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span>	*<span class="hljs-title">mq_ops</span>;</span><br><br>	<span class="hljs-comment">/* sw queues */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ctx</span> __<span class="hljs-title">percpu</span>	*<span class="hljs-title">queue_ctx</span>;</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		queue_depth;<br><br>	<span class="hljs-comment">/* hw dispatch queues */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_hw_ctx</span>	**<span class="hljs-title">queue_hw_ctx</span>;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		nr_hw_queues;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">backing_dev_info</span>	*<span class="hljs-title">backing_dev_info</span>;</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The queue owner gets to use this for whatever they like.</span><br><span class="hljs-comment">	 * ll_rw_blk doesn&#x27;t touch it.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span>			*queuedata;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * various queue flags, see QUEUE_* below</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		queue_flags;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Number of contexts that have called blk_set_pm_only(). If this</span><br><span class="hljs-comment">	 * counter is above zero then only RQF_PM requests are processed.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">atomic_t</span>		pm_only;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * ida allocated id for this queue.  Used to index queues from</span><br><span class="hljs-comment">	 * ioctx.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span>			id;<br><br>	<span class="hljs-type">spinlock_t</span>		queue_lock;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * queue kobject</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * mq queue kobject</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">mq_kobj</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  CONFIG_BLK_DEV_INTEGRITY</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_integrity</span> <span class="hljs-title">integrity</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>	<span class="hljs-comment">/* CONFIG_BLK_DEV_INTEGRITY */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PM</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>		*<span class="hljs-title">dev</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">rpm_status</span>		<span class="hljs-title">rpm_status</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * queue settings</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		nr_requests;	<span class="hljs-comment">/* Max # of requests */</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		dma_pad_mask;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		dma_alignment;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_INLINE_ENCRYPTION</span><br>	<span class="hljs-comment">/* Inline crypto capabilities */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_keyslot_manager</span> *<span class="hljs-title">ksm</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		rq_timeout;<br>	<span class="hljs-type">int</span>			poll_nsec;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_stat_callback</span>	*<span class="hljs-title">poll_cb</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_rq_stat</span>	<span class="hljs-title">poll_stat</span>[<span class="hljs-title">BLK_MQ_POLL_STATS_BKTS</span>];</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span>	<span class="hljs-title">timeout</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span>	<span class="hljs-title">timeout_work</span>;</span><br><br>	<span class="hljs-type">atomic_t</span>		nr_active_requests_shared_sbitmap;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbitmap_queue</span>	<span class="hljs-title">sched_bitmap_tags</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbitmap_queue</span>	<span class="hljs-title">sched_breserved_tags</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">icq_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_CGROUP</span><br>	DECLARE_BITMAP		(blkcg_pols, BLKCG_MAX_POLS);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blkcg_gq</span>		*<span class="hljs-title">root_blkg</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">blkg_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_limits</span>	<span class="hljs-title">limits</span>;</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		required_elevator_features;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_ZONED</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Zoned block device information for request dispatch control.</span><br><span class="hljs-comment">	 * nr_zones is the total number of zones of the device. This is always</span><br><span class="hljs-comment">	 * 0 for regular block devices. conv_zones_bitmap is a bitmap of nr_zones</span><br><span class="hljs-comment">	 * bits which indicates if a zone is conventional (bit set) or</span><br><span class="hljs-comment">	 * sequential (bit clear). seq_zones_wlock is a bitmap of nr_zones</span><br><span class="hljs-comment">	 * bits which indicates if a zone is write locked, that is, if a write</span><br><span class="hljs-comment">	 * request targeting the zone was dispatched. All three fields are</span><br><span class="hljs-comment">	 * initialized by the low level device driver (e.g. scsi/sd.c).</span><br><span class="hljs-comment">	 * Stacking drivers (device mappers) may or may not initialize</span><br><span class="hljs-comment">	 * these fields.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * Reads of this information must be protected with blk_queue_enter() /</span><br><span class="hljs-comment">	 * blk_queue_exit(). Modifying this information is only allowed while</span><br><span class="hljs-comment">	 * no requests are being processed. See also blk_mq_freeze_queue() and</span><br><span class="hljs-comment">	 * blk_mq_unfreeze_queue().</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		nr_zones;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		*conv_zones_bitmap;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>		*seq_zones_wlock;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		max_open_zones;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		max_active_zones;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_BLK_DEV_ZONED */</span></span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * sg stuff</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		sg_timeout;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		sg_reserved_size;<br>	<span class="hljs-type">int</span>			node;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>		<span class="hljs-title">debugfs_mutex</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_trace</span> __<span class="hljs-title">rcu</span>	*<span class="hljs-title">blk_trace</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * for flush operations</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_flush_queue</span>	*<span class="hljs-title">fq</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">requeue_list</span>;</span><br>	<span class="hljs-type">spinlock_t</span>		requeue_lock;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">delayed_work</span>	<span class="hljs-title">requeue_work</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>		<span class="hljs-title">sysfs_lock</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>		<span class="hljs-title">sysfs_dir_lock</span>;</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * for reusing dead hctx instance in case of updating</span><br><span class="hljs-comment">	 * nr_hw_queues</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">unused_hctx_list</span>;</span><br>	<span class="hljs-type">spinlock_t</span>		unused_hctx_lock;<br><br>	<span class="hljs-type">int</span>			mq_freeze_depth;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BLK_DEV_BSG)</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bsg_class_device</span> <span class="hljs-title">bsg_dev</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_THROTTLING</span><br>	<span class="hljs-comment">/* Throttle data */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">throtl_data</span> *<span class="hljs-title">td</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span>		<span class="hljs-title">rcu_head</span>;</span><br>	<span class="hljs-type">wait_queue_head_t</span>	mq_freeze_wq;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Protect concurrent access to q_usage_counter by</span><br><span class="hljs-comment">	 * percpu_ref_kill() and percpu_ref_reinit().</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span>		<span class="hljs-title">mq_freeze_lock</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_tag_set</span>	*<span class="hljs-title">tag_set</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">tag_set_list</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_set</span>		<span class="hljs-title">bio_split</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>		*<span class="hljs-title">debugfs_dir</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEBUG_FS</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>		*<span class="hljs-title">sched_debugfs_dir</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>		*<span class="hljs-title">rqos_debugfs_dir</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-type">bool</span>			mq_sysfs_init_done;<br><br>	<span class="hljs-type">size_t</span>			cmd_size;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLK_MAX_WRITE_HINTS	5</span><br>	u64			write_hints[BLK_MAX_WRITE_HINTS];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>struct blk_mq_ops</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span> &#123;</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @queue_rq: Queue a new request from block IO.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">blk_status_t</span> (*queue_rq)(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *,<br>				 <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> blk_mq_queue_data *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @commit_rqs: If a driver uses bd-&gt;last to judge when to submit</span><br><span class="hljs-comment">	 * requests to hardware, it must define this function. In case of errors</span><br><span class="hljs-comment">	 * that make us stop issuing further requests, this hook serves the</span><br><span class="hljs-comment">	 * purpose of kicking the hardware (which the last request otherwise</span><br><span class="hljs-comment">	 * would have done).</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*commit_rqs)(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @get_budget: Reserve budget before queue request, once .queue_rq is</span><br><span class="hljs-comment">	 * run, it is driver&#x27;s responsibility to release the</span><br><span class="hljs-comment">	 * reserved budget. Also we have to handle failure case</span><br><span class="hljs-comment">	 * of .get_budget for avoiding I/O deadlock.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> (*get_budget)(<span class="hljs-keyword">struct</span> request_queue *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @put_budget: Release the reserved budget.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*put_budget)(<span class="hljs-keyword">struct</span> request_queue *, <span class="hljs-type">int</span>);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @set_rq_budget_token: store rq&#x27;s budget token</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*set_rq_budget_token)(<span class="hljs-keyword">struct</span> request *, <span class="hljs-type">int</span>);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @get_rq_budget_token: retrieve rq&#x27;s budget token</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> (*get_rq_budget_token)(<span class="hljs-keyword">struct</span> request *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @timeout: Called on request timeout.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">enum</span> <span class="hljs-title function_">blk_eh_timer_return</span> <span class="hljs-params">(*timeout)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *, <span class="hljs-type">bool</span>)</span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @poll: Called to poll for completion of a specific tag.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> (*poll)(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @complete: Mark the request as complete.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*complete)(<span class="hljs-keyword">struct</span> request *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @init_hctx: Called when the block layer side of a hardware queue has</span><br><span class="hljs-comment">	 * been set up, allowing the driver to allocate/init matching</span><br><span class="hljs-comment">	 * structures.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> (*init_hctx)(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *, <span class="hljs-type">void</span> *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @exit_hctx: Ditto for exit/teardown.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*exit_hctx)(<span class="hljs-keyword">struct</span> blk_mq_hw_ctx *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @init_request: Called for every command allocated by the block layer</span><br><span class="hljs-comment">	 * to allow the driver to set up driver specific data.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * Tag greater than or equal to queue_depth is for setting up</span><br><span class="hljs-comment">	 * flush request.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> (*init_request)(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">struct</span> request *,<br>			    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @exit_request: Ditto for exit/teardown.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*exit_request)(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>, <span class="hljs-keyword">struct</span> request *,<br>			     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @initialize_rq_fn: Called from inside blk_get_request().</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*initialize_rq_fn)(<span class="hljs-keyword">struct</span> request *rq);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @cleanup_rq: Called before freeing one request which isn&#x27;t completed</span><br><span class="hljs-comment">	 * yet, and usually for freeing the driver private data.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*cleanup_rq)(<span class="hljs-keyword">struct</span> request *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @busy: If set, returns whether or not this queue currently is busy.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">bool</span> (*busy)(<span class="hljs-keyword">struct</span> request_queue *);<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @map_queues: This allows drivers specify their own queue mapping by</span><br><span class="hljs-comment">	 * overriding the setup-time function that builds the mq_map.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">int</span> (*map_queues)(<span class="hljs-keyword">struct</span> blk_mq_tag_set *<span class="hljs-built_in">set</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEBUG_FS</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * @show_rq: Used by the debugfs implementation to show driver-specific</span><br><span class="hljs-comment">	 * information about a request.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">void</span> (*show_rq)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> request *rq);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><strong>struct request</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span> *<span class="hljs-title">q</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ctx</span> *<span class="hljs-title">mq_ctx</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_hw_ctx</span> *<span class="hljs-title">mq_hctx</span>;</span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd_flags;		<span class="hljs-comment">/* op and common flags */</span><br>	<span class="hljs-type">req_flags_t</span> rq_flags;<br><br>	<span class="hljs-type">int</span> tag;<br>	<span class="hljs-type">int</span> internal_tag;<br><br>	<span class="hljs-comment">/* the following two fields are internal, NEVER access directly */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __data_len;	<span class="hljs-comment">/* total data len */</span><br>	<span class="hljs-type">sector_t</span> __sector;		<span class="hljs-comment">/* sector cursor */</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bio</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">biotail</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">queuelist</span>;</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The hash is used inside the scheduler, and killed once the</span><br><span class="hljs-comment">	 * request reaches the dispatch list. The ipi_list is only used</span><br><span class="hljs-comment">	 * to queue the request for softirq completion, which is long</span><br><span class="hljs-comment">	 * after the request has been unhashed (and even removed from</span><br><span class="hljs-comment">	 * the dispatch list).</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">hash</span>;</span>	<span class="hljs-comment">/* merge hash */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">llist_node</span> <span class="hljs-title">ipi_list</span>;</span><br>	&#125;;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * The rb_node is only used inside the io scheduler, requests</span><br><span class="hljs-comment">	 * are pruned when moved to the dispatch queue. So let the</span><br><span class="hljs-comment">	 * completion_data share space with the rb_node.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">rb_node</span>;</span>	<span class="hljs-comment">/* sort/lookup */</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_vec</span> <span class="hljs-title">special_vec</span>;</span><br>		<span class="hljs-type">void</span> *completion_data;<br>		<span class="hljs-type">int</span> error_count; <span class="hljs-comment">/* for legacy drivers, don&#x27;t use */</span><br>	&#125;;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Three pointers are available for the IO schedulers, if they need</span><br><span class="hljs-comment">	 * more they have to dynamically allocate it.  Flush requests are</span><br><span class="hljs-comment">	 * never put on the IO scheduler. So let the flush fields share</span><br><span class="hljs-comment">	 * space with the elevator data.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_cq</span>		*<span class="hljs-title">icq</span>;</span><br>			<span class="hljs-type">void</span>			*priv[<span class="hljs-number">2</span>];<br>		&#125; elv;<br><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		seq;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">list</span>;</span><br>			rq_end_io_fn		*saved_end_io;<br>		&#125; flush;<br>	&#125;;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gendisk</span> *<span class="hljs-title">rq_disk</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_device</span> *<span class="hljs-title">part</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_RQ_ALLOC_TIME</span><br>	<span class="hljs-comment">/* Time that the first bio started allocating this request. */</span><br>	u64 alloc_time_ns;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/* Time that this request was allocated for this IO. */</span><br>	u64 start_time_ns;<br>	<span class="hljs-comment">/* Time that I/O was submitted to the device. */</span><br>	u64 io_start_time_ns;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_WBT</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> wbt_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * rq sectors used for blk stats. It has the same value</span><br><span class="hljs-comment">	 * with blk_rq_sectors(rq), except that it never be zeroed</span><br><span class="hljs-comment">	 * by completion.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> stats_sectors;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Number of scatter-gather DMA addr+len pairs after</span><br><span class="hljs-comment">	 * physical address coalescing is performed.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> nr_phys_segments;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> nr_integrity_segments;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_INLINE_ENCRYPTION</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio_crypt_ctx</span> *<span class="hljs-title">crypt_ctx</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_ksm_keyslot</span> *<span class="hljs-title">crypt_keyslot</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> write_hint;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ioprio;<br><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">mq_rq_state</span> <span class="hljs-title">state</span>;</span><br>	<span class="hljs-type">refcount_t</span> ref;<br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> timeout;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> deadline;<br><br>	<span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">call_single_data</span> <span class="hljs-title">csd</span>;</span><br>		u64 fifo_time;<br>	&#125;;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * completion callback.</span><br><span class="hljs-comment">	 */</span><br>	rq_end_io_fn *end_io;<br>	<span class="hljs-type">void</span> *end_io_data;<br>&#125;;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" class="category-chain-item">内核驱动开发记录</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="category-chain-item">学习记录</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/zns-ssd-femu-nvme-spdk-dpdk/" class="category-chain-item">zns ssd-femu-nvme-spdk-dpdk</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0-linux-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" class="print-no-link">#学习 linux 驱动开发</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/c++%20%E5%87%BD%E6%95%B0%E6%9C%AA%E8%AE%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E5%80%BC.html" title="c++ 函数未设置返回值">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">c++ 函数未设置返回值</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/NVMe%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1.html" title="NVMe驱动学习记录-1">
                        <span class="hidden-mobile">NVMe驱动学习记录-1</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz","appKey":"0e2MMh7ddBCGGytOe9UEy5NP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://uu0wegco.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
