

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/nano-1.jpg">
  <link rel="icon" href="/img/nano-1.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="最佳损友1020">
  <meta name="keywords" content="">
  
    <meta name="description" content="往期文章：NVMe驱动学习记录-1NVMe驱动学习记录-2NVMe驱动 请求路径学习记录 整合了之前文章的一些内容 参考源码地址：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kernel&#x2F;v4.x&#x2F;linux-4.19.90.tar.gz      linux-4.19.90\drivers\nvme\host  源码阅读环境：Windows 搭建 openg">
<meta property="og:type" content="article">
<meta property="og:title" content="NVMe驱动注释（持续更新）">
<meta property="og:url" content="https://www.jiasun.top/blog/NVMe%E9%A9%B1%E5%8A%A8%E6%B3%A8%E9%87%8A%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.html">
<meta property="og:site_name" content="最佳损友1020’s Blog">
<meta property="og:description" content="往期文章：NVMe驱动学习记录-1NVMe驱动学习记录-2NVMe驱动 请求路径学习记录 整合了之前文章的一些内容 参考源码地址：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kernel&#x2F;v4.x&#x2F;linux-4.19.90.tar.gz      linux-4.19.90\drivers\nvme\host  源码阅读环境：Windows 搭建 openg">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4ecd7c7deba418d2d5ceba1203f15d13.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5910c833b1644958863005af04c5e394.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d3a1901b8d9e49aaa96f266b1524fe8a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/14c45b6066d64a289eb97e263bbf9037.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7e8ebb2b41004945840c592f8d7f81fa.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f9858338fc8443868e85327d0842e918.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/da7278c5a4eb421f922a05022fa265cd.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8e08b8d6be35458d8f2cdb0a58164d0d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c4133ba2520b4f21b9e671cd3d0209bc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/28607989a14247cbb513a72b489c7b38.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7679029c10cd4a9aa4d775c28248586f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/209e8945b42346c699e60ef7025d262b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f2853984dd2b4101b4600429588cf3c8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/34987e7f18924c63afe70e003e0203e5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ed7c8032112b466b891c08bd66509d65.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4137d833e46f4f1ebb9fdc94d547f909.png">
<meta property="article:published_time" content="2023-03-06T02:26:57.000Z">
<meta property="article:modified_time" content="2023-10-31T14:45:58.957Z">
<meta property="article:author" content="最佳损友1020">
<meta property="article:tag" content="nvme驱动">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/4ecd7c7deba418d2d5ceba1203f15d13.png">
  
  
  
  <title>NVMe驱动注释（持续更新） - 最佳损友1020’s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/csdn.css">
<link rel="stylesheet" href="/css/top.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.jiasun.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz","app_key":"ljkRZDiTtVmjn5mpaQmpFqgv","server_url":"https://n227fxnj.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>最佳损友1020</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="NVMe驱动注释（持续更新）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-06 10:26" pubdate>
          2023年3月6日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          35k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          289 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">NVMe驱动注释（持续更新）</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer" />



<p>往期文章：<br><a href="https://www.jiasun.top/blog/NVMe%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-1.html">NVMe驱动学习记录-1</a><br><a href="https://www.jiasun.top/blog/NVMe%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-2.html">NVMe驱动学习记录-2</a><br><a href="https://www.jiasun.top/blog/NVMe%E9%A9%B1%E5%8A%A8%20%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html">NVMe驱动 请求路径学习记录</a></p>
<p>整合了之前文章的一些内容</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>源码地址：<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-4.19.90.tar.gz">https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-4.19.90.tar.gz</a>    </p>
<blockquote>
<p>linux-4.19.90\drivers\nvme\host</p>
</blockquote>
<p>源码阅读环境：<a target="_blank" rel="noopener" href="https://geek-docs.com/personal/obama/windows-setup-opengrok.html">Windows 搭建 opengrok|极客教程 (geek-docs.com)</a></p>
<p>书籍：<br><a target="_blank" rel="noopener" href="https://github.com/1020xyr/books/blob/main/LINUX%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F(%E7%AC%AC3%E7%89%88).pdf">LINUX设备驱动程序</a><br><a target="_blank" rel="noopener" href="https://nvmexpress.org/developers/nvme-specification/">NVMe Base Specification</a></p>
<p>初始化参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/panzhenjie/article/details/51581063">linux里的nvme驱动代码分析（加载初始化） </a> nvme_reset_work()函数后的代码大致相同</p>
<p>IO入口点：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72234187">NVMe的Linux内核驱动分析</a></p>
<p>块设备层相关数据结构：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32740107/article/details/106302376?spm=1001.2014.3001.5501">Block multi-queue 架构解析（一）数据结构</a></p>
<p>块设备层文档：<a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/block_device_drivers.html#block-device-drivers">Block Device Drivers</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tolimit/p/8779876.html">linux内核源码分析 - nvme设备的初始化</a></p>
<p>函数查询：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/ident">identifier - Linux source code (v5.14.9) - Bootlin</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4ecd7c7deba418d2d5ceba1203f15d13.png" srcset="/img/loading.gif" lazyload alt="preview"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/daocaokafei/article/details/108071589">手把手教Linux驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaojiang1025/category/918665.html?page=2">linux驱动开发</a></p>
<p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/karenchan/topics/1006006">nvme kernel driver 阅读笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1338070478725480449">nvme协议详解</a></p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p><font size=5>请注意，本文已将错误处理代码 unlikely分支代码略去，留下基本的处理代码，若需阅读相关代码，请自行下载源码</font></p>
<h2 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">nvme_core模块初始化<br>	nvme_core_init():创建工作队列，类；申请设备号<br>nvme模块初始化<br>	nvme_init():注册pci_driver结构体<br>	nvme_probe()<br>		nvme_dev_map():申请IO内存并进行映射<br>		nvme_setup_prp_pools():创建DMA池<br>		nvme_init_ctrl():填充nvme_ctrl结构体，创建字符设备<br>		nvme_reset_ctrl():修改nvme_ctrl结构体状态，将nvme_reset_work加入工作队列nvme_reset_wq<br>    <br>	<span class="hljs-title function_">nvme_reset_work</span><span class="hljs-params">()</span>:重启设备，涉及许多nvme协议相关知识，还有设备各阶段对寄存器的操作，没太仔细看，就对照博客看一下功能即可<br>    	<span class="hljs-title function_">nvme_dev_disable</span><span class="hljs-params">(dev, <span class="hljs-literal">false</span>)</span>:正常关机<br>		<span class="hljs-title function_">nvme_pci_enable</span><span class="hljs-params">()</span>:初始化pci设备（BAR寄存器，MSI-X中断，CMB等)<br>  		<span class="hljs-title function_">nvme_pci_configure_admin_queue</span><span class="hljs-params">()</span>:映射bar寄存器，申请并初始化admin队列<br>		<span class="hljs-title function_">nvme_alloc_admin_tags</span><span class="hljs-params">()</span>:初始化dev-&gt;admin_tagset结构体，并创建请求队列<br>    	<span class="hljs-title function_">nvme_init_identify</span><span class="hljs-params">()</span>: 向NVMe设备发送identify命令<br>    	<span class="hljs-title function_">nvme_setup_io_queues</span><span class="hljs-params">()</span>:向NVMe设备发送<span class="hljs-built_in">set</span> feature命令，再次申请中断号，注册中断函数 申请空间，创建IO队列<br>    	<span class="hljs-title function_">nvme_dev_add</span><span class="hljs-params">()</span>:填充dev-&gt;tagset <br>    	<span class="hljs-title function_">nvme_start_ctrl</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title function_">nvme_queue_scan</span><span class="hljs-params">()</span>-&gt;ctrl-&gt;scan_work-&gt;<span class="hljs-title function_">nvme_scan_work</span><span class="hljs-params">()</span><br>    <br>    <span class="hljs-title function_">nvme_scan_work</span><span class="hljs-params">()</span>: 发送一系列identify命令，创建块设备<br>    只需看<span class="hljs-title function_">nvme_scan_ns_list</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title function_">nvme_validate_ns</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title function_">nvme_alloc_ns</span><span class="hljs-params">()</span><br>    	<span class="hljs-title function_">nvme_alloc_ns</span><span class="hljs-params">()</span>:填充ns，创建块设备<br><br></code></pre></td></tr></table></figure>

<h2 id="简单注释"><a href="#简单注释" class="headerlink" title="简单注释"></a>简单注释</h2><p>nvme驱动由两个内核模块组成：nvme模块与nvme_core模块，nvme模块依赖于nvme_core模块</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">s081@ubuntu ~&gt; lsmod | grep <span class="hljs-string">&quot;nvme&quot;</span><br>nvme                   49152  0<br>nvme_core             135168  1 nvme<br>s081@ubuntu ~&gt; rmmod nvme_core<br>rmmod: ERROR: Module nvme_core is <span class="hljs-keyword">in</span> use by: nvme<br></code></pre></td></tr></table></figure>

<p>Makefile文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># SPDX-License-Identifier: GPL<span class="hljs-number">-2.0</span><br><br>ccflags-y				+= -I$(src)<br><br>obj-$(CONFIG_NVME_CORE)			+= nvme-core.o<br>obj-$(CONFIG_BLK_DEV_NVME)		+= nvme.o<br>obj-$(CONFIG_NVME_FABRICS)		+= nvme-fabrics.o<br>obj-$(CONFIG_NVME_RDMA)			+= nvme-rdma.o<br>obj-$(CONFIG_NVME_FC)			+= nvme-fc.o<br><br>nvme-core-y				:= core.o<br>nvme-core-$(CONFIG_TRACING)		+= trace.o<br>nvme-core-$(CONFIG_NVME_MULTIPATH)	+= multipath.o<br>nvme-core-$(CONFIG_NVM)			+= lightnvm.o<br>nvme-core-$(CONFIG_FAULT_INJECTION_DEBUG_FS)	+= fault_inject.o<br><br>nvme-y					+= pci.o<br><br>nvme-fabrics-y				+= fabrics.o<br><br>nvme-rdma-y				+= rdma.o<br><br>nvme-fc-y				+= fc.o<br></code></pre></td></tr></table></figure>
<p>可以看出nvme-core模块由core.c编译而来，nvme模块由pci.c编译而来<br>主要涉及的文件有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">drivers\nvme\host\nvme.h<br>\include\linux\nvme.h<br>drivers\nvme\host\pci.c<br>drivers\nvme\host\core.c<br></code></pre></td></tr></table></figure>


<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="nvme-core-init"><a href="#nvme-core-init" class="headerlink" title="nvme_core_init"></a>nvme_core_init</h4><p>nvme驱动首先加载nvme_core模块，再加载nvme模块，故先看nvme_core模块的入口点函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __init <span class="hljs-title function_">nvme_core_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> result = -ENOMEM;<br>  <span class="hljs-comment">// 创建工作队列</span><br>  nvme_wq = alloc_workqueue(<span class="hljs-string">&quot;nvme-wq&quot;</span>, WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, <span class="hljs-number">0</span>);<br>  nvme_reset_wq = alloc_workqueue(<span class="hljs-string">&quot;nvme-reset-wq&quot;</span>, WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, <span class="hljs-number">0</span>);<br>  nvme_delete_wq = alloc_workqueue(<span class="hljs-string">&quot;nvme-delete-wq&quot;</span>, WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 申请设备号</span><br>  result = alloc_chrdev_region(&amp;nvme_chr_devt, <span class="hljs-number">0</span>, NVME_MINORS, <span class="hljs-string">&quot;nvme&quot;</span>);<br>  <span class="hljs-comment">// 创建struct class对象，用作device_create(struct class *class, struct device *parent,dev_t devt, void *drvdata, const char *fmt, ...)参数</span><br>  nvme_class = class_create(THIS_MODULE, <span class="hljs-string">&quot;nvme&quot;</span>);<br>  nvme_subsys_class = class_create(THIS_MODULE, <span class="hljs-string">&quot;nvme-subsystem&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_VERSION(<span class="hljs-string">&quot;1.0&quot;</span>);<br>module_init(nvme_core_init);<br>module_exit(nvme_core_exit);<br></code></pre></td></tr></table></figure>
<p>nvme_core模块只是创建了3个工作队列，申请了字符设备的设备号，创建了两个class类<br><img src="https://img-blog.csdnimg.cn/5910c833b1644958863005af04c5e394.png" srcset="/img/loading.gif" lazyload><br>nvme-generic不知道从哪来的，有可能是内核版本不一致的问题，虚拟机内核版本5.15.0，nvme代码版本4.19.0</p>
<p>然后便是nvme模块的入口点函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span> <span class="hljs-title">nvme_id_table</span>[] =</span> &#123;&#123;<br>                                                         PCI_VDEVICE(INTEL, <span class="hljs-number">0x0953</span>),<br>                                                         .driver_data = NVME_QUIRK_STRIPE_SIZE | NVME_QUIRK_DEALLOCATE_ZEROES,<br>                                                     &#125;,<br><span class="hljs-comment">// 略去一些id</span><br>                                                     &#123;PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_EXPRESS, <span class="hljs-number">0xffffff</span>)&#125;,<br>                                                     &#123;PCI_DEVICE(PCI_VENDOR_ID_APPLE, <span class="hljs-number">0x2001</span>)&#125;,<br>                                                     &#123;PCI_DEVICE(PCI_VENDOR_ID_APPLE, <span class="hljs-number">0x2003</span>)&#125;,<br>                                                     &#123;<br>                                                         <span class="hljs-number">0</span>,<br>                                                     &#125;&#125;;<br>MODULE_DEVICE_TABLE(pci, nvme_id_table);<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span> <span class="hljs-title">nvme_driver</span> =</span> &#123;<br>    .name = <span class="hljs-string">&quot;nvme&quot;</span>,<br>    .id_table = nvme_id_table,<br>    .probe = nvme_probe,  <span class="hljs-comment">// 探测函数</span><br>    .remove = nvme_remove,<br>    .shutdown = nvme_shutdown,<br>    .driver =<br>        &#123;<br>            .pm = &amp;nvme_dev_pm_ops,<br>        &#125;,<br>    .sriov_configure = pci_sriov_configure_simple,<br>    .err_handler = &amp;nvme_err_handler,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">nvme_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> pci_register_driver(&amp;nvme_driver);  <span class="hljs-comment">// 注册pci_driver对象</span><br>&#125;<br><br>MODULE_AUTHOR(<span class="hljs-string">&quot;Matthew Wilcox &lt;willy@linux.intel.com&gt;&quot;</span>);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_VERSION(<span class="hljs-string">&quot;1.0&quot;</span>);<br>module_init(nvme_init);<br>module_exit(nvme_exit);<br><br></code></pre></td></tr></table></figure>
<p>nvme_init函数向系统注册一个pci_driver对象，当连入pci总线的设备ID与nvme_id_table匹配时，则会调用驱动的探测函数nvme_probe，进行设备的初始化操作</p>
<h4 id="nvme-probe"><a href="#nvme-probe" class="headerlink" title="nvme_probe"></a>nvme_probe</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *pdev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id)</span> &#123;<br>  <span class="hljs-type">int</span> node, result = -ENOMEM;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_dev</span> *<span class="hljs-title">dev</span>;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> quirks = id-&gt;driver_data;  <span class="hljs-comment">// enum nvme_quirks对象，非标准方法</span><br>  <span class="hljs-type">size_t</span> alloc_size;<br><br>  node = dev_to_node(&amp;pdev-&gt;dev);                                         <span class="hljs-comment">// 获取所属内存节点</span><br>  <span class="hljs-keyword">if</span> (node == NUMA_NO_NODE) set_dev_node(&amp;pdev-&gt;dev, first_memory_node);  <span class="hljs-comment">// 设置所属内存节点</span><br><br>  dev = kzalloc_node(<span class="hljs-keyword">sizeof</span>(*dev), GFP_KERNEL, node);  <span class="hljs-comment">// 为nvme_dev结构体申请空间，注意dev为struct nvme_dev *类型而不是struct device*类型</span><br><br>  dev-&gt;queues = kcalloc_node(num_possible_cpus() + <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> nvme_queue), GFP_KERNEL, node);  <span class="hljs-comment">// 申请(num_possible_cpus() + 1)个nvme_queue结构体空间</span><br><br>  dev-&gt;dev = get_device(&amp;pdev-&gt;dev);  <span class="hljs-comment">// 增加pdev-&gt;dev引用计数</span><br>  pci_set_drvdata(pdev, dev);         <span class="hljs-comment">// 设置device私有数据，pdev-&gt;dev-&gt;driver_data = dev</span><br><br>  result = nvme_dev_map(dev);  <span class="hljs-comment">// 映射BAR空间</span><br>  <span class="hljs-comment">// 创建工作项</span><br>  INIT_WORK(&amp;dev-&gt;ctrl.reset_work, nvme_reset_work);<br>  INIT_WORK(&amp;dev-&gt;remove_work, nvme_remove_dead_ctrl_work);<br>  <span class="hljs-comment">// 初始化互斥锁</span><br>  mutex_init(&amp;dev-&gt;shutdown_lock);<br>  <span class="hljs-comment">// 初始化完成变量</span><br>  init_completion(&amp;dev-&gt;ioq_wait);<br><br>  result = nvme_setup_prp_pools(dev);  <span class="hljs-comment">// 创建DMA池</span><br><br>  quirks |= check_vendor_combination_bug(pdev);  <span class="hljs-comment">// 特殊设备处理，不需要关注</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Double check that our mempool alloc size will cover the biggest</span><br><span class="hljs-comment">   * command we support.</span><br><span class="hljs-comment">   */</span><br>  alloc_size = nvme_pci_iod_alloc_size(dev, NVME_MAX_KB_SZ, NVME_MAX_SEGS, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 分配的内存池大小，与sgl命令 scatterlist有关，暂不分析</span><br>  WARN_ON_ONCE(alloc_size &gt; PAGE_SIZE);<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  mempool_t *mempool_create_node(int min_nr, mempool_alloc_t *alloc_fn,mempool_free_t *free_fn, void *pool_data,gfp_t gfp_mask, int node_id)</span><br><span class="hljs-comment">  void *mempool_kmalloc(gfp_t gfp_mask, void *pool_data)</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">        size_t size = (size_t)pool_data;</span><br><span class="hljs-comment">        return kmalloc(size, gfp_mask);</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  */</span><br>  dev-&gt;iod_mempool = mempool_create_node(<span class="hljs-number">1</span>, mempool_kmalloc, mempool_kfree, (<span class="hljs-type">void</span> *)alloc_size, GFP_KERNEL, node);  <span class="hljs-comment">// 创建内存池，预分配一个对象空间</span><br><br>  result = nvme_init_ctrl(&amp;dev-&gt;ctrl, &amp;pdev-&gt;dev, &amp;nvme_pci_ctrl_ops, quirks);  <span class="hljs-comment">// 填充struct nvme_ctrl结构体并注册字符设备</span><br><br>  dev_info(dev-&gt;ctrl.device, <span class="hljs-string">&quot;pci function %s\n&quot;</span>, dev_name(&amp;pdev-&gt;dev));<br><br>  nvme_reset_ctrl(&amp;dev-&gt;ctrl);            <span class="hljs-comment">// 重置控制器</span><br>  nvme_get_ctrl(&amp;dev-&gt;ctrl);              <span class="hljs-comment">// 增加dev-&gt;ctrl-&gt;device引用计数</span><br>  async_schedule(nvme_async_probe, dev);  <span class="hljs-comment">// 等待任务完成再减小引用计数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分析nvme_dev_map函数与BAR相关代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_remap_bar</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span> *<span class="hljs-title">pdev</span> =</span> to_pci_dev(dev-&gt;dev);<br>  <span class="hljs-keyword">if</span> (size &lt;= dev-&gt;bar_mapped_size) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;             <span class="hljs-comment">// 如果小于之前的映射空间大小，则不需要重新映射</span><br>  <span class="hljs-keyword">if</span> (size &gt; pci_resource_len(pdev, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> -ENOMEM;   <span class="hljs-comment">//  超出BAR空间大小，返回错误</span><br>  <span class="hljs-keyword">if</span> (dev-&gt;bar) iounmap(dev-&gt;bar);                        <span class="hljs-comment">// 取消之前的映射</span><br>  dev-&gt;bar = ioremap(pci_resource_start(pdev, <span class="hljs-number">0</span>), size);  <span class="hljs-comment">// 映射BAR0</span><br>  dev-&gt;bar_mapped_size = size;<br>  dev-&gt;dbs = dev-&gt;bar + NVME_REG_DBS;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_dev_map</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span> *<span class="hljs-title">pdev</span> =</span> to_pci_dev(dev-&gt;dev);<br>  pci_request_mem_regions(pdev, <span class="hljs-string">&quot;nvme&quot;</span>);     <span class="hljs-comment">// 声明占用内存空间，只调用一次</span><br>  nvme_remap_bar(dev, NVME_REG_DBS + <span class="hljs-number">4096</span>);  <span class="hljs-comment">// 进行BAR空间映射，调用了三次</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">三次nvme_remap_bar调用<br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>  NVME_REG_CAP = <span class="hljs-number">0x0000</span>,    <span class="hljs-comment">/* Controller Capabilities */</span><br>  NVME_REG_VS = <span class="hljs-number">0x0008</span>,     <span class="hljs-comment">/* Version */</span><br>  NVME_REG_INTMS = <span class="hljs-number">0x000c</span>,  <span class="hljs-comment">/* Interrupt Mask Set */</span><br>  NVME_REG_INTMC = <span class="hljs-number">0x0010</span>,  <span class="hljs-comment">/* Interrupt Mask Clear */</span><br>  NVME_REG_CC = <span class="hljs-number">0x0014</span>,     <span class="hljs-comment">/* Controller Configuration */</span><br>  NVME_REG_CSTS = <span class="hljs-number">0x001c</span>,   <span class="hljs-comment">/* Controller Status */</span><br>  NVME_REG_NSSR = <span class="hljs-number">0x0020</span>,   <span class="hljs-comment">/* NVM Subsystem Reset */</span><br>  NVME_REG_AQA = <span class="hljs-number">0x0024</span>,    <span class="hljs-comment">/* Admin Queue Attributes */</span><br>  NVME_REG_ASQ = <span class="hljs-number">0x0028</span>,    <span class="hljs-comment">/* Admin SQ Base Address */</span><br>  NVME_REG_ACQ = <span class="hljs-number">0x0030</span>,    <span class="hljs-comment">/* Admin CQ Base Address */</span><br>  NVME_REG_CMBLOC = <span class="hljs-number">0x0038</span>, <span class="hljs-comment">/* Controller Memory Buffer Location */</span><br>  NVME_REG_CMBSZ = <span class="hljs-number">0x003c</span>,  <span class="hljs-comment">/* Controller Memory Buffer Size */</span><br>  NVME_REG_DBS = <span class="hljs-number">0x1000</span>,    <span class="hljs-comment">/* SQ 0 Tail Doorbell */</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_CAP_STRIDE(cap)	(((cap) &gt;&gt; 32) &amp; 0xf)	<span class="hljs-comment">// DB寄存器步长</span></span><br><br>dev-&gt;db_stride = <span class="hljs-number">1</span> &lt;&lt; NVME_CAP_STRIDE(dev-&gt;ctrl.cap);   <span class="hljs-comment">// CAP寄存器32-35位</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">db_bar_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev, <span class="hljs-type">unsigned</span> nr_io_queues)</span> &#123; <br>	<span class="hljs-keyword">return</span> NVME_REG_DBS + ((nr_io_queues + <span class="hljs-number">1</span>) * <span class="hljs-number">8</span> * dev-&gt;db_stride); <br>&#125;<br><br><span class="hljs-comment">// nvme_dev_map</span><br>nvme_remap_bar(dev, NVME_REG_DBS + <span class="hljs-number">4096</span>); <br><br><span class="hljs-comment">// nvme_pci_configure_admin_queue</span><br>result = nvme_remap_bar(dev, db_bar_size(dev, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// nvme_setup_io_queues</span><br>  <span class="hljs-keyword">do</span> &#123;<br>    size = db_bar_size(dev, nr_io_queues);<br>    result = nvme_remap_bar(dev, size);<br>    <span class="hljs-keyword">if</span> (!result) <span class="hljs-keyword">break</span>;		<span class="hljs-comment">// 映射成功，退出循环</span><br>    <span class="hljs-keyword">if</span> (!--nr_io_queues) <span class="hljs-keyword">return</span> -ENOMEM;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">使用方式<br><span class="hljs-comment">// nvme_init_queue  nvme_alloc_queue</span><br>nvmeq-&gt;q_db = &amp;dev-&gt;dbs[qid * <span class="hljs-number">2</span> * dev-&gt;db_stride];<br><span class="hljs-comment">// nvme_submit_cmd</span><br>writel(nvmeq-&gt;sq_tail, nvmeq-&gt;q_db);<br><span class="hljs-comment">// nvme_ring_cq_doorbell</span><br>u16 head = nvmeq-&gt;cq_head;<br>writel(head, nvmeq-&gt;q_db + nvmeq-&gt;dev-&gt;db_stride);<br></code></pre></td></tr></table></figure>
<p>首先介绍Doorbell Stride寄存器——NVM-Express-Base-Specification<br><img src="https://img-blog.csdnimg.cn/d3a1901b8d9e49aaa96f266b1524fe8a.png" srcset="/img/loading.gif" lazyload><br><img src="https://img-blog.csdnimg.cn/14c45b6066d64a289eb97e263bbf9037.png" srcset="/img/loading.gif" lazyload><br>总的来说一句话，实际的物理设备CAP.DSTRD值为0，dev-&gt;db_stride为1，之后分析中默认db_stride为1<br><img src="https://img-blog.csdnimg.cn/7e8ebb2b41004945840c592f8d7f81fa.png" srcset="/img/loading.gif" lazyload><br>vmware中虚拟nvme硬盘BAR0为16K，驱动第一次映射了8K空间，第二次仅仅映射1个sq&#x2F;cq寄存器对（admin）的空间，大概率是小于8K的，不需要重新映射，第三次首先计算IO队列数，而后持续尝试映射对应大小的BAR空间，直到找到合适的IO队列数，但通常也是小于8K的，所以不需要进行循环，所以大多数情况只需要进行一次实际的BAR空间映射<br><strong>NVMe白皮书对NVMe的配置建议</strong><br><img src="https://img-blog.csdnimg.cn/f9858338fc8443868e85327d0842e918.png" srcset="/img/loading.gif" lazyload><br>由dev-&gt;dbs使用方式可知，每一个DB寄存器对，前4个字节为SQ Tail DB，后四个字节为CQ Head DB</p>
<p><strong>DMA池代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_setup_prp_pools</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span> &#123;<br>  <span class="hljs-comment">// struct dma_pool *dma_pool_create(const char *name, struct device *dev,size_t size, size_t align, size_t boundary)</span><br>  <span class="hljs-comment">// 创建页DMA池</span><br>  dev-&gt;prp_page_pool = dma_pool_create(<span class="hljs-string">&quot;prp list page&quot;</span>, dev-&gt;dev, PAGE_SIZE, PAGE_SIZE, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 创建小DMA池</span><br>  <span class="hljs-comment">/* Optimisation for I/Os between 4k and 128k */</span><br>  dev-&gt;prp_small_pool = dma_pool_create(<span class="hljs-string">&quot;prp list 256&quot;</span>, dev-&gt;dev, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="nvme-init-ctrl"><a href="#nvme-init-ctrl" class="headerlink" title="nvme_init_ctrl"></a>nvme_init_ctrl</h4><p><strong>nvme_ctrl结构体初始化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORBITS	20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAJOR(dev)	((unsigned int) ((dev) &gt;&gt; MINORBITS))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINOR(dev)	((unsigned int) ((dev) &amp; MINORMASK))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Initialize a NVMe controller structures.  This needs to be called during</span><br><span class="hljs-comment"> * earliest initialization so that we have the initialized structured around</span><br><span class="hljs-comment"> * during probing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">nvme_init_ctrl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, <span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> nvme_ctrl_ops *ops, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> quirks)</span> &#123;<br>  <span class="hljs-type">int</span> ret;<br><br>  ctrl-&gt;state = NVME_CTRL_NEW;<br>  spin_lock_init(&amp;ctrl-&gt;lock);<br>  mutex_init(&amp;ctrl-&gt;scan_lock);<br>  INIT_LIST_HEAD(&amp;ctrl-&gt;namespaces);<br>  init_rwsem(&amp;ctrl-&gt;namespaces_rwsem);<br>  ctrl-&gt;dev = dev;<br>  ctrl-&gt;ops = ops;<br>  ctrl-&gt;quirks = quirks;<br>  <span class="hljs-comment">// 创建工作项</span><br>  INIT_WORK(&amp;ctrl-&gt;scan_work, nvme_scan_work);<br>  INIT_WORK(&amp;ctrl-&gt;async_event_work, nvme_async_event_work);<br>  INIT_WORK(&amp;ctrl-&gt;fw_act_work, nvme_fw_act_work);<br>  INIT_WORK(&amp;ctrl-&gt;delete_work, nvme_delete_ctrl_work);<br>  <span class="hljs-comment">// 创建延迟工作项</span><br>  INIT_DELAYED_WORK(&amp;ctrl-&gt;ka_work, nvme_keep_alive_work);<br>  <span class="hljs-built_in">memset</span>(&amp;ctrl-&gt;ka_cmd, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ctrl-&gt;ka_cmd));<br>  ctrl-&gt;ka_cmd.common.opcode = nvme_admin_keep_alive;<br><br>  BUILD_BUG_ON(NVME_DSM_MAX_RANGES * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> nvme_dsm_range) &gt; PAGE_SIZE);<br>  ctrl-&gt;discard_page = alloc_page(GFP_KERNEL);<br>  <span class="hljs-comment">// 分配未使用的唯一ID</span><br>  ret = ida_simple_get(&amp;nvme_instance_ida, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, GFP_KERNEL);<br>  ctrl-&gt;instance = ret;<br><br>  device_initialize(&amp;ctrl-&gt;ctrl_device);  <span class="hljs-comment">// 初始化struct device结构体</span><br>  ctrl-&gt;device = &amp;ctrl-&gt;ctrl_device;<br>  ctrl-&gt;device-&gt;devt = MKDEV(MAJOR(nvme_chr_devt), ctrl-&gt;instance);  <span class="hljs-comment">// 使用之前申请的设备号</span><br>  ctrl-&gt;device-&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> =</span> nvme_class;<br>  ctrl-&gt;device-&gt;parent = ctrl-&gt;dev;<br>  ctrl-&gt;device-&gt;groups = nvme_dev_attr_groups;<br>  ctrl-&gt;device-&gt;release = nvme_free_ctrl;<br>  dev_set_drvdata(ctrl-&gt;device, ctrl);	<span class="hljs-comment">// ctrl-&gt;device-&gt;driver_data=ctrl</span><br>  ret = dev_set_name(ctrl-&gt;device, <span class="hljs-string">&quot;nvme%d&quot;</span>, ctrl-&gt;instance); <br><br>  cdev_init(&amp;ctrl-&gt;cdev, &amp;nvme_dev_fops);  <span class="hljs-comment">// 初始化字符设备</span><br>  ctrl-&gt;cdev.owner = ops-&gt;module;<br>  ret = cdev_device_add(&amp;ctrl-&gt;cdev, ctrl-&gt;device);  <span class="hljs-comment">// 注册字符设备并导出至用户空间</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Initialize latency tolerance controls.  The sysfs files won&#x27;t</span><br><span class="hljs-comment">   * be visible to userspace unless the device actually supports APST.</span><br><span class="hljs-comment">   */</span><br>  ctrl-&gt;device-&gt;power.set_latency_tolerance = nvme_set_latency_tolerance;<br>  dev_pm_qos_update_user_latency_tolerance(ctrl-&gt;device, min(default_ps_max_latency_us, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)S32_MAX));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>nvme_init_ctrl函数主要就是填充了一遍nvme_ctrl结构体并注册了字符设备，nvme0即为导出的字符设备，主设备号为240，次设备号为0<br><img src="https://img-blog.csdnimg.cn/da7278c5a4eb421f922a05022fa265cd.png" srcset="/img/loading.gif" lazyload><br>再向虚拟机中加入一个nvme盘，注意需设置为新的设备节点<br><img src="https://img-blog.csdnimg.cn/8e08b8d6be35458d8f2cdb0a58164d0d.png" srcset="/img/loading.gif" lazyload><br><img src="https://img-blog.csdnimg.cn/c4133ba2520b4f21b9e671cd3d0209bc.png" srcset="/img/loading.gif" lazyload><br><img src="https://img-blog.csdnimg.cn/28607989a14247cbb513a72b489c7b38.png" srcset="/img/loading.gif" lazyload><br>默认设置的话就会变成以下的样子<br><img src="https://img-blog.csdnimg.cn/7679029c10cd4a9aa4d775c28248586f.png" srcset="/img/loading.gif" lazyload><br><img src="https://img-blog.csdnimg.cn/209e8945b42346c699e60ef7025d262b.png" srcset="/img/loading.gif" lazyload><br>nvme_probe函数中的dev_info输出如下<br><img src="https://img-blog.csdnimg.cn/f2853984dd2b4101b4600429588cf3c8.png" srcset="/img/loading.gif" lazyload><br>也就是说，设备有两个，驱动也执行了两次探测函数，创建了两个nvme字符设备，那么问题来了，nvme驱动是一个块设备驱动，为什么要创建字符设备呢？ 当然是提供相应的功能，也就是file_operations操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IOCTL_ID		_IO(<span class="hljs-string">&#x27;N&#x27;</span>, 0x40)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IOCTL_ADMIN_CMD	_IOWR(<span class="hljs-string">&#x27;N&#x27;</span>, 0x41, struct nvme_admin_cmd)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IOCTL_SUBMIT_IO	_IOW(<span class="hljs-string">&#x27;N&#x27;</span>, 0x42, struct nvme_user_io)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IOCTL_IO_CMD	_IOWR(<span class="hljs-string">&#x27;N&#x27;</span>, 0x43, struct nvme_passthru_cmd)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IOCTL_RESET	_IO(<span class="hljs-string">&#x27;N&#x27;</span>, 0x44)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IOCTL_SUBSYS_RESET	_IO(<span class="hljs-string">&#x27;N&#x27;</span>, 0x45)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IOCTL_RESCAN	_IO(<span class="hljs-string">&#x27;N&#x27;</span>, 0x46)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_dev_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ctrl</span> *<span class="hljs-title">ctrl</span> =</span> container_of(inode-&gt;i_cdev, <span class="hljs-keyword">struct</span> nvme_ctrl, cdev);<br><br>  <span class="hljs-keyword">switch</span> (ctrl-&gt;state) &#123;<br>    <span class="hljs-keyword">case</span> NVME_CTRL_LIVE:<br>    <span class="hljs-keyword">case</span> NVME_CTRL_ADMIN_ONLY:<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> -EWOULDBLOCK;<br>  &#125;<br><br>  file-&gt;private_data = ctrl;  <span class="hljs-comment">// 先将private_data赋值为ctrl，便于之后使用</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nvme_dev_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_ctrl</span> *<span class="hljs-title">ctrl</span> =</span> file-&gt;private_data; <br>  <span class="hljs-type">void</span> __user *argp = (<span class="hljs-type">void</span> __user *)arg;<br><br>  <span class="hljs-keyword">switch</span> (cmd) &#123;<br>    <span class="hljs-keyword">case</span> NVME_IOCTL_ADMIN_CMD:<br>      <span class="hljs-keyword">return</span> nvme_user_cmd(ctrl, <span class="hljs-literal">NULL</span>, argp);<br>    <span class="hljs-keyword">case</span> NVME_IOCTL_IO_CMD:<br>      <span class="hljs-keyword">return</span> nvme_dev_user_cmd(ctrl, argp);<br>    <span class="hljs-keyword">case</span> NVME_IOCTL_RESET:<br>      dev_warn(ctrl-&gt;device, <span class="hljs-string">&quot;resetting controller\n&quot;</span>);<br>      <span class="hljs-keyword">return</span> nvme_reset_ctrl_sync(ctrl);<br>    <span class="hljs-keyword">case</span> NVME_IOCTL_SUBSYS_RESET:<br>      <span class="hljs-keyword">return</span> nvme_reset_subsystem(ctrl);<br>    <span class="hljs-keyword">case</span> NVME_IOCTL_RESCAN:<br>      nvme_queue_scan(ctrl);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> -ENOTTY;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">nvme_dev_fops</span> =</span> &#123;<br>    .owner = THIS_MODULE,<br>    .open = nvme_dev_open,<br>    .unlocked_ioctl = nvme_dev_ioctl,<br>    .compat_ioctl = nvme_dev_ioctl,<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>之后深入的操作太头疼了，暂不分析</p>
<p>继续看nvme_probe函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">nvme_reset_ctrl(&amp;dev-&gt;ctrl);            <span class="hljs-comment">// 重置控制器</span><br>nvme_get_ctrl(&amp;dev-&gt;ctrl);              <span class="hljs-comment">// 增加dev-&gt;ctrl-&gt;device引用计数</span><br>async_schedule(nvme_async_probe, dev);  <span class="hljs-comment">// 等待任务完成再减小引用计数</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">nvme_reset_ctrl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!nvme_change_ctrl_state(ctrl, NVME_CTRL_RESETTING)) <span class="hljs-keyword">return</span> -EBUSY;  <span class="hljs-comment">// 修改crtl状态</span><br>  <span class="hljs-keyword">if</span> (!queue_work(nvme_reset_wq, &amp;ctrl-&gt;reset_work)) <span class="hljs-keyword">return</span> -EBUSY;       <span class="hljs-comment">// 调度reset_work</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nvme_async_probe</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">async_cookie_t</span> cookie)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_dev</span> *<span class="hljs-title">dev</span> =</span> data;<br>  <span class="hljs-comment">// flush_work - wait for a work to finish executing the last queueing instance</span><br>  <span class="hljs-comment">// 等待以下两个任务执行完成</span><br>  flush_work(&amp;dev-&gt;ctrl.reset_work);<br>  flush_work(&amp;dev-&gt;ctrl.scan_work);<br>  nvme_put_ctrl(&amp;dev-&gt;ctrl);  <span class="hljs-comment">// 减小dev-&gt;ctrl-&gt;device引用计数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出距离初始化完毕至少还有两个work：reset_work，scan_work</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">INIT_WORK(&amp;dev-&gt;ctrl.reset_work, nvme_reset_work);<br>INIT_WORK(&amp;ctrl-&gt;scan_work, nvme_scan_work);<br></code></pre></td></tr></table></figure>
<h4 id="nvme-reset-work"><a href="#nvme-reset-work" class="headerlink" title="nvme_reset_work"></a>nvme_reset_work</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">nvme_reset_work</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> work_struct *work)</span> </span>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">nvme_dev</span> *dev = <span class="hljs-built_in">container_of</span>(work, <span class="hljs-keyword">struct</span> nvme_dev, ctrl.reset_work);<br>  <span class="hljs-type">bool</span> was_suspend = !!(dev-&gt;ctrl.ctrl_config &amp; NVME_CC_SHN_NORMAL);<br>  <span class="hljs-type">int</span> result;<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">nvme_ctrl_state</span> new_state = NVME_CTRL_LIVE;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * If we&#x27;re called to reset a live controller first shut it down before</span><br><span class="hljs-comment">   * moving on.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// nvme_enable_ctrl： ctrl-&gt;ctrl_config |= NVME_CC_ENABLE;</span><br>  <span class="hljs-keyword">if</span> (dev-&gt;ctrl.ctrl_config &amp; NVME_CC_ENABLE) <span class="hljs-built_in">nvme_dev_disable</span>(dev, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 驱动初始化时NVME_CC_ENABLE并未置位，不进入该函数</span><br><br>  <span class="hljs-built_in">mutex_lock</span>(&amp;dev-&gt;shutdown_lock);<br>  result = <span class="hljs-built_in">nvme_pci_enable</span>(dev);  <span class="hljs-comment">// 使能PCI设备</span><br><br>  result = <span class="hljs-built_in">nvme_pci_configure_admin_queue</span>(dev);  <span class="hljs-comment">// 配置admin queue</span><br></code></pre></td></tr></table></figure>


<h4 id="nvme-pci-enable"><a href="#nvme-pci-enable" class="headerlink" title="nvme_pci_enable"></a>nvme_pci_enable</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_pci_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span> &#123;<br>  <span class="hljs-type">int</span> result = -ENOMEM;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span> *<span class="hljs-title">pdev</span> =</span> to_pci_dev(dev-&gt;dev);<br><br>  pci_enable_device_mem(pdev);  <span class="hljs-comment">// 使能设备的内存空间</span><br><br>  pci_set_master(pdev);  <span class="hljs-comment">// 设置PCI_COMMAND寄存器bus master位，使能DMA</span><br>  <span class="hljs-comment">// 对dma_mask和coherent_dma_mask赋值</span><br>  <span class="hljs-keyword">if</span> (dma_set_mask_and_coherent(dev-&gt;dev, DMA_BIT_MASK(<span class="hljs-number">64</span>)) &amp;&amp; dma_set_mask_and_coherent(dev-&gt;dev, DMA_BIT_MASK(<span class="hljs-number">32</span>))) <span class="hljs-keyword">goto</span> disable;<br><br>  <span class="hljs-keyword">if</span> (readl(dev-&gt;bar + NVME_REG_CSTS) == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 测试是否能读取BAR空间</span><br>    result = -ENODEV;<br>    <span class="hljs-keyword">goto</span> disable;<br>  &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Some devices and/or platforms don&#x27;t advertise or work with INTx</span><br><span class="hljs-comment">   * interrupts. Pre-enable a single MSIX or MSI vec for setup. We&#x27;ll</span><br><span class="hljs-comment">   * adjust this later.</span><br><span class="hljs-comment">   */</span><br>  result = pci_alloc_irq_vectors(pdev, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, PCI_IRQ_ALL_TYPES);  <span class="hljs-comment">// 请求中断向量</span><br><br>  dev-&gt;ctrl.cap = lo_hi_readq(dev-&gt;bar + NVME_REG_CAP);  <span class="hljs-comment">// 读取CAP寄存器</span><br><br>  dev-&gt;q_depth = <span class="hljs-type">min_t</span>(<span class="hljs-type">int</span>, NVME_CAP_MQES(dev-&gt;ctrl.cap) + <span class="hljs-number">1</span>, io_queue_depth);  <span class="hljs-comment">// 设置队列深度</span><br>  dev-&gt;db_stride = <span class="hljs-number">1</span> &lt;&lt; NVME_CAP_STRIDE(dev-&gt;ctrl.cap);                         <span class="hljs-comment">// 设置DB寄存器步长，一般为1</span><br>  dev-&gt;dbs = dev-&gt;bar + <span class="hljs-number">4096</span>;                                                   <span class="hljs-comment">// 设置DB寄存器内存映射起始地址</span><br><br>  nvme_map_cmb(dev);  <span class="hljs-comment">// 映射CMB</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  pci_enable_pcie_error_reporting enables the device to send error messages to root port when an error is detected.</span><br><span class="hljs-comment">  Note that devices don’t enable the error reporting by default, so device drivers need call this function to enable it.</span><br><span class="hljs-comment">  */</span><br>  pci_enable_pcie_error_reporting(pdev);<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  The pci_save_state() and pci_restore_state() functions can be used by a device driver to save and restore standard PCI config registers.</span><br><span class="hljs-comment">  The pci_save_state() function must be invoked while the device has valid state before pci_restore_state() can be used.</span><br><span class="hljs-comment">  If the device is not in the fully-powered state (PCI_POWERSTATE_D0) when pci_restore_state() is  invoked,</span><br><span class="hljs-comment">  then the device will be transitioned to PCI_POWERSTATE_D0 before any config registers are restored.</span><br><span class="hljs-comment">  */</span><br>  pci_save_state(pdev);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>disable:<br>  pci_disable_device(pdev);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>pci_enable_device_mem</p>
</blockquote>
<p>PCI&#x2F;PCIE的BAR有两种类型，memory和IO。pci_enable_device_mem只初始化memory类型的BAR，pci_enable_device同时初始化memory和IO类型的BAR。如果要驱动的PCI&#x2F;PCIE设备包含IO空间，那么必须使用pci_enable_device</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pci_enable_device_mem - Initialize a device for use with Memory space</span><br><span class="hljs-comment"> * @dev: PCI device to be initialized</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Initialize device before it&#x27;s used by a driver. Ask low-level code</span><br><span class="hljs-comment"> * to enable Memory resources. Wake up the device if it was suspended.</span><br><span class="hljs-comment"> * Beware, this function can fail.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pci_enable_device_mem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *dev)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> pci_enable_device_flags(dev, IORESOURCE_MEM);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pci_enable_device - Initialize device before it&#x27;s used by a driver.</span><br><span class="hljs-comment"> * @dev: PCI device to be initialized</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Initialize device before it&#x27;s used by a driver. Ask low-level code</span><br><span class="hljs-comment"> * to enable I/O and memory. Wake up the device if it was suspended.</span><br><span class="hljs-comment"> * Beware, this function can fail.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note we don&#x27;t actually enable the device many times if we call</span><br><span class="hljs-comment"> * this function repeatedly (we just increment the count).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pci_enable_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *dev)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);<br>&#125;<br><br>Before touching any device registers, the driver needs to enable the PCI device by calling <span class="hljs-title function_">pci_enable_device</span><span class="hljs-params">()</span>. <br>This will:<br>1 wake up the device <span class="hljs-keyword">if</span> it was in suspended state,<br>2 allocate I/O and memory regions of the <span class="hljs-title function_">device</span> <span class="hljs-params">(<span class="hljs-keyword">if</span> BIOS did not)</span>,<br>3 allocate an <span class="hljs-title function_">IRQ</span> <span class="hljs-params">(<span class="hljs-keyword">if</span> BIOS did not)</span>.<br></code></pre></td></tr></table></figure>
<blockquote>
<p>dma_set_mask_and_coherent</p>
</blockquote>
<p>函数dma_set_mask_and_coherent()用于对dma_mask和coherent_dma_mask赋值。</p>
<p>dma_mask表示的是该设备通过DMA方式可寻址的物理地址范围，coherent_dma_mask表示所有设备通过DMA方式可寻址的公共的物理地址范围，因为不是所有的硬件设备都能够支持64bit的地址宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Set both the DMA mask and the coherent DMA mask to the same thing.</span><br><span class="hljs-comment"> * Note that we don&#x27;t check the return value from dma_set_coherent_mask()</span><br><span class="hljs-comment"> * as the DMA API guarantees that the coherent DMA mask can be set to</span><br><span class="hljs-comment"> * the same or smaller than the streaming DMA mask.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dma_set_mask_and_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, u64 mask)</span><br>&#123;<br>	<span class="hljs-type">int</span> rc = dma_set_mask(dev, mask);<br>	<span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>)<br>		dma_set_coherent_mask(dev, mask);<br>	<span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>pci_alloc_irq_vectors</p>
</blockquote>
<p>传统中断在系统初始化扫描PCI bus tree时就已自动为设备分配好中断号, 但是如果设备需要使用MSI，驱动需要进行一些额外的配置。linux内核提供pci_alloc_irq_vectors来进行MSI&#x2F;MSI-X capablity的初始化配置以及中断号分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pci_alloc_irq_vectors() - Allocate multiple device interrupt vectors</span><br><span class="hljs-comment"> * @dev:      the PCI device to operate on</span><br><span class="hljs-comment"> * @min_vecs: minimum required number of vectors (must be &gt;= 1)</span><br><span class="hljs-comment"> * @max_vecs: maximum desired number of vectors</span><br><span class="hljs-comment"> * @flags:    One or more of:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *            * %PCI_IRQ_MSIX      Allow trying MSI-X vector allocations</span><br><span class="hljs-comment"> *            * %PCI_IRQ_MSI       Allow trying MSI vector allocations</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *            * %PCI_IRQ_LEGACY    Allow trying legacy INTx interrupts, if</span><br><span class="hljs-comment"> *              and only if @min_vecs == 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *            * %PCI_IRQ_AFFINITY  Auto-manage IRQs affinity by spreading</span><br><span class="hljs-comment"> *              the vectors around available CPUs</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Allocate up to @max_vecs interrupt vectors on device. MSI-X irq</span><br><span class="hljs-comment"> * vector allocation has a higher precedence over plain MSI, which has a</span><br><span class="hljs-comment"> * higher precedence over legacy INTx emulation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Upon a successful allocation, the caller should use pci_irq_vector()</span><br><span class="hljs-comment"> * to get the Linux IRQ number to be passed to request_threaded_irq().</span><br><span class="hljs-comment"> * The driver must call pci_free_irq_vectors() on cleanup.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return: number of allocated vectors (which might be smaller than</span><br><span class="hljs-comment"> * @max_vecs), -ENOSPC if less than @min_vecs interrupt vectors are</span><br><span class="hljs-comment"> * available, other errnos otherwise.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pci_alloc_irq_vectors</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *dev, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> min_vecs,</span><br><span class="hljs-params">			  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_vecs, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> pci_alloc_irq_vectors_affinity(dev, min_vecs, max_vecs,<br>					      flags, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>小端数据读写</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> __u64 <span class="hljs-title function_">lo_hi_readq</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span><br>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> u32 __iomem *p = addr;<br>	u32 low, high;<br><br>	low = readl(p);<br>	high = readl(p + <span class="hljs-number">1</span>);<br><br>	<span class="hljs-keyword">return</span> low + ((u64)high &lt;&lt; <span class="hljs-number">32</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">lo_hi_writeq</span><span class="hljs-params">(__u64 val, <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> __iomem *addr)</span><br>&#123;<br>	writel(val, addr);<br>	writel(val &gt;&gt; <span class="hljs-number">32</span>, addr + <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来看nvme_pci_enable函数中的nvme_map_cmb</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nvme_map_cmb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span> &#123;<br>  u64 size, offset;<br>  <span class="hljs-type">resource_size_t</span> bar_size;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span> *<span class="hljs-title">pdev</span> =</span> to_pci_dev(dev-&gt;dev);<br>  <span class="hljs-type">int</span> bar;<br><br>  <span class="hljs-keyword">if</span> (dev-&gt;cmb_size) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 已经映射过，直接退出</span><br><br>  dev-&gt;cmbsz = readl(dev-&gt;bar + NVME_REG_CMBSZ);  <span class="hljs-comment">// 读取控制器内存大小</span><br>  <span class="hljs-keyword">if</span> (!dev-&gt;cmbsz) <span class="hljs-keyword">return</span>;<br>  dev-&gt;cmbloc = readl(dev-&gt;bar + NVME_REG_CMBLOC);  <span class="hljs-comment">// 读取控制器内存位置</span><br><br>  <span class="hljs-keyword">if</span> (!use_cmb_sqes) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 设置CMB映射的起始地址与大小</span><br>  size = nvme_cmb_size_unit(dev) * nvme_cmb_size(dev);<br>  offset = nvme_cmb_size_unit(dev) * NVME_CMB_OFST(dev-&gt;cmbloc);<br>  bar = NVME_CMB_BIR(dev-&gt;cmbloc);<br>  bar_size = pci_resource_len(pdev, bar);<br><br>  <span class="hljs-keyword">if</span> (offset &gt; bar_size) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Controllers may support a CMB size larger than their BAR,</span><br><span class="hljs-comment">   * for example, due to being behind a bridge. Reduce the CMB to</span><br><span class="hljs-comment">   * the reported size of the BAR</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">if</span> (size &gt; bar_size - offset) size = bar_size - offset;<br>  dev-&gt;cmb = ioremap_wc(pci_resource_start(pdev, bar) + offset, size);  <span class="hljs-comment">// 进行虚拟地址-总线地址映射</span><br>  <span class="hljs-keyword">if</span> (!dev-&gt;cmb) <span class="hljs-keyword">return</span>;<br>  dev-&gt;cmb_bus_addr = pci_bus_address(pdev, bar) + offset;  <span class="hljs-comment">// 设置CMB总线地址</span><br>  dev-&gt;cmb_size = size;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * sysfs_add_file_to_group - add an attribute file to a pre-existing group.</span><br><span class="hljs-comment">   * @kobj: object we&#x27;re acting for.</span><br><span class="hljs-comment">   * @attr: attribute descriptor.</span><br><span class="hljs-comment">   * @group: group name.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// 将一个属性attr加入kobj目录下已存在的的属性集合group</span><br>  sysfs_add_file_to_group(&amp;dev-&gt;ctrl.device-&gt;kobj, &amp;dev_attr_cmb.attr, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>CMB</p>
</blockquote>
<p>但是如果CPU将整条指令而不是指针直接写到SSD端的DRAM的话，并不耗费太多资源，此时能够节省一次PCIE往返及一次SSD控制器内部的中断处理。于是，人们就想将SSD控制器上的一小段DRAM空间映射到host物理地址空间从而可以让驱动直接写指令进去，甚至写一些数据进去也是可以的。这块被映射到host物理地址空间的DRAM空间便被称为CMB了</p>
<blockquote>
<p>ioremap_wc</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* ioremap() and friends.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* ioremap() takes a resource address, and size.  Due to the ARM memory</span><br><span class="hljs-comment">* types, it is important to use the correct ioremap() function as each</span><br><span class="hljs-comment">* mapping has specific properties.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Function		Memory type	Cacheability	Cache hint</span><br><span class="hljs-comment">* ioremap()		Device		n/a		n/a</span><br><span class="hljs-comment">* ioremap_cache()	Normal		Writeback	Read allocate</span><br><span class="hljs-comment">* ioremap_wc()		Normal		Non-cacheable	n/a</span><br><span class="hljs-comment">* ioremap_wt()		Normal		Non-cacheable	n/a</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* All device mappings have the following properties:</span><br><span class="hljs-comment">* - no access speculation</span><br><span class="hljs-comment">* - no repetition (eg, on return from an exception)</span><br><span class="hljs-comment">* - number, order and size of accesses are maintained</span><br><span class="hljs-comment">* - unaligned accesses are &quot;unpredictable&quot;</span><br><span class="hljs-comment">* - writes may be delayed before they hit the endpoint device</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* All normal memory mappings have the following properties:</span><br><span class="hljs-comment">* - reads can be repeated with no side effects</span><br><span class="hljs-comment">* - repeated reads return the last value written</span><br><span class="hljs-comment">* - reads can fetch additional locations without side effects</span><br><span class="hljs-comment">* - writes can be repeated (in certain cases) with no side effects</span><br><span class="hljs-comment">* - writes can be merged before accessing the target</span><br><span class="hljs-comment">* - unaligned accesses can be supported</span><br><span class="hljs-comment">* - ordering is not guaranteed without explicit dependencies or barrier</span><br><span class="hljs-comment">*   instructions</span><br><span class="hljs-comment">* - writes may be delayed before they hit the endpoint memory</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* The cache hint is only a performance hint: CPUs may alias these hints.</span><br><span class="hljs-comment">* Eg, a CPU not implementing read allocate but implementing write allocate</span><br><span class="hljs-comment">* will provide a write allocate mapping instead.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ioremap_wc	-	map memory into CPU space write combined</span><br><span class="hljs-comment">* @phys_addr:	bus address of the memory</span><br><span class="hljs-comment">* @size:	size of the resource to map</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* This version of ioremap ensures that the memory is marked write combining.</span><br><span class="hljs-comment">* Write combining allows faster writes to some hardware devices.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Must be freed with iounmap.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> __iomem *<span class="hljs-title function_">ioremap_wc</span><span class="hljs-params">(<span class="hljs-type">resource_size_t</span> phys_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> __ioremap_caller(phys_addr, size, _PAGE_CACHE_MODE_WC,<br>					__builtin_return_address(<span class="hljs-number">0</span>), <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="nvme-pci-configure-admin-queue"><a href="#nvme-pci-configure-admin-queue" class="headerlink" title="nvme_pci_configure_admin_queue"></a>nvme_pci_configure_admin_queue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_pci_configure_admin_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span> &#123;<br>  <span class="hljs-type">int</span> result;<br>  u32 aqa;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">nvmeq</span>;</span><br><br>  result = nvme_remap_bar(dev, db_bar_size(dev, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 重映射BAR空间（之前已映射，大概率直接返回）</span><br><br>  dev-&gt;subsystem = readl(dev-&gt;bar + NVME_REG_VS) &gt;= NVME_VS(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) ? NVME_CAP_NSSRC(dev-&gt;ctrl.cap) : <span class="hljs-number">0</span>;  <span class="hljs-comment">// NVM Subsystem Reset Supported</span><br><br>  <span class="hljs-keyword">if</span> (dev-&gt;subsystem &amp;&amp; (readl(dev-&gt;bar + NVME_REG_CSTS) &amp; NVME_CSTS_NSSRO)) writel(NVME_CSTS_NSSRO, dev-&gt;bar + NVME_REG_CSTS);  <span class="hljs-comment">// NVM Subsystem Reset Occurred</span><br><br>  result = nvme_disable_ctrl(&amp;dev-&gt;ctrl, dev-&gt;ctrl.cap);  <span class="hljs-comment">//  重置控制器</span><br><br>  result = nvme_alloc_queue(dev, <span class="hljs-number">0</span>, NVME_AQ_DEPTH);  <span class="hljs-comment">// 为admin queue分配空间</span><br><br>  nvmeq = &amp;dev-&gt;queues[<span class="hljs-number">0</span>];<br>  aqa = nvmeq-&gt;q_depth - <span class="hljs-number">1</span>;<br>  aqa |= aqa &lt;&lt; <span class="hljs-number">16</span>;<br><br>  writel(aqa, dev-&gt;bar + NVME_REG_AQA);  <span class="hljs-comment">// 同时设置admin SQ队列深度与CQ队列深度</span><br>  <span class="hljs-comment">// 设置admin SQ/CQ基址</span><br>  lo_hi_writeq(nvmeq-&gt;sq_dma_addr, dev-&gt;bar + NVME_REG_ASQ);<br>  lo_hi_writeq(nvmeq-&gt;cq_dma_addr, dev-&gt;bar + NVME_REG_ACQ);<br><br>  result = nvme_enable_ctrl(&amp;dev-&gt;ctrl, dev-&gt;ctrl.cap);  <span class="hljs-comment">// 使能控制器</span><br><br>  nvmeq-&gt;cq_vector = <span class="hljs-number">0</span>;<br>  nvme_init_queue(nvmeq, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化admin queue</span><br></code></pre></td></tr></table></figure>
<p>nvme_disable_ctrl与nvme_enable_ctrl</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">nvme_disable_ctrl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, u64 cap)</span> &#123;<br>  <span class="hljs-type">int</span> ret;<br><br>  ctrl-&gt;ctrl_config &amp;= ~NVME_CC_SHN_MASK;<br>  ctrl-&gt;ctrl_config &amp;= ~NVME_CC_ENABLE;<br>  <span class="hljs-comment">// 将Controller Configuration寄存器Enable,Shutdown Notification位重置</span><br>  ret = ctrl-&gt;ops-&gt;reg_write32(ctrl, NVME_REG_CC, ctrl-&gt;ctrl_config);  <br><br>  <span class="hljs-keyword">return</span> nvme_wait_ready(ctrl, cap, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 等待状态设置完毕</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">nvme_enable_ctrl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, u64 cap)</span> &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Default to a 4K page size, with the intention to update this</span><br><span class="hljs-comment">   * path in the future to accomodate architectures with differing</span><br><span class="hljs-comment">   * kernel and IO page sizes.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">unsigned</span> dev_page_min = NVME_CAP_MPSMIN(cap) + <span class="hljs-number">12</span>, page_shift = <span class="hljs-number">12</span>;<br>  <span class="hljs-type">int</span> ret;<br><br>  <span class="hljs-keyword">if</span> (page_shift &lt; dev_page_min) &#123;<br>    dev_err(ctrl-&gt;device, <span class="hljs-string">&quot;Minimum device page size %u too large for host (%u)\n&quot;</span>, <span class="hljs-number">1</span> &lt;&lt; dev_page_min, <span class="hljs-number">1</span> &lt;&lt; page_shift);<br>    <span class="hljs-keyword">return</span> -ENODEV;<br>  &#125;<br><br>  ctrl-&gt;page_size = <span class="hljs-number">1</span> &lt;&lt; page_shift;<br><br>  ctrl-&gt;ctrl_config = NVME_CC_CSS_NVM;                          <span class="hljs-comment">// I/O Command Set Selected设置为NVM Command Set</span><br>  ctrl-&gt;ctrl_config |= (page_shift - <span class="hljs-number">12</span>) &lt;&lt; NVME_CC_MPS_SHIFT;  <span class="hljs-comment">// 设置Memory Page Size寄存器</span><br>  ctrl-&gt;ctrl_config |= NVME_CC_AMS_RR | NVME_CC_SHN_NONE;       <span class="hljs-comment">// Arbitration Mechanism Selected 设置为Round Robin，Shutdown Notification设置为No notification; no effect</span><br>  ctrl-&gt;ctrl_config |= NVME_CC_IOSQES | NVME_CC_IOCQES;         <span class="hljs-comment">// 设置SQ为64字节，CQ为16字节</span><br>  ctrl-&gt;ctrl_config |= NVME_CC_ENABLE;                          <span class="hljs-comment">// 置位ENABLE位</span><br><br>  ret = ctrl-&gt;ops-&gt;reg_write32(ctrl, NVME_REG_CC, ctrl-&gt;ctrl_config);  <span class="hljs-comment">// 写入Controller Configuration寄存器</span><br>  <span class="hljs-keyword">return</span> nvme_wait_ready(ctrl, cap, <span class="hljs-literal">true</span>);                             <span class="hljs-comment">// 等待状态设置完毕</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_wait_ready</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_ctrl *ctrl, u64 cap, <span class="hljs-type">bool</span> enabled)</span> &#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout = ((NVME_CAP_TIMEOUT(cap) + <span class="hljs-number">1</span>) * HZ / <span class="hljs-number">2</span>) + jiffies;  <span class="hljs-comment">// 设置超时时间</span><br>  u32 csts, bit = enabled ? NVME_CSTS_RDY : <span class="hljs-number">0</span>;                               <span class="hljs-comment">// 预期值与CC.EN保持一致</span><br>  <span class="hljs-type">int</span> ret;<br><br>  <span class="hljs-keyword">while</span> ((ret = ctrl-&gt;ops-&gt;reg_read32(ctrl, NVME_REG_CSTS, &amp;csts)) == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 读取Controller Status寄存器</span><br>    <span class="hljs-keyword">if</span> (csts == ~<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -ENODEV;                                         <span class="hljs-comment">// 全F，出现错误</span><br>    <span class="hljs-keyword">if</span> ((csts &amp; NVME_CSTS_RDY) == bit) <span class="hljs-keyword">break</span>;                               <span class="hljs-comment">// 读到预期值，跳出循环</span><br><br>    msleep(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">if</span> (fatal_signal_pending(current)) <span class="hljs-keyword">return</span> -EINTR;<br>    <span class="hljs-keyword">if</span> (time_after(jiffies, timeout)) &#123;  <span class="hljs-comment">// 等待状态超时，返回错误</span><br>      dev_err(ctrl-&gt;device, <span class="hljs-string">&quot;Device not ready; aborting %s\n&quot;</span>, enabled ? <span class="hljs-string">&quot;initialisation&quot;</span> : <span class="hljs-string">&quot;reset&quot;</span>);<br>      <span class="hljs-keyword">return</span> -ENODEV;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中CC.EN与CSTS.RDY的相关描述如下：<br><img src="https://img-blog.csdnimg.cn/34987e7f18924c63afe70e003e0203e5.png" srcset="/img/loading.gif" lazyload><br><img src="https://img-blog.csdnimg.cn/ed7c8032112b466b891c08bd66509d65.png" srcset="/img/loading.gif" lazyload><br>然后是nvme_alloc_queue与nvme_init_queue</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQ_SIZE(depth) (depth * sizeof(struct nvme_command))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CQ_SIZE(depth) (depth * sizeof(struct nvme_completion))</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_alloc_sq_cmds</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev, <span class="hljs-keyword">struct</span> nvme_queue *nvmeq, <span class="hljs-type">int</span> qid, <span class="hljs-type">int</span> depth)</span> &#123;<br>  <span class="hljs-comment">/* CMB SQEs will be mapped before creation */</span><br>  <span class="hljs-keyword">if</span> (qid &amp;&amp; dev-&gt;cmb &amp;&amp; use_cmb_sqes &amp;&amp; (dev-&gt;cmbsz &amp; NVME_CMBSZ_SQS)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 使用CMB</span><br>  nvmeq-&gt;sq_cmds = dma_alloc_coherent(dev-&gt;dev, SQ_SIZE(depth), &amp;nvmeq-&gt;sq_dma_addr, GFP_KERNEL);  <span class="hljs-comment">// 为SQ创建DMA缓冲区</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_alloc_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev, <span class="hljs-type">int</span> qid, <span class="hljs-type">int</span> depth)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">nvmeq</span> =</span> &amp;dev-&gt;queues[qid];<br><br>  <span class="hljs-keyword">if</span> (dev-&gt;ctrl.queue_count &gt; qid) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 已经为该队列分配空间</span><br><br>  nvmeq-&gt;cqes = dma_zalloc_coherent(dev-&gt;dev, CQ_SIZE(depth), &amp;nvmeq-&gt;cq_dma_addr, GFP_KERNEL);  <span class="hljs-comment">// 为CQ创建DMA缓冲区</span><br><br>  nvme_alloc_sq_cmds(dev, nvmeq, qid, depth);  <span class="hljs-comment">// 如果不使用CMB，为SQ创建DMA缓冲区</span><br>  <span class="hljs-comment">// 初始化nvme_queue结构体成员</span><br>  nvmeq-&gt;q_dmadev = dev-&gt;dev;<br>  nvmeq-&gt;dev = dev;<br>  spin_lock_init(&amp;nvmeq-&gt;sq_lock);<br>  spin_lock_init(&amp;nvmeq-&gt;cq_lock);<br>  nvmeq-&gt;cq_head = <span class="hljs-number">0</span>;<br>  nvmeq-&gt;cq_phase = <span class="hljs-number">1</span>;<br>  nvmeq-&gt;q_db = &amp;dev-&gt;dbs[qid * <span class="hljs-number">2</span> * dev-&gt;db_stride];<br>  nvmeq-&gt;q_depth = depth;<br>  nvmeq-&gt;qid = qid;<br>  nvmeq-&gt;cq_vector = <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">// 队列数量加一</span><br>  dev-&gt;ctrl.queue_count++;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nvme_init_queue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_queue *nvmeq, u16 qid)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_dev</span> *<span class="hljs-title">dev</span> =</span> nvmeq-&gt;dev;<br><br>  spin_lock_irq(&amp;nvmeq-&gt;cq_lock);<br>  nvmeq-&gt;sq_tail = <span class="hljs-number">0</span>;<br>  nvmeq-&gt;cq_head = <span class="hljs-number">0</span>;<br>  nvmeq-&gt;cq_phase = <span class="hljs-number">1</span>;<br>  nvmeq-&gt;q_db = &amp;dev-&gt;dbs[qid * <span class="hljs-number">2</span> * dev-&gt;db_stride];<br>  <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)nvmeq-&gt;cqes, <span class="hljs-number">0</span>, CQ_SIZE(nvmeq-&gt;q_depth));<br>  nvme_dbbuf_init(dev, nvmeq, qid);<br>  dev-&gt;online_queues++;<br>  spin_unlock_irq(&amp;nvmeq-&gt;cq_lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于dbbuf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 分配空间</span><br>NVME_CTRL_OACS_DBBUF_SUPP = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span><br><br><span class="hljs-keyword">if</span> (dev-&gt;ctrl.oacs &amp; NVME_CTRL_OACS_DBBUF_SUPP) &#123;<br>  result = nvme_dbbuf_dma_alloc(dev);<br>  <span class="hljs-keyword">if</span> (result) dev_warn(dev-&gt;dev, <span class="hljs-string">&quot;unable to allocate dma for dbbuf\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nvme_dbbuf_dma_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev)</span> &#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mem_size = nvme_dbbuf_size(dev-&gt;db_stride);<br><br>  <span class="hljs-keyword">if</span> (dev-&gt;dbbuf_dbs) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  dev-&gt;dbbuf_dbs = dma_alloc_coherent(dev-&gt;dev, mem_size, &amp;dev-&gt;dbbuf_dbs_dma_addr, GFP_KERNEL);<br>  <span class="hljs-keyword">if</span> (!dev-&gt;dbbuf_dbs) <span class="hljs-keyword">return</span> -ENOMEM;<br>  dev-&gt;dbbuf_eis = dma_alloc_coherent(dev-&gt;dev, mem_size, &amp;dev-&gt;dbbuf_eis_dma_addr, GFP_KERNEL);<br>  <span class="hljs-keyword">if</span> (!dev-&gt;dbbuf_eis) &#123;<br>    dma_free_coherent(dev-&gt;dev, mem_size, dev-&gt;dbbuf_dbs, dev-&gt;dbbuf_dbs_dma_addr);<br>    dev-&gt;dbbuf_dbs = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> -ENOMEM;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">nvme_dbbuf_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nvme_dev *dev, <span class="hljs-keyword">struct</span> nvme_queue *nvmeq, <span class="hljs-type">int</span> qid)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!dev-&gt;dbbuf_dbs || !qid) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 若未创建dbbuf或qid为0（admin queue），直接返回</span><br><br>  nvmeq-&gt;dbbuf_sq_db = &amp;dev-&gt;dbbuf_dbs[sq_idx(qid, dev-&gt;db_stride)];<br>  nvmeq-&gt;dbbuf_cq_db = &amp;dev-&gt;dbbuf_dbs[cq_idx(qid, dev-&gt;db_stride)];<br>  nvmeq-&gt;dbbuf_sq_ei = &amp;dev-&gt;dbbuf_eis[sq_idx(qid, dev-&gt;db_stride)];<br>  nvmeq-&gt;dbbuf_cq_ei = &amp;dev-&gt;dbbuf_eis[cq_idx(qid, dev-&gt;db_stride)];<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4137d833e46f4f1ebb9fdc94d547f909.png" srcset="/img/loading.gif" lazyload><br>本文并不分析 Doorbell Buffer Config command的部分，当作不支持该命令</p>
<h4 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="请求超时相关代码"><a href="#请求超时相关代码" class="headerlink" title="请求超时相关代码"></a>请求超时相关代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// tagset赋值过程</span><br><span class="hljs-number">1493</span>  		dev-&gt;admin_tagset.ops = &amp;nvme_mq_admin_ops;<br><span class="hljs-number">1494</span>  		dev-&gt;admin_tagset.nr_hw_queues = <span class="hljs-number">1</span>;<br><span class="hljs-number">1495</span>  <br><span class="hljs-number">1496</span>  		dev-&gt;admin_tagset.queue_depth = NVME_AQ_MQ_TAG_DEPTH;<br><span class="hljs-number">1497</span>  		dev-&gt;admin_tagset.timeout = ADMIN_TIMEOUT;<br><span class="hljs-number">1498</span>  		dev-&gt;admin_tagset.numa_node = dev_to_node(dev-&gt;dev);<br><span class="hljs-number">1499</span>  		dev-&gt;admin_tagset.cmd_size = nvme_pci_cmd_size(dev, <span class="hljs-literal">false</span>);<br><span class="hljs-number">1500</span>  		dev-&gt;admin_tagset.flags = BLK_MQ_F_NO_SCHED;<br><span class="hljs-number">1501</span>  		dev-&gt;admin_tagset.driver_data = dev;<br><br><br><span class="hljs-number">2035</span>  		dev-&gt;tagset.ops = &amp;nvme_mq_ops;<br><span class="hljs-number">2036</span>  		dev-&gt;tagset.nr_hw_queues = dev-&gt;online_queues - <span class="hljs-number">1</span>;<br><span class="hljs-number">2037</span>  		dev-&gt;tagset.timeout = NVME_IO_TIMEOUT;<br><span class="hljs-number">2038</span>  		dev-&gt;tagset.numa_node = dev_to_node(dev-&gt;dev);<br><span class="hljs-number">2039</span>  		dev-&gt;tagset.queue_depth = <span class="hljs-type">min_t</span>(<span class="hljs-type">int</span>, dev-&gt;q_depth, BLK_MQ_MAX_DEPTH) - <span class="hljs-number">1</span>;<br><span class="hljs-number">2041</span>  		dev-&gt;tagset.cmd_size = nvme_pci_cmd_size(dev, <span class="hljs-literal">false</span>);<br><span class="hljs-number">2046</span>  		dev-&gt;tagset.flags = BLK_MQ_F_SHOULD_MERGE;<br><span class="hljs-number">2047</span>  		dev-&gt;tagset.driver_data = dev;<br><br><span class="hljs-comment">// timeout 相关变量</span><br><span class="hljs-number">40</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> admin_timeout = <span class="hljs-number">60</span>;<br><span class="hljs-number">41</span>  module_param(admin_timeout, uint, <span class="hljs-number">0644</span>);<br><span class="hljs-number">42</span>  MODULE_PARM_DESC(admin_timeout, <span class="hljs-string">&quot;timeout in seconds for admin commands&quot;</span>);<br><span class="hljs-number">43</span>  EXPORT_SYMBOL_GPL(admin_timeout);<br><span class="hljs-number">44</span>  <br><span class="hljs-number">45</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nvme_io_timeout = <span class="hljs-number">30</span>;<br><span class="hljs-number">46</span>  module_param_named(io_timeout, nvme_io_timeout, uint, <span class="hljs-number">0644</span>);<br><span class="hljs-number">47</span>  MODULE_PARM_DESC(io_timeout, <span class="hljs-string">&quot;timeout in seconds for I/O&quot;</span>);<br><span class="hljs-number">48</span>  EXPORT_SYMBOL_GPL(nvme_io_timeout);<br><br><span class="hljs-number">27</span>  <span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nvme_io_timeout;<br><span class="hljs-number">28</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> NVME_IO_TIMEOUT	(nvme_io_timeout * HZ)</span><br><span class="hljs-number">29</span>  <br><span class="hljs-number">30</span>  <span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> admin_timeout;<br><span class="hljs-number">31</span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ADMIN_TIMEOUT	(admin_timeout * HZ)</span><br><br><span class="hljs-comment">// 超时函数</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">blk_eh_timer_return</span> &#123;</span><br>	BLK_EH_DONE,		<span class="hljs-comment">/* drivers has completed the command */</span><br>	BLK_EH_RESET_TIMER,	<span class="hljs-comment">/* reset timer and try again */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title function_">blk_eh_timer_return</span> <span class="hljs-params">(timeout_fn)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *, <span class="hljs-type">bool</span>)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span> &#123;</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Queue request</span><br><span class="hljs-comment">	 */</span><br>	queue_rq_fn		*queue_rq;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Called on request timeout</span><br><span class="hljs-comment">	 */</span><br>	timeout_fn		*timeout;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Called to poll for completion of a specific tag.</span><br><span class="hljs-comment">	 */</span><br>	poll_fn			*poll;<br><br>	softirq_done_fn		*complete;<br>&#125;;<br><br><span class="hljs-comment">// 超时函数的赋值与调用</span><br><span class="hljs-number">1457</span>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span> <span class="hljs-title">nvme_mq_admin_ops</span> =</span> &#123;<br><span class="hljs-number">1458</span>  	.queue_rq	= nvme_queue_rq,<br><span class="hljs-number">1459</span>  	.complete	= nvme_pci_complete_rq,<br><span class="hljs-number">1460</span>  	.init_hctx	= nvme_admin_init_hctx,<br><span class="hljs-number">1461</span>  	.exit_hctx      = nvme_admin_exit_hctx,<br><span class="hljs-number">1462</span>  	.init_request	= nvme_init_request,<br><span class="hljs-number">1463</span>  	.timeout	= nvme_timeout,<br><span class="hljs-number">1464</span>  &#125;;<br><span class="hljs-number">1465</span>  <br><span class="hljs-number">1466</span>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">blk_mq_ops</span> <span class="hljs-title">nvme_mq_ops</span> =</span> &#123;<br><span class="hljs-number">1467</span>  	.queue_rq	= nvme_queue_rq,<br><span class="hljs-number">1468</span>  	.complete	= nvme_pci_complete_rq,<br><span class="hljs-number">1469</span>  	.init_hctx	= nvme_init_hctx,<br><span class="hljs-number">1470</span>  	.init_request	= nvme_init_request,<br><span class="hljs-number">1471</span>  	.map_queues	= nvme_pci_map_queues,<br><span class="hljs-number">1472</span>  	.timeout	= nvme_timeout,<br><span class="hljs-number">1473</span>  	.poll		= nvme_poll,<br><span class="hljs-number">1474</span>  &#125;;<br><br><span class="hljs-number">1128</span>  <span class="hljs-type">static</span> <span class="hljs-keyword">enum</span> blk_eh_timer_return <span class="hljs-title function_">nvme_timeout</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req, <span class="hljs-type">bool</span> reserved)</span><br>1129  &#123;<br><span class="hljs-number">1130</span>  	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_iod</span> *<span class="hljs-title">iod</span> =</span> blk_mq_rq_to_pdu(req);<br><span class="hljs-number">1131</span>  	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_queue</span> *<span class="hljs-title">nvmeq</span> =</span> iod-&gt;nvmeq;<br><span class="hljs-number">1132</span>  	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_dev</span> *<span class="hljs-title">dev</span> =</span> nvmeq-&gt;dev;<br><span class="hljs-number">1133</span>  	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span> *<span class="hljs-title">abort_req</span>;</span><br><span class="hljs-number">1134</span>  	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nvme_command</span> <span class="hljs-title">cmd</span>;</span><br><span class="hljs-number">1135</span>  	<span class="hljs-type">bool</span> shutdown = <span class="hljs-literal">false</span>;<br><span class="hljs-number">1136</span>  	u32 csts = readl(dev-&gt;bar + NVME_REG_CSTS);<br><span class="hljs-number">1137</span>  <br><span class="hljs-number">1138</span>  	<span class="hljs-comment">/* If PCI error recovery process is happening, we cannot reset or</span><br><span class="hljs-comment">1139  	 * the recovery mechanism will surely fail.</span><br><span class="hljs-comment">1140  	 */</span><br><span class="hljs-number">1141</span>  	mb();<br><span class="hljs-number">1142</span>  	<span class="hljs-keyword">if</span> (pci_channel_offline(to_pci_dev(dev-&gt;dev)))<br><span class="hljs-number">1143</span>  		<span class="hljs-keyword">return</span> BLK_EH_RESET_TIMER;<br><span class="hljs-number">1144</span>  <br><span class="hljs-number">1145</span>  	<span class="hljs-comment">/*</span><br><span class="hljs-comment">1146  	 * Reset immediately if the controller is failed</span><br><span class="hljs-comment">1147  	 */</span><br><span class="hljs-number">1148</span>  	<span class="hljs-keyword">if</span> (nvme_should_reset(dev, csts)) &#123;<br><span class="hljs-number">1149</span>  		nvme_warn_reset(dev, csts);<br><span class="hljs-number">1150</span>  		nvme_dev_disable(dev, <span class="hljs-literal">false</span>);<br><span class="hljs-number">1151</span>  		nvme_reset_ctrl(&amp;dev-&gt;ctrl);<br><span class="hljs-number">1152</span>  		<span class="hljs-keyword">return</span> BLK_EH_DONE;<br><span class="hljs-number">1153</span>  	&#125;<br><span class="hljs-number">1154</span>  <br><span class="hljs-number">1155</span>  	<span class="hljs-comment">/*</span><br><span class="hljs-comment">1156  	 * Did we miss an interrupt?</span><br><span class="hljs-comment">1157  	 */</span><br><span class="hljs-number">1158</span>  	<span class="hljs-keyword">if</span> (__nvme_poll(nvmeq, req-&gt;tag)) &#123;<br><span class="hljs-number">1159</span>  		dev_warn(dev-&gt;ctrl.device,<br><span class="hljs-number">1160</span>  			 <span class="hljs-string">&quot;I/O %d QID %d timeout, completion polled\n&quot;</span>,<br><span class="hljs-number">1161</span>  			 req-&gt;tag, nvmeq-&gt;qid);<br><span class="hljs-number">1162</span>  		<span class="hljs-keyword">return</span> BLK_EH_DONE;<br><span class="hljs-number">1163</span>  	&#125;<br><span class="hljs-comment">// 省略大部分代码</span><br><span class="hljs-number">1234</span>  &#125;<br><br><span class="hljs-comment">// 若未设置超时时间，则赋值为默认值30s</span><br>blk_mq_init_queue<br>	blk_mq_init_allocated_queue<br>			<span class="hljs-title function_">INIT_WORK</span><span class="hljs-params">(&amp;q-&gt;timeout_work, blk_mq_timeout_work)</span>;  <span class="hljs-comment">// 初始化工作项</span><br>			blk_queue_rq_timeout(q, <span class="hljs-built_in">set</span>-&gt;timeout ? <span class="hljs-built_in">set</span>-&gt;timeout : <span class="hljs-number">30</span> * HZ);	  <span class="hljs-comment">// 设置请求超时时间</span><br><br><br><span class="hljs-comment">// 检查请求是否超时并调用相应超时函数</span><br>blk_mq_timeout_work<br>	blk_mq_check_expired<br>		blk_mq_rq_timed_out  <br>		 <br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">blk_mq_rq_timed_out</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> request *req, <span class="hljs-type">bool</span> reserved)</span><br>&#123;<br>	req-&gt;rq_flags |= RQF_TIMED_OUT;<br>	<span class="hljs-keyword">if</span> (req-&gt;q-&gt;mq_ops-&gt;timeout) &#123;<br>		<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">blk_eh_timer_return</span> <span class="hljs-title">ret</span>;</span><br><br>		ret = req-&gt;q-&gt;mq_ops-&gt;timeout(req, reserved);<br>		<span class="hljs-keyword">if</span> (ret == BLK_EH_DONE)<br>			<span class="hljs-keyword">return</span>;<br>		WARN_ON_ONCE(ret != BLK_EH_RESET_TIMER);<br>	&#125;<br><br>	blk_add_timer(req);<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="category-chain-item">学习记录</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/zns-ssd-femu-nvme-spdk-dpdk/" class="category-chain-item">zns ssd-femu-nvme-spdk-dpdk</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/nvme%E9%A9%B1%E5%8A%A8/" class="print-no-link">#nvme驱动</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/linux%20UIO%E9%A9%B1%E5%8A%A8%E5%AE%9E%E8%B7%B5.html" title="linux UIO驱动实践">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">linux UIO驱动实践</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/leetcode%E8%AE%B0%E5%BD%952.html" title="leetcode记录2">
                        <span class="hidden-mobile">leetcode记录2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz","appKey":"0e2MMh7ddBCGGytOe9UEy5NP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"https://uu0wegco.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
