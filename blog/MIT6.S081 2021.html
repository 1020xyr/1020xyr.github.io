<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/nano.jpg"><link rel="icon" href="/img/nano.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="最佳损友1020"><meta name="keywords" content=""><meta name="description" content="There is a saying in computer systems that any systems problem can be solved with a level of indirection.  6.S081 lab地址 推荐博客：二十八画生征友：一起来通关6.S081&#x2F;6.828吧~ piazza课程主页：https:&#x2F;&#x2F;piazza.com&#x2F;mooc_se"><meta property="og:type" content="article"><meta property="og:title" content="MIT6.S081 2021"><meta property="og:url" content="https://www.jiasun.top/blog/MIT6.S081%202021.html"><meta property="og:site_name" content="最佳损友1020’s Blog"><meta property="og:description" content="There is a saying in computer systems that any systems problem can be solved with a level of indirection.  6.S081 lab地址 推荐博客：二十八画生征友：一起来通关6.S081&#x2F;6.828吧~ piazza课程主页：https:&#x2F;&#x2F;piazza.com&#x2F;mooc_se"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/881c3b87741c43dfa749a98eedb20552.png"><meta property="article:published_time" content="2022-04-04T15:14:38.000Z"><meta property="article:modified_time" content="2023-10-31T14:45:58.967Z"><meta property="article:author" content="最佳损友1020"><meta property="article:tag" content="MIT6.S081 file system traps Copy-on-Write"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/881c3b87741c43dfa749a98eedb20552.png"><title>MIT6.S081 2021 - 最佳损友1020’s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/csdn.css"><link rel="stylesheet" href="/css/top.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.jiasun.top",root:"/",version:"1.9.5-a",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"n227FxNJCTncCeI3DrGx7MnC-gzGzoHsz",app_key:"ljkRZDiTtVmjn5mpaQmpFqgv",server_url:"https://n227fxnj.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>最佳损友1020</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="MIT6.S081 2021"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-04-04 23:14" pubdate>2022年4月4日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 42k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 353 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">MIT6.S081 2021</h1><div class="markdown-body"><meta name="referrer" content="no-referrer"><blockquote><p>There is a saying in computer systems that any systems problem can be solved with a level of indirection.</p></blockquote><p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2021/tools.html">6.S081 lab地址</a></p><p>推荐博客：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/251366985">二十八画生征友：一起来通关6.S081&#x2F;6.828吧~</a></p><p>piazza课程主页：<a target="_blank" rel="noopener" href="https://piazza.com/mooc_self-learning_university/fall2020/6s081">https://piazza.com/mooc_self-learning_university&#x2F;fall2020&#x2F;6s081</a><br>access code: 6s081</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><strong>虚拟机基本配置</strong><br>下载Ubuntu镜像<a target="_blank" rel="noopener" href="https://repo.huaweicloud.com/ubuntu-releases/20.04/">华为镜像站</a>， 在software&amp;update中修改软件源（我选的是阿里源）。<br>更新软件：apt-get update &amp; apt-get upgrade<br>创建root用户 : sudo passwd root<br>安装open-vm-tools-desktop 支持宿主机 虚拟机之间复制粘贴<br><strong>设置ssh远程登录及公钥登录登录</strong><br>安装ssh相关服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install openssh-client openssh-server <br></code></pre></td></tr></table></figure><p>修改ssh配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Port 22<br>PermitRootLogin <span class="hljs-built_in">yes</span><br>PubkeyAuthentication <span class="hljs-built_in">yes</span><br>PasswordAuthentication <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>将公钥添加到authorized_keys中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit pub <span class="hljs-comment"># 复制粘贴宿主机公钥</span><br><span class="hljs-built_in">mkdir</span> ~/.ssh <span class="hljs-comment"># 其中~为你想用公钥登录的用户目录，我直接在root用户下创建</span><br><span class="hljs-built_in">cat</span> pub &gt;&gt; ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br>sudo service sshd restart<br></code></pre></td></tr></table></figure><p><strong>vscode远程登录</strong><br>安装Remote-ssh插件-》点击左下角图标-》Connect to Host-》Configure SSH Hosts<br>新建一段为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host 6.081<br>  HostName 192.168.252.135 <br>  Port 22<br>  User root<br></code></pre></td></tr></table></figure><p>虚拟机IP地址，使用ifconfig查看<br>而后直接Connect to Host登录即可</p><p>安装实验工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu <br></code></pre></td></tr></table></figure><p><mark>后面发现在云服务器上安装一下qemu就好了，没必要用VMware。。</mark><br>vscode crtl + p快捷键被占用，修改crtl + p快捷方式<br>退出qemu两种方法：</p><ol><li>在另一个终端中输入 killall qemu-system-arm（网上的方法，我试着不行，使用ps -A | grep qemu找到进程id，而后kill -9 pid杀死进程）</li><li>在 qemu 中 输入ctrl+a 抬起后，再输入’x’。</li></ol><h1 id="Xv6-and-Unix-utilities"><a href="#Xv6-and-Unix-utilities" class="headerlink" title="Xv6 and Unix utilities"></a>Xv6 and Unix utilities</h1><h2 id="vscode格式化头文件排序问题"><a href="#vscode格式化头文件排序问题" class="headerlink" title="vscode格式化头文件排序问题"></a>vscode格式化头文件排序问题</h2><p>由于设置了保存时自动格式化，保存时头文件会自动排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-comment">// 变成了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-comment">// 使得stat.h中uint未声明</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br>  <span class="hljs-type">int</span> dev;     <span class="hljs-comment">// File system&#x27;s disk device</span><br>  uint ino;    <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">short</span> type;  <span class="hljs-comment">// Type of file</span><br>  <span class="hljs-type">short</span> nlink; <span class="hljs-comment">// Number of links to file</span><br>  uint64 size; <span class="hljs-comment">// Size of file in bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>解决：将Clang_format_sort Include改成false</p><h2 id="以地址空间的视角看待变量"><a href="#以地址空间的视角看待变量" class="headerlink" title="以地址空间的视角看待变量"></a>以地址空间的视角看待变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> number<br>res = read(read_fd, &amp;number, <span class="hljs-number">4</span>);<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">char</span> number[<span class="hljs-number">4</span>]<br>res = read(read_fd, number, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b589ac9f039b40ddaaf89b035895c55d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" srcset="/img/loading.gif" lazyload><br>把普通的变量当作数组，很巧妙的视角。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>fmtname函数</strong><br>ls.c中fmtname函数在末尾填充空格，find.c使用这个函数时需换成在末尾加上’\0’</p><p><strong>warning:suggest parentheses around assignment used as truth value</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(res = <span class="hljs-built_in">func</span>())&#123;<br>&#125;<br><span class="hljs-comment">// 改成</span><br><span class="hljs-keyword">while</span>((res = <span class="hljs-built_in">func</span>()))&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>加一个括号括起来就可以了</p><p><strong>a label can only be part of a statement and a declaration is not a statement</strong><br>在写代码的时候，变量的声明不应该出现在label之后。中间加上大括号即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">case</span> T_FILE: <br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// 改成</span><br><span class="hljs-keyword">case</span> T_FILE:&#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-keyword">break</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p><strong>xargs</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>*<br><span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> max)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, cc;<br>  <span class="hljs-type">char</span> c;<br><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i+<span class="hljs-number">1</span> &lt; max; )&#123;<br>    cc = read(<span class="hljs-number">0</span>, &amp;c, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(cc &lt; <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    buf[i++] = c;<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == <span class="hljs-string">&#x27;\r&#x27;</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个部分是耗时最久的，刚开始我没理解题目意思，一直打算<mark>按空格分割字符串，将其拆分成多行</mark>，使用strtok函数发现并没有提供，而动态数组也不知道咋申请，如果用定长的二维数组又觉得太奇怪，故一直卡在这了。后面发现原来<mark>将参数当成一行就行了</mark>。我又直接把系统gets函数拿来用，没有发现gets函数最后还是把’\n’放在字符串里面了，使得一直显示如下的错误。所以说与其抄系统的代码，不如自己写一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">$ sh &lt; xargstest.sh<br>$ $ $ $ $ $ ./a/b <span class="hljs-comment">// 自己测试的输出</span><br><br>grep: cannot open ./a/b <br><br>./c/b	<span class="hljs-comment">// 自己测试的输出</span><br><br>grep: cannot open ./c/b<br><br>./b    <span class="hljs-comment">// 自己测试的输出</span><br><br>grep: cannot open ./b<br></code></pre></td></tr></table></figure><p>我自己实现的gets函数如下，如果不设返回值，单以字符串第一位是否’\0’判断是否结束，则\n\n会被理解为结束，故设置返回值，当读到文件末尾时返回-1。<br>字符串长度为0且返回值为-1时表示参数读取完毕</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_gets</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> max)</span> &#123;  <span class="hljs-comment">//读取字符串，读到文件末尾时返回-1</span><br>  <span class="hljs-type">int</span> i, cc;<br>  <span class="hljs-type">char</span> c;<br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; max;) &#123;<br>    cc = read(<span class="hljs-number">0</span>, &amp;c, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (cc &lt; <span class="hljs-number">1</span>) &#123;<br>      res = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">break</span>;<br>    buf[i++] = c;<br>  &#125;<br>  buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过截图<br><img src="https://img-blog.csdnimg.cn/d43168e2e337412d8406207543f85c2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_16,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload></p><h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><p>sleep</p><blockquote><p>Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user&#x2F;sleep.c.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 参数格式不对</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep ticks\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 将字符串转换成整数</span><br>  <span class="hljs-type">int</span> res = sleep(ticks);<br>  <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>pingpong</p><blockquote><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where<pid>is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file user&#x2F;pingpong.c.</pid></pid></pid></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">char</span> msg = <span class="hljs-string">&#x27;a&#x27;</span>;<br>  <span class="hljs-type">char</span> buf;<br><br>  pipe(p);<br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    read(p[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 读取字符</span><br>    <span class="hljs-type">int</span> pid = getpid();<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%d: received ping\n&quot;</span>, pid);<br>    write(p[<span class="hljs-number">1</span>], &amp;buf, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 向管道写入相同字符</span><br>    close(p[<span class="hljs-number">0</span>]);           <span class="hljs-comment">// 关闭读端</span><br>    close(p[<span class="hljs-number">1</span>]);           <span class="hljs-comment">// 关闭写端</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    write(p[<span class="hljs-number">1</span>], &amp;msg, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 向管道写入字符</span><br>    read(p[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 读取字符</span><br>    <span class="hljs-type">int</span> pid = getpid();<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%d: received pong\n&quot;</span>, pid);<br>    close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 关闭读端</span><br>    close(p[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 关闭写端</span><br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>primes</p><blockquote><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user&#x2F;primes.c.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> read_fd, <span class="hljs-type">int</span> write_fd)</span> &#123;<br>  close(write_fd);<br>  <span class="hljs-type">int</span> first_number;<br>  <span class="hljs-type">int</span> other_number;<br>  <span class="hljs-comment">// 读取第一个数字，作为素数</span><br>  <span class="hljs-type">int</span> res = read(read_fd, &amp;first_number, <span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 管道关闭，立即退出进程</span><br>    close(read_fd);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 创建子进程</span><br>      func(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      close(p[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 读取其他数字，若不被第一个数字整除，则传给子进程</span><br>        res = read(read_fd, &amp;other_number, <span class="hljs-number">4</span>);<br>        <span class="hljs-comment">// 管道关闭，输出第一个数字后等待子进程退出，下列语句的顺序很重要</span><br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;prime %d\n&quot;</span>, first_number);<br>          close(p[<span class="hljs-number">1</span>]);<br>          wait((<span class="hljs-type">int</span> *)<span class="hljs-number">0</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (other_number % first_number != <span class="hljs-number">0</span>) &#123;<br>            write(p[<span class="hljs-number">1</span>], &amp;other_number, <span class="hljs-number">4</span>);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>  pipe(p);<br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    func(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    close(p[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;  <span class="hljs-comment">// 将数字传给子进程</span><br>      write(p[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-number">4</span>);<br>    &#125;<br>    close(p[<span class="hljs-number">1</span>]);<br>    wait((<span class="hljs-type">int</span> *)<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>find</p><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user&#x2F;find.c.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">fmtname</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[DIRSIZ + <span class="hljs-number">1</span>];<br>  <span class="hljs-type">char</span> *p;<br><br>  <span class="hljs-comment">// Find first character after last slash.</span><br>  <span class="hljs-keyword">for</span> (p = path + <span class="hljs-built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="hljs-string">&#x27;/&#x27;</span>; p--)<br>    ;<br>  p++;<br><br>  uint name_len = <span class="hljs-built_in">strlen</span>(p);<br>  <span class="hljs-comment">// Return blank-padded name.</span><br>  <span class="hljs-keyword">if</span> (name_len &gt;= DIRSIZ) <span class="hljs-keyword">return</span> p;<br>  memmove(buf, p, <span class="hljs-built_in">strlen</span>(p));<br>  buf[name_len] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 末尾加上&#x27;\0&#x27;</span><br>  <span class="hljs-keyword">return</span> buf;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target_filename)</span> &#123;<br>  <span class="hljs-comment">// printf(&quot;test1: %s %s\n&quot;, path, target_filename);</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>  <span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (st.type) &#123;<br>    <span class="hljs-keyword">case</span> T_FILE: &#123;<br>      <span class="hljs-type">char</span> *filename = fmtname(path);<br>      <span class="hljs-comment">// printf(&quot;test2: %s\n&quot;, filename);</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(filename, target_filename) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> T_DIR:<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-built_in">strcpy</span>(buf, path);<br>      p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>      *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>      <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de)) &#123;<br>        <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        memmove(p, de.name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断是否为.或..</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>          find(buf, target_filename);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  close(fd);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find path target_filename\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>xargs</p><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user&#x2F;xargs.c.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EXTRA_ARG_LEN 100</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">my_gets</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">int</span> max)</span> &#123;  <span class="hljs-comment">//读取字符串，读到文件末尾时返回-1</span><br>  <span class="hljs-type">int</span> i, cc;<br>  <span class="hljs-type">char</span> c;<br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; max;) &#123;<br>    cc = read(<span class="hljs-number">0</span>, &amp;c, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (cc &lt; <span class="hljs-number">1</span>) &#123;<br>      res = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">break</span>;<br>    buf[i++] = c;<br>  &#125;<br>  buf[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>  <span class="hljs-type">char</span> extra_args[MAX_EXTRA_ARG_LEN];<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> res = my_gets(extra_args, MAX_EXTRA_ARG_LEN);<br>    <span class="hljs-comment">// 双重判断，避免\n\n的情况</span><br>    <span class="hljs-keyword">if</span> (extra_args[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; res == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 此时argv[0]为xargs，需将参数整体往前移动一位</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc - <span class="hljs-number">1</span>; i++) &#123;<br>        argv[i] = argv[i + <span class="hljs-number">1</span>];<br>      &#125;<br>      argv[argc - <span class="hljs-number">1</span>] = extra_args;  <span class="hljs-comment">// 设置额外参数</span><br>      exec(argv[<span class="hljs-number">0</span>], argv);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="system-calls"><a href="#system-calls" class="headerlink" title="system calls"></a>system calls</h1><h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel&#x2F;syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>trace调用过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">trace(atoi(argv[<span class="hljs-number">1</span>]))-&gt;.global trace-&gt;syscall-&gt;sys_trace-&gt;syscall<br></code></pre></td></tr></table></figure><p>首先在用户空间调用trace函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">char</span> *nargv[MAXARG];<br><br>  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span> || (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-string">&#x27;9&#x27;</span>))&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (trace(atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;<br>    nargv[i<span class="hljs-number">-2</span>] = argv[i];<br>  &#125;<br>  exec(nargv[<span class="hljs-number">0</span>], nargv);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">在user/user.h文件中加入函数声明<br><span class="hljs-type">int</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br>此时可以通过编译过程，只需链接时找到trace函数定义即可<br></code></pre></td></tr></table></figure><p>trace函数定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">在kernel/syscall.h中定义调用号<br><span class="hljs-comment">#define SYS_trace 22</span><br><br>usys.pl插入函数入口点<br>entry(<span class="hljs-string">&quot;trace&quot;</span>);<br><br>usys.S生成代码片段<br>.global trace<br>trace:<br> li a7, SYS_trace <span class="hljs-comment"># 将系统调用号存入a7中</span><br> ecall <span class="hljs-comment"># 陷入内核，跳转到syscall函数</span><br> ret <br></code></pre></td></tr></table></figure><p>内核函数调用流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; 	<span class="hljs-comment">// sys_trace函数在别处定义</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br>    [SYS_fork] sys_fork,   [SYS_exit] sys_exit,     [SYS_wait] sys_wait,<br>    [SYS_pipe] sys_pipe,   [SYS_read] sys_read,     [SYS_kill] sys_kill,<br>    [SYS_exec] sys_exec,   [SYS_fstat] sys_fstat,   [SYS_chdir] sys_chdir,<br>    [SYS_dup] sys_dup,     [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk,<br>    [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,<br>    [SYS_write] sys_write, [SYS_mknod] sys_mknod,   [SYS_unlink] sys_unlink,<br>    [SYS_link] sys_link,   [SYS_mkdir] sys_mkdir,   [SYS_close] sys_close,<br>    [SYS_trace] sys_trace,<br>&#125;;	<span class="hljs-comment">//  增加一条[SYS_trace] sys_trace</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *sys_call_names[] = &#123;<br>    [SYS_fork] <span class="hljs-string">&quot;fork&quot;</span>,   [SYS_exit] <span class="hljs-string">&quot;exit&quot;</span>,     [SYS_wait] <span class="hljs-string">&quot;wait&quot;</span>,<br>    [SYS_pipe] <span class="hljs-string">&quot;pipe&quot;</span>,   [SYS_read] <span class="hljs-string">&quot;read&quot;</span>,     [SYS_kill] <span class="hljs-string">&quot;kill&quot;</span>,<br>    [SYS_exec] <span class="hljs-string">&quot;exec&quot;</span>,   [SYS_fstat] <span class="hljs-string">&quot;fstat&quot;</span>,   [SYS_chdir] <span class="hljs-string">&quot;chdir&quot;</span>,<br>    [SYS_dup] <span class="hljs-string">&quot;dup&quot;</span>,     [SYS_getpid] <span class="hljs-string">&quot;getpid&quot;</span>, [SYS_sbrk] <span class="hljs-string">&quot;sbrk&quot;</span>,<br>    [SYS_sleep] <span class="hljs-string">&quot;sleep&quot;</span>, [SYS_uptime] <span class="hljs-string">&quot;uptime&quot;</span>, [SYS_open] <span class="hljs-string">&quot;open&quot;</span>,<br>    [SYS_write] <span class="hljs-string">&quot;write&quot;</span>, [SYS_mknod] <span class="hljs-string">&quot;mknod&quot;</span>,   [SYS_unlink] <span class="hljs-string">&quot;unlink&quot;</span>,<br>    [SYS_link] <span class="hljs-string">&quot;link&quot;</span>,   [SYS_mkdir] <span class="hljs-string">&quot;mkdir&quot;</span>,   [SYS_close] <span class="hljs-string">&quot;close&quot;</span>,<br>    [SYS_trace] <span class="hljs-string">&quot;trace&quot;</span>,<br>&#125;;	<span class="hljs-comment">// 系统调用对应的名字</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num](); 	<span class="hljs-comment">// 执行sys_trace()</span><br>    <span class="hljs-type">int</span> test_bit = p-&gt;trace_mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num);<br>    <span class="hljs-keyword">if</span> (test_bit) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sys_call_names[num],<br>             p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>, p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sys_trace执行流程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint64 <span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;	<span class="hljs-comment">// 将系统调用参数存于各个寄存器</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">switch</span> (n) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">argint</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> *ip)</span> &#123;<br>  *ip = argraw(n);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>uint64 <span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> mask;<br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;	<span class="hljs-comment">// 获取参数</span><br>  myproc()-&gt;trace_mask = mask;	<span class="hljs-comment">// 设置trace_mask</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中trace_mask为proc结构体成员，可以在allocproc函数中将trace_mask初始化为0（不一定需要）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>  <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">void</span> *chan;            <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed;            <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-type">int</span> xstate;            <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-type">int</span> pid;               <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>  <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;                <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                    <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-type">pagetable_t</span> pagetable;        <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span>  <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>       <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>   <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>            <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];                <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-type">int</span> trace_mask;               <span class="hljs-comment">// add trace mask</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc *<span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span> (p-&gt;state == UNUSED) &#123;<br>      <span class="hljs-keyword">goto</span> found;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>found:<br>  p-&gt;pid = allocpid();<br>  p-&gt;state = USED;<br>  p-&gt;trace_mask = <span class="hljs-number">0</span>;	<span class="hljs-comment">// init trace_mask</span><br>  <span class="hljs-comment">// Allocate a trapframe page.</span><br>  <span class="hljs-keyword">if</span> ((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>) &#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);<br>  <span class="hljs-keyword">if</span> (p-&gt;pagetable == <span class="hljs-number">0</span>) &#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br>  <span class="hljs-comment">// which returns to user space.</span><br>  <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>  p-&gt;context.ra = (uint64)forkret;<br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;<br><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>当进程创建子进程时，复制trace_mask</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span> ((np = allocproc()) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span> (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>) &#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  <span class="hljs-comment">//  copy the trace mask from the parent to the child process.</span><br>  np-&gt;trace_mask = p-&gt;trace_mask;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span> (p-&gt;ofile[i]) np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  release(&amp;np-&gt;lock);<br><br>  acquire(&amp;wait_lock);<br>  np-&gt;parent = p;<br>  release(&amp;wait_lock);<br><br>  acquire(&amp;np-&gt;lock);<br>  np-&gt;state = RUNNABLE;<br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着看syscall函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();		<span class="hljs-comment">// a0存储返回值</span><br>    <span class="hljs-type">int</span> test_bit = p-&gt;trace_mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num);	<span class="hljs-comment">// 取出系统调用号相应位</span><br>    <span class="hljs-keyword">if</span> (test_bit) &#123;	 <span class="hljs-comment">// 如果不为0则输出系统调用相关信息</span><br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sys_call_names[num],<br>             p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>, p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在测试trace时，总是出现超时的情况，显示MISSING ALL TESTS PASSED<br>修改gradelib.py中的timeout，将30改成100。测试通过！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_qemu</span>(<span class="hljs-params">self, *monitors, **kw</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Run a QEMU-based test.  monitors should functions that will</span><br><span class="hljs-string">    be called with this Runner instance once QEMU and GDB are</span><br><span class="hljs-string">    started.  Typically, they should register callbacks that throw</span><br><span class="hljs-string">    TerminateTest when stop events occur.  The target_base</span><br><span class="hljs-string">    argument gives the make target to run.  The make_args argument</span><br><span class="hljs-string">    should be a list of additional arguments to pass to make.  The</span><br><span class="hljs-string">    timeout argument bounds how long to run before returning.&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_qemu_kw</span>(<span class="hljs-params">target_base=<span class="hljs-string">&quot;qemu&quot;</span>, make_args=[], timeout=<span class="hljs-number">100</span></span>):<br>        <span class="hljs-keyword">return</span> target_base, make_args, timeout<br>    target_base, make_args, timeout = run_qemu_kw(**kw)<br></code></pre></td></tr></table></figure><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><blockquote><p>In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel&#x2F;sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p></blockquote><p>sysinfo过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在用户空间调用sysinfo</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sysinfo *info)</span> &#123;<br>  <span class="hljs-keyword">if</span> (sysinfo(info) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;FAIL: sysinfo failed&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br>user/user.h头文件中加入sysinfo声明<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sysinfo*)</span>;<br></code></pre></td></tr></table></figure><p>编译过程完成，链接时寻找sysinfo实际定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">kernel/syscall.h头文件插入系统调用号<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_sysinfo 23</span><br><br>usys.pl插入函数入口点<br>entry(<span class="hljs-string">&quot;sysinfo&quot;</span>);<br><br>生成汇编代码：<br>.global sysinfo<br>sysinfo:<br> li a7, SYS_sysinfo<br> ecall<br> ret<br></code></pre></td></tr></table></figure><p>内核函数调用过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// syscall.c</span><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;	<span class="hljs-comment">// 实际的系统调用函数,在sysproc.c中定义</span><br><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br>    [SYS_fork] sys_fork,   [SYS_exit] sys_exit,     [SYS_wait] sys_wait,<br>    [SYS_pipe] sys_pipe,   [SYS_read] sys_read,     [SYS_kill] sys_kill,<br>    [SYS_exec] sys_exec,   [SYS_fstat] sys_fstat,   [SYS_chdir] sys_chdir,<br>    [SYS_dup] sys_dup,     [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk,<br>    [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open,<br>    [SYS_write] sys_write, [SYS_mknod] sys_mknod,   [SYS_unlink] sys_unlink,<br>    [SYS_link] sys_link,   [SYS_mkdir] sys_mkdir,   [SYS_close] sys_close,<br>    [SYS_trace] sys_trace, [SYS_sysinfo] sys_sysinfo,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *sys_call_names[] = &#123;<br>    [SYS_fork] <span class="hljs-string">&quot;fork&quot;</span>,   [SYS_exit] <span class="hljs-string">&quot;exit&quot;</span>,     [SYS_wait] <span class="hljs-string">&quot;wait&quot;</span>,<br>    [SYS_pipe] <span class="hljs-string">&quot;pipe&quot;</span>,   [SYS_read] <span class="hljs-string">&quot;read&quot;</span>,     [SYS_kill] <span class="hljs-string">&quot;kill&quot;</span>,<br>    [SYS_exec] <span class="hljs-string">&quot;exec&quot;</span>,   [SYS_fstat] <span class="hljs-string">&quot;fstat&quot;</span>,   [SYS_chdir] <span class="hljs-string">&quot;chdir&quot;</span>,<br>    [SYS_dup] <span class="hljs-string">&quot;dup&quot;</span>,     [SYS_getpid] <span class="hljs-string">&quot;getpid&quot;</span>, [SYS_sbrk] <span class="hljs-string">&quot;sbrk&quot;</span>,<br>    [SYS_sleep] <span class="hljs-string">&quot;sleep&quot;</span>, [SYS_uptime] <span class="hljs-string">&quot;uptime&quot;</span>, [SYS_open] <span class="hljs-string">&quot;open&quot;</span>,<br>    [SYS_write] <span class="hljs-string">&quot;write&quot;</span>, [SYS_mknod] <span class="hljs-string">&quot;mknod&quot;</span>,   [SYS_unlink] <span class="hljs-string">&quot;unlink&quot;</span>,<br>    [SYS_link] <span class="hljs-string">&quot;link&quot;</span>,   [SYS_mkdir] <span class="hljs-string">&quot;mkdir&quot;</span>,   [SYS_close] <span class="hljs-string">&quot;close&quot;</span>,<br>    [SYS_trace] <span class="hljs-string">&quot;trace&quot;</span>, [SYS_sysinfo] <span class="hljs-string">&quot;sysinfo&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>sys_sysinfo函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sysproc.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sysinfo.h&quot;</span> <span class="hljs-comment">// 导入struct sysinfo结构体定义</span></span><br><br>uint64 <span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  uint64 up_sysinfo;  <span class="hljs-comment">// user pointer to struct sysinfo</span><br>  <span class="hljs-comment">// 与trace调用中的argint类似，指针变量同样存储一个整数，只不过这个整数为另一个变量的地址</span><br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;up_sysinfo) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;	<br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>  info.freemem = free_memory_amount();		<span class="hljs-comment">// 计算空余内存</span><br>  info.nproc = live_process_number();		<span class="hljs-comment">// 计算使用中的进程数</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, up_sysinfo, (<span class="hljs-type">char</span> *)&amp;info, <span class="hljs-keyword">sizeof</span>(info)) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个统计函数的定义如下，研究同文件中其他函数可得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">free_memory_amount</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  uint64 cnt = <span class="hljs-number">0</span>;<br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">while</span> (r)<br>  &#123;<br>    cnt++;<br>    r = r-&gt;next;<br>  &#125;<br>  release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> cnt * PGSIZE;<br>&#125;<br><br>uint64 <span class="hljs-title function_">live_process_number</span><span class="hljs-params">()</span> &#123;<br>  uint64 cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span> (p-&gt;state != UNUSED) &#123;<br>      cnt++;<br>    &#125;<br>    release(&amp;p-&gt;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-comment">// 为了使用这两个函数，将其函数声明放在defs.h中</span><br><span class="hljs-comment">// kalloc.c</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">kinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>uint64 <span class="hljs-title function_">free_memory_amount</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// proc.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cpuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">growproc</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">proc_mapstacks</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span>)</span>;<br><span class="hljs-type">pagetable_t</span> <span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">proc_freepagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span>, uint64)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-keyword">struct</span> cpu* <span class="hljs-title function_">mycpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">struct</span> cpu* <span class="hljs-title function_">getmycpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">struct</span> proc* <span class="hljs-title function_">myproc</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">procinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((<span class="hljs-keyword">noreturn</span>))</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-keyword">struct</span> spinlock*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(uint64)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">either_copyout</span><span class="hljs-params">(<span class="hljs-type">int</span> user_dst, uint64 dst, <span class="hljs-type">void</span>* src, uint64 len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">either_copyin</span><span class="hljs-params">(<span class="hljs-type">void</span>* dst, <span class="hljs-type">int</span> user_src, uint64 src, uint64 len)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">procdump</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>uint64 <span class="hljs-title function_">live_process_number</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>简单看一下copyout函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span><br><br><span class="hljs-comment">// Copy from kernel to user.</span><br><span class="hljs-comment">// Copy len bytes from src to virtual address dstva in a given page table.</span><br><span class="hljs-comment">// Return 0 on success, -1 on error.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">copyout</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 dstva, <span class="hljs-type">char</span> *src, uint64 len)</span><br>&#123;<br>  uint64 n, va0, pa0;<br><br>  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>    va0 = PGROUNDDOWN(dstva);  			<span class="hljs-comment">// 获得逻辑页号</span><br>    pa0 = walkaddr(pagetable, va0);		<span class="hljs-comment">// 逻辑页号转换成物理页号</span><br>    <span class="hljs-keyword">if</span>(pa0 == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    n = PGSIZE - (dstva - va0);<br>    <span class="hljs-keyword">if</span>(n &gt; len)<br>      n = len;<br>    <span class="hljs-comment">// pa0 物理页号 + dstva - va0 页内偏移地址  = 物理地址 </span><br>    memmove((<span class="hljs-type">void</span> *)(pa0 + (dstva - va0)), src, n);	<br><br>    len -= n;<br>    src += n;<br>    dstva = va0 + PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试通过截图<br><img src="https://img-blog.csdnimg.cn/96d799887c2742829be7615e8ebafe58.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyA5L2z5o2f5Y-LMTAyMA==,size_15,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload></p><h1 id="page-tables"><a href="#page-tables" class="headerlink" title="page tables"></a>page tables</h1><p>在做实验之前推荐阅读《深入理解linux内核》第一章，隔了很长时间重新写这个实验，之前看的xv6 book和代码全忘光了，但也懒得再看一遍了。<br>阅读xv6 book，最主要就是搞懂书中几张图的含义<br><img src="https://img-blog.csdnimg.cn/f6eb42bc8d8f4a0a8b28517fb8a98947.png" srcset="/img/loading.gif" lazyload><br>第一张图可以看出虚拟地址为64位，物理地址为56位，页大小为4kb<br><img src="https://img-blog.csdnimg.cn/788cffeb9a144c609d9d8560377d5b86.png" srcset="/img/loading.gif" lazyload><br>第二张图可以看出使用了3级页表，虚拟地址中使用39位用于寻址，其中27位用于页的寻址，12用作页偏移量。每一页表占用空间为一页（4KB），总共有512个表项，每一个表项占用8B（64位），其中10字节保留，44字节指向下一物理页，该物理页有可能是页表，有可能是存储真实数据的页，12位存储标志位。U代表用户态是否可以访问，X表示是否能以解释为指令执行，V表示是否有效，即是否发生缺页。<br><img src="https://img-blog.csdnimg.cn/3ecc7e2db78043ec9d607bde3c1c7e18.png" srcset="/img/loading.gif" lazyload><br>第三张图为内核地址空间与物理内存的映射关系，可以对照这张图阅读memlayout.h vm.c的代码<br><img src="https://img-blog.csdnimg.cn/43465ff311be45a58f0d82524d6fe24b.png" srcset="/img/loading.gif" lazyload><br>第四张图为用户地址空间分布，书中的其他内容我全忘了，毕竟是英文书籍。。。<br>大致阅读kern&#x2F;vm.c代码，对walk mappages进行简要分析（页表的建立与查询）<br><strong>要了解函数功能最快的方式就是看其最简单的分支</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Return the address of the PTE in page table pagetable</span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,</span><br><span class="hljs-comment">// create any required page-table pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The risc-v Sv39 scheme has three levels of page-table</span><br><span class="hljs-comment">// pages. A page-table page contains 512 64-bit PTEs.</span><br><span class="hljs-comment">// A 64-bit virtual address is split into five fields:</span><br><span class="hljs-comment">//   39..63 -- must be zero.</span><br><span class="hljs-comment">//   30..38 -- 9 bits of level-2 index.</span><br><span class="hljs-comment">//   21..29 -- 9 bits of level-1 index.</span><br><span class="hljs-comment">//   12..20 -- 9 bits of level-0 index.</span><br><span class="hljs-comment">//    0..11 -- 12 bits of byte offset within the page.</span><br><span class="hljs-function"><span class="hljs-type">pte_t</span> *<span class="hljs-title">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (va &gt;= MAXVA) <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[<span class="hljs-built_in">PX</span>(level, va)];<br>    <span class="hljs-keyword">if</span> (*pte &amp; PTE_V) &#123;<br>      pagetable = (<span class="hljs-type">pagetable_t</span>)<span class="hljs-built_in">PTE2PA</span>(*pte);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (!alloc || (pagetable = (<span class="hljs-type">pde_t</span> *)<span class="hljs-built_in">kalloc</span>()) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>      *pte = <span class="hljs-built_in">PA2PTE</span>(pagetable) | PTE_V;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &amp;pagetable[<span class="hljs-built_in">PX</span>(<span class="hljs-number">0</span>, va)];<br>&#125;<br>简化版即为<br><span class="hljs-function"><span class="hljs-type">pte_t</span> *<span class="hljs-title">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[<span class="hljs-built_in">PX</span>(level, va)];  <span class="hljs-comment">// 得到相应页表表项</span><br>    <span class="hljs-keyword">if</span> (*pte &amp; PTE_V) &#123;<br>      pagetable = (<span class="hljs-type">pagetable_t</span>)<span class="hljs-built_in">PTE2PA</span>(*pte); <span class="hljs-comment">// 将表项转换成物理页地址</span><br>    &#125; <br>  &#125;<br>  <span class="hljs-keyword">return</span> &amp;pagetable[<span class="hljs-built_in">PX</span>(<span class="hljs-number">0</span>, va)];		<span class="hljs-comment">// 返回0级页表的表项指针</span><br>&#125;<br><br><span class="hljs-comment">// extract the three 9-bit page table indices from a virtual address.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXMASK          0x1FF <span class="hljs-comment">// 9 bits			// 页表索引掩码</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))	<span class="hljs-comment">// 页表索引的位置</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)  <span class="hljs-comment">// 取出相应页表的索引并将其移动到低位</span></span><br><br><span class="hljs-comment">// shift a physical address to the right place for a PTE.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)	<span class="hljs-comment">// 首先去除10位标志位，而后右移12位（页起始地址偏移量为0）</span></span><br><br><br><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to</span><br><span class="hljs-comment">// physical addresses starting at pa. va and size might not</span><br><span class="hljs-comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span><br><span class="hljs-comment">// allocate a needed page-table page.</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">int</span> perm)</span> </span>&#123;<br>  uint64 a, last;<br>  <span class="hljs-type">pte_t</span> *pte;<br><br>  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;mappages: size&quot;</span>);<br><br>  a = <span class="hljs-built_in">PGROUNDDOWN</span>(va);<br>  last = <span class="hljs-built_in">PGROUNDDOWN</span>(va + size - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-keyword">if</span> ((pte = <span class="hljs-built_in">walk</span>(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (*pte &amp; PTE_V) <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;mappages: remap&quot;</span>);<br>    *pte = <span class="hljs-built_in">PA2PTE</span>(pa) | perm | PTE_V;<br>    <span class="hljs-keyword">if</span> (a == last) <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>简化后即为<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">int</span> perm)</span> </span>&#123;<br>  uint64 a, last;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <br>  a = <span class="hljs-built_in">PGROUNDDOWN</span>(va);	<span class="hljs-comment">// 起始页</span><br>  last = <span class="hljs-built_in">PGROUNDDOWN</span>(va + size - <span class="hljs-number">1</span>); <span class="hljs-comment">// 结束页</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;	<span class="hljs-comment">// 映射是以页的粒度</span><br>  	pte = <span class="hljs-built_in">walk</span>(pagetable, a, <span class="hljs-number">1</span>); 	   <span class="hljs-comment">// 得到虚拟地址的页表表项指针</span><br>    *pte = <span class="hljs-built_in">PA2PTE</span>(pa) | perm | PTE_V;  <span class="hljs-comment">// 将该表项设为pa物理地址，建立映射关系，并设置标志位</span><br>    <span class="hljs-keyword">if</span> (a == last) <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) <span class="hljs-comment">// 将低12位置为0，即对页大小取整</span></span><br></code></pre></td></tr></table></figure><p>正式进行实验，Speed up system calls 和 Print a page table是很久之前写的，不太记得了，如有遗漏的地方，望请告知！</p><h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><blockquote><p>When each process is created, map one read-only page at USYSCALL (a VA defined in memlayout.h). At the start of this page, store a struct usyscall (also defined in memlayout.h), and initialize it to store the PID of the current process. For this lab, ugetpid() has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the ugetpid test case passes when running pgtbltest.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">ugetpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">u</span> =</span> (<span class="hljs-keyword">struct</span> usyscall *)USYSCALL;<br>  <span class="hljs-keyword">return</span> u-&gt;pid;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span><br><br><span class="hljs-comment">// usyscall的实现对标trapframe，创建，注销的方法都与trapframe相似</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span>  <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span>* <span class="hljs-title">usyscall</span>;</span>	<span class="hljs-comment">// 增加usyscall成员</span><br>&#125;;<br><span class="hljs-comment">// 比较对称的四个函数allocproc proc_pagetable freeproc proc_freepagetable</span><br><span class="hljs-comment">// Look in the process table for an UNUSED proc.</span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,</span><br><span class="hljs-comment">// and return with p-&gt;lock held.</span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc *<span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span> (p-&gt;state == UNUSED) &#123;<br>      <span class="hljs-keyword">goto</span> found;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>found:<br>  p-&gt;pid = allocpid();<br>  p-&gt;state = USED;<br><br>  <span class="hljs-comment">// Allocate a trapframe page.</span><br>  <span class="hljs-keyword">if</span> ((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>) &#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>	<br>  <span class="hljs-comment">// Allocate a usyscall page. </span><br>  <span class="hljs-keyword">if</span> ((p-&gt;usyscall = (<span class="hljs-keyword">struct</span> usyscall *)kalloc()) == <span class="hljs-number">0</span>) &#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);<br>  <span class="hljs-keyword">if</span> (p-&gt;pagetable == <span class="hljs-number">0</span>) &#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br>  <span class="hljs-comment">// which returns to user space.</span><br>  <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>  p-&gt;context.ra = (uint64)forkret;<br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;<br><br>  <span class="hljs-comment">// init usyscall page</span><br>  p-&gt;usyscall-&gt;pid = p-&gt;pid;<br><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// Create a user page table for a given process,</span><br><span class="hljs-comment">// with no user memory, but with trampoline pages.</span><br><span class="hljs-type">pagetable_t</span> <span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span> &#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span> (pagetable == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.</span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>  <span class="hljs-keyword">if</span> (mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline,<br>               PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>) &#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span><br>  <span class="hljs-keyword">if</span> (mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p-&gt;trapframe),<br>               PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>) &#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map one read-only page at USYSCALL</span><br>  <span class="hljs-keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall),<br>               PTE_R | PTE_U) &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// PTE_R | PTE_U 用户可以访问，可以读</span><br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);	<span class="hljs-comment">// 取消之前的映射，这次映射未成功，不用取消</span><br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br><span class="hljs-comment">// free a proc structure and the data hanging from it,</span><br><span class="hljs-comment">// including user pages.</span><br><span class="hljs-comment">// p-&gt;lock must be held.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span> &#123;<br>  <span class="hljs-keyword">if</span> (p-&gt;trapframe) kfree((<span class="hljs-type">void</span> *)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br><br>  kfree((<span class="hljs-type">void</span> *)p-&gt;usyscall);<br>  p-&gt;usyscall = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (p-&gt;pagetable) proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  p-&gt;sz = <span class="hljs-number">0</span>;<br>  p-&gt;pid = <span class="hljs-number">0</span>;<br>  p-&gt;parent = <span class="hljs-number">0</span>;<br>  p-&gt;name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  p-&gt;chan = <span class="hljs-number">0</span>;<br>  p-&gt;killed = <span class="hljs-number">0</span>;<br>  p-&gt;xstate = <span class="hljs-number">0</span>;<br>  p-&gt;state = UNUSED;<br>&#125;<br><br><span class="hljs-comment">// Free a process&#x27;s page table, and free the</span><br><span class="hljs-comment">// physical memory it refers to.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">proc_freepagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;<br>  uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmfree(pagetable, sz);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><blockquote><p>Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable) in exec.c just before the return argc, to print the first process’s page table. You receive full credit for this part of the lab if you pass the pte printout test of make grade.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// defs.h</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span>;<br><span class="hljs-comment">// vm.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint_impl</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">int</span> level)</span><br>&#123;<br>    <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)<br>    &#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-type">pagetable_t</span> next_pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(pte);<br>        <span class="hljs-keyword">if</span> (pte &amp; PTE_V) <span class="hljs-comment">// 该页有效</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &gt;= level; j--)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; ..&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, next_pagetable); <span class="hljs-comment">// %p pointer 以十六进制整数方式输出指针的值</span><br>            <span class="hljs-keyword">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 表示该表项指示的页存储着页表</span><br>            &#123;<br>                vmprint_impl(next_pagetable, level - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>    vmprint_impl(pagetable, <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">//exec()</span><br><span class="hljs-comment">// print pid==1 info</span><br><span class="hljs-keyword">if</span> (p-&gt;pid == <span class="hljs-number">1</span>) vmprint(p-&gt;pagetable);<br><span class="hljs-keyword">return</span> argc;  <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)</span><br></code></pre></td></tr></table></figure><p>其中pte &amp; (PTE_R | PTE_W | PTE_X)) &#x3D;&#x3D; 0让我挺疑惑的，为什么读写执行标志位全为0下一项就是页表呢。<br><img src="https://img-blog.csdnimg.cn/116cb2abf3334cac99c2f0098a3e3d83.png" srcset="/img/loading.gif" lazyload><br>在<a target="_blank" rel="noopener" href="https://1790865014.gitbook.io/ucore-step-by-step/intro-3">lab2: 物理内存和页表</a>中我找到了上表。</p><p>重新看walk函数代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span> *<span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (va &gt;= MAXVA)<br>        panic(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--)<br>    &#123;<br>        <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<br>        <span class="hljs-keyword">if</span> (*pte &amp; PTE_V)<br>        &#123;<br>            pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(*pte);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (!alloc || (pagetable = (<span class="hljs-type">pde_t</span> *)kalloc()) == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>            *pte = PA2PTE(pagetable) | PTE_V;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">0</span>, va)];<br>&#125;<br><br>*pte = PA2PTE(pagetable) | PTE_V; <br><span class="hljs-comment">// 表示该表项只有PTE_V置位，这表示指向页表的表项的R W X标志位确实全为0</span><br></code></pre></td></tr></table></figure><h2 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h2><blockquote><p>Your job is to implement pgaccess(), a system call that reports which pages have been accessed. The system call takes three arguments. First, it takes the starting virtual address of the first user page to check. Second, it takes the number of pages to check. Finally, it takes a user address to a buffer to store the results into a bitmask (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). You will receive full credit for this part of the lab if the pgaccess test case passes when running pgtbltest.</p></blockquote><p>pgaccess系统调用的大部分代码已经写好了，只需要补全sys_pgaccess函数就可以。<br>系统调用路径为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pgtbltest.c</span><br><span class="hljs-keyword">if</span> (pgaccess(buf, <span class="hljs-number">32</span>, &amp;abits) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 调用pgaccess函数</span><br><br><span class="hljs-comment">// user.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">int</span> len, <span class="hljs-type">void</span> *mask)</span>; <span class="hljs-comment">// 函数声明</span><br><br><span class="hljs-comment">// syscall.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_pgaccess  30 <span class="hljs-comment">// 定义调用号</span></span><br><br><span class="hljs-comment">// usys.S</span><br>pgaccess:	<span class="hljs-comment">// 函数入口</span><br> li a7, SYS_pgaccess<br> ecall<br> ret<br><br><span class="hljs-comment">// syscall.c</span><br><span class="hljs-comment">// 定义pgaccess内核函数原型</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL</span><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL</span><br>	[SYS_pgaccess] sys_pgaccess,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// sysproc.c 函数实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>sys_pgaccess函数比较简单，分为获取参数，查询PTE_A标志位并写入临时缓冲区，写入用户缓冲区三个部分。<br>可以参照walkaddr函数使用walk函数，获取调用参数和写入用户地址的方法与上一个实验类似。<br><img src="https://img-blog.csdnimg.cn/265ecf255c5d4d5c96521065fa09e037.png" srcset="/img/loading.gif" lazyload><br>查看手册可知PTE_A标志位在第六位</p><p>参考代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// riscv.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_A (1L &lt;&lt; 6)</span><br><span class="hljs-comment">// sysproc.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_PGACCESS_PAGE_NUMBER 64		<span class="hljs-comment">// 最大查询页数</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// lab pgtbl: your code here.</span><br>    uint64 base;<br>    <span class="hljs-type">int</span> len;<br>    uint64 mask;<br>    <span class="hljs-comment">// 获取参数</span><br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;base) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">1</span>, &amp;len) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">2</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    len = len &gt; MAX_PGACCESS_PAGE_NUMBER ? MAX_PGACCESS_PAGE_NUMBER : len;<br>    uint64 tmp_buffer = <span class="hljs-number">0</span>; <span class="hljs-comment">// 临时缓冲区</span><br>    <span class="hljs-type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;<br>    <span class="hljs-type">pte_t</span> *pte;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        pte = walk(pagetable, base + PGSIZE * i, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 如果页表项存在且PTE_A标志位置位</span><br>        <span class="hljs-keyword">if</span> (pte != <span class="hljs-number">0</span> &amp;&amp; (*pte &amp; PTE_A) != <span class="hljs-number">0</span>)  <br>        &#123;<br>            tmp_buffer |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            *pte &amp;= ~PTE_A;   <span class="hljs-comment">// 清空标志位</span><br>        &#125;<br>    &#125;<br>    <br>    uint64 mask_size = (len - <span class="hljs-number">1</span>) / <span class="hljs-number">8</span> + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 写入用户空间的字节数，向上取整</span><br>    <span class="hljs-keyword">if</span> (copyout(pagetable, mask, (<span class="hljs-type">char</span> *)&amp;tmp_buffer, mask_size))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// defs.h</span><br><span class="hljs-type">pte_t</span> *<span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span>;<br></code></pre></td></tr></table></figure><p><strong>编译时报错</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kernel/sysproc.c:95:15: error: implicit declaration of <span class="hljs-keyword">function</span> ‘walk’ [-Werror=implicit-function-declaration]<br>   95 |         pte = walk(pagetable, base + PGSIZE * i, 0);<br>      |               ^~~~<br>kernel/sysproc.c:95:13: error: assignment to ‘pte_t *’ &#123;aka ‘long unsigned int *’&#125; from ‘int’ makes pointer from <span class="hljs-built_in">integer</span> without a cast [-Werror=int-conversion]<br>   95 |         pte = walk(pagetable, base + PGSIZE * i, 0);<br></code></pre></td></tr></table></figure><p>排查后发现没有walk函数声明，在defs.h添加walk函数声明<br><strong>usertests测试超时</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Timeout! (300.3s) <br>== Test   usertests: all tests == <br>  usertests: all tests: FAIL <br>    ...<br>         <span class="hljs-built_in">test</span> bigfile: OK<br>         <span class="hljs-built_in">test</span> dirfile: OK<br>         <span class="hljs-built_in">test</span> iref: OK<br>         <span class="hljs-built_in">test</span> forktest: OK<br>         <span class="hljs-built_in">test</span> bigdir: qemu-system-riscv64: terminating on signal 15 from pid 3652612 (make)<br>    MISSING <span class="hljs-string">&#x27;^ALL TESTS PASSED$&#x27;</span><br></code></pre></td></tr></table></figure><p>修改超时时间为1000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">@test(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;usertests&quot;</span>)<br>def <span class="hljs-title function_">test_usertests</span><span class="hljs-params">()</span>:<br>    r.<span class="hljs-title function_">run_qemu</span><span class="hljs-params">(shell_script([</span><br><span class="hljs-params">        <span class="hljs-string">&#x27;usertests&#x27;</span></span><br><span class="hljs-params">    ]), timeout=<span class="hljs-number">1000</span>)</span><br></code></pre></td></tr></table></figure><p>测试通过截图<br><img src="https://img-blog.csdnimg.cn/8bf7bc162d4e478fa92d3a6e9389f23d.png" srcset="/img/loading.gif" lazyload></p><h1 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h1><ul><li>在xv6书中，异常控制流的原因分为系统调用，设备中断，异常（故障），并将其统称为陷阱。</li><li>xv6在内核中处理所有陷阱，不会移交给用户空间代码</li><li>对于陷阱处理，分为三种情况，分别是用户空间陷阱，内核空间陷阱，定时器中断</li><li>用户空间陷阱处理流程大致为uservec-&gt;usertrap-&gt;usertrapret-&gt;userret，简要看一下这四个函数，大部分代码是关于陷入前保存现场和内核处理后还原现场，有比较详尽的注释。</li><li>内核空间陷阱处理流程大致为kernelvec-&gt;kerneltrap-&gt;kernelvec</li><li>trampoline page放置代码，trapframe page放置数据，这两页同时存在内核页表和进程页表中</li><li>系统调用：ecall指令陷入内核，执行uservec-&gt;usertrap-&gt;syscall,补全了之前分析的系统调用路径。</li><li>内核将物理地址直接映射成虚拟地址，故可以直接使用物理地址</li><li>Xv6对异常的响应相当简单：如果在用户空间中发生异常，内核直接杀死该进程。如果在内核发生了异常，则中止内核。</li><li>如果将内核空间映射到进程页表，陷入内核空间就不需要切换页表，也可以直接使用用户空间指针，这也是现行操作系统采取的方式，但xv6为简化问题，使用单独的内核页表映射内核空间。参见<a href="https://www.jiasun.top/blog/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html">内核页表学习记录</a></li></ul><p>用户参数与寄存器对应代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint64<br><span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><p>相关文章与书籍<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389626435">聊聊 ARM 与 RISC-V</a><br><a target="_blank" rel="noopener" href="https://gitee.com/xyr1020/books/blob/main/RISC-V-Reader-Chinese-v2p1.pdf">RISC-V手册（中科院翻译版）</a><br>只需要简单阅读即可，主要是看手册附录部分的指令列表<br><img src="https://img-blog.csdnimg.cn/ce88e215c54e4c65a1f99ae2f79d0fb0.png" srcset="/img/loading.gif" lazyload><br>在附录A RISC-V 指令列表查询指令详细信息<br>一些用到的指令如下<br><img src="https://img-blog.csdnimg.cn/a3bef00944db422298857f290ab14e8a.png" srcset="/img/loading.gif" lazyload><img src="https://img-blog.csdnimg.cn/186b2901fe1c4891b10b555d638d031c.png" srcset="/img/loading.gif" lazyload><img src="https://img-blog.csdnimg.cn/e3261ed5b16d4fc3a694c2c836c44958.png" srcset="/img/loading.gif" lazyload><img src="https://img-blog.csdnimg.cn/3f7ab315ed034ec5a7d00f94b8b86a14.png" srcset="/img/loading.gif" lazyload><img src="https://img-blog.csdnimg.cn/a3170bfa05e0424db962dc02d7153207.png" srcset="/img/loading.gif" lazyload><img src="https://img-blog.csdnimg.cn/a340b54f21024653bfa749f2f6e55271.png" srcset="/img/loading.gif" lazyload></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>   <span class="hljs-number">0</span>:	<span class="hljs-number">1141</span>                	addi	sp,sp,<span class="hljs-number">-16</span><br>   <span class="hljs-number">2</span>:	e422                	sd	s0,<span class="hljs-number">8</span>(sp)<br>   <span class="hljs-number">4</span>:	<span class="hljs-number">0800</span>                	addi	s0,sp,<span class="hljs-number">16</span>    <span class="hljs-comment">// 保存寄存器的值</span><br>  <span class="hljs-keyword">return</span> x+<span class="hljs-number">3</span>;<br>&#125;<br>   <span class="hljs-number">6</span>:	<span class="hljs-number">250</span>d                	addiw	a0,a0,<span class="hljs-number">3</span>     <span class="hljs-comment">// a0寄存器既存参数，又存返回值</span><br>   <span class="hljs-number">8</span>:	<span class="hljs-number">6422</span>                	ld	s0,<span class="hljs-number">8</span>(sp)<br>   a:	<span class="hljs-number">0141</span>                	addi	sp,sp,<span class="hljs-number">16</span>    <span class="hljs-comment">// 还原寄存器的值</span><br>   c:	<span class="hljs-number">8082</span>                	ret<br><br><span class="hljs-number">000000000000000</span>e &lt;f&gt;:<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>   e:	<span class="hljs-number">1141</span>                	addi	sp,sp,<span class="hljs-number">-16</span><br>  <span class="hljs-number">10</span>:	e422                	sd	s0,<span class="hljs-number">8</span>(sp)<br>  <span class="hljs-number">12</span>:	<span class="hljs-number">0800</span>                	addi	s0,sp,<span class="hljs-number">16</span><br>  <span class="hljs-keyword">return</span> g(x);<br>&#125;<br>  <span class="hljs-number">14</span>:	<span class="hljs-number">250</span>d                	addiw	a0,a0,<span class="hljs-number">3</span>     <span class="hljs-comment">// 编译器优化，进行了函数展开，即为x+3</span><br>  <span class="hljs-number">16</span>:	<span class="hljs-number">6422</span>                	ld	s0,<span class="hljs-number">8</span>(sp)<br>  <span class="hljs-number">18</span>:	<span class="hljs-number">0141</span>                	addi	sp,sp,<span class="hljs-number">16</span><br>  <span class="hljs-number">1</span>a:	<span class="hljs-number">8082</span>                	ret<br><br><span class="hljs-number">000000000000001</span>c &lt;main&gt;:<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-number">1</span>c:	<span class="hljs-number">1141</span>                	addi	sp,sp,<span class="hljs-number">-16</span><br>  <span class="hljs-number">1</span>e:	e406                	sd	ra,<span class="hljs-number">8</span>(sp)<br>  <span class="hljs-number">20</span>:	e022                	sd	s0,<span class="hljs-number">0</span>(sp)<br>  <span class="hljs-number">22</span>:	<span class="hljs-number">0800</span>                	addi	s0,sp,<span class="hljs-number">16</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, f(<span class="hljs-number">8</span>)+<span class="hljs-number">1</span>, <span class="hljs-number">13</span>);<br>  <span class="hljs-number">24</span>:	<span class="hljs-number">4635</span>                	li	a2,<span class="hljs-number">13</span><br>  <span class="hljs-number">26</span>:	<span class="hljs-number">45b</span>1                	li	a1,<span class="hljs-number">12</span>       <span class="hljs-comment">// 编译期间提前进行计算，8+3+1</span><br>  <span class="hljs-number">28</span>:	<span class="hljs-number">00000517</span>          	auipc	a0,<span class="hljs-number">0x0</span>   <br>  <span class="hljs-number">2</span>c:	<span class="hljs-number">7</span>c050513          	addi	a0,a0,<span class="hljs-number">1984</span> # <span class="hljs-number">7e8</span> &lt;<span class="hljs-built_in">malloc</span>+<span class="hljs-number">0xea</span>&gt;   <span class="hljs-comment">// 应该存储的是字符串&quot;%d %d\n&quot;的起始地址</span><br>  <span class="hljs-number">30</span>:	<span class="hljs-number">00000097</span>          	auipc	ra,<span class="hljs-number">0x0</span><br>  <span class="hljs-number">34</span>:	<span class="hljs-number">610080e7</span>          	jalr	<span class="hljs-number">1552</span>(ra) # <span class="hljs-number">640</span> &lt;<span class="hljs-built_in">printf</span>&gt;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-number">38</span>:	<span class="hljs-number">4501</span>                	li	a0,<span class="hljs-number">0</span><br>  <span class="hljs-number">3</span>a:	<span class="hljs-number">00000097</span>          	auipc	ra,<span class="hljs-number">0x0</span><br>  <span class="hljs-number">3</span>e:	<span class="hljs-number">27e080</span>e7          	jalr	<span class="hljs-number">638</span>(ra) # <span class="hljs-number">2b</span>8 &lt;<span class="hljs-built_in">exit</span>&gt;<br></code></pre></td></tr></table></figure><p>Q1：<br>可以看出a0存放第一个参数，a1存放第二个参数，a2存放第三个参数，与argraw函数对应关系类似</p><p>Q2：<br>都进行了函数展开，在addiw	a0,a0,3和li	a1,12语句位置调用函数</p><p>Q3：<br>printf函数位于0x640的位置</p><p>Q4：<br>ra寄存器存放返回地址，即为0x38</p><p>后面的问题懒得看</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><blockquote><p>Implement a backtrace() function in kernel&#x2F;printf.c. Insert a call to this function in sys_sleep, and then run bttest, which calls sys_sleep. Your output should be as follows:<br>backtrace:<br>0x0000000080002cda<br>0x0000000080002bb6<br>0x0000000080002898<br>After bttest exit qemu. In your terminal: the addresses may be slightly different but if you run addr2line -e kernel&#x2F;kernel (or riscv64-unknown-elf-addr2line -e kernel&#x2F;kernel) and cut-and-paste the above addresses as follows:<br>$ addr2line -e kernel&#x2F;kernel<br>0x0000000080002de2<br>0x0000000080002f4a<br>0x0000000080002bfc<br>Ctrl-D<br>You should see something like this:<br>kernel&#x2F;sysproc.c:74<br>kernel&#x2F;syscall.c:224<br>kernel&#x2F;trap.c:85</p></blockquote><p><img src="https://img-blog.csdnimg.cn/bc07c50ae28f42f286236139b0ff736e.png" srcset="/img/loading.gif" lazyload></p><p>Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.<br>这部分实验主要理清整数，地址，指针等类似概念，最好画一张示意图，便于理解。<br>参考代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// defs.h</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// riscv.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> uint64<br><span class="hljs-title function_">r_fp</span><span class="hljs-params">()</span><br>&#123;<br>  uint64 x;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mv %0, s0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (x) )</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">// printf.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<br>    uint64 *current_frame_pointer = (uint64 *)r_fp();                         <span class="hljs-comment">// 当前栈帧指针</span><br>    uint64 *top_pointer = (uint64 *)PGROUNDUP((uint64)current_frame_pointer); <span class="hljs-comment">// 页尾部</span><br>    uint64 return_address;<br>    <span class="hljs-keyword">for</span> (uint64 *fp = current_frame_pointer; fp &lt; top_pointer; fp = (uint64 *)(*(fp - <span class="hljs-number">2</span>)))<br>    &#123;<br>        return_address = *(fp - <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算函数返回地址</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, return_address);<br>    &#125;<br>&#125;<br><br>在sys_sleep函数插入backtrace<br>在panic函数插入backtrace（可选）<br></code></pre></td></tr></table></figure><p>-1 -2是因为类型为uint64指针，一次加减8，相对于整数运算的-8 -16。<br>可以直接使用整数变量而不用指针变量，只在取值时强制转换为指针，但我觉得那样不好看。</p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><blockquote><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p></blockquote><p>在这个部分我最主要错误的点是想在内核中执行用户空间的函数，而没有注意到epc（之前没认真看xv6 book），但让我奇怪的一点是handler作为一个函数指针竟然有时候是0（periodic()函数），奇怪，这个函数正好放在在0的位置吗？<br><img src="https://img-blog.csdnimg.cn/f7ade89e25754865b4025d2aae244895.png" srcset="/img/loading.gif" lazyload><br>没注意原来实验特地说明了这一点。。</p><blockquote><p>Note that the address of the user’s alarm function might be 0 (e.g., in user&#x2F;alarmtest.asm, periodic is at address 0).</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// alarmtest.asm</span><br><span class="hljs-number">0000000000000000</span> &lt;periodic&gt;:<br>&#125;<br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">periodic</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>依据系统调用路径编写sigalarm sigreturn系统调用<br>&#x3D;&#x3D;只展示相关代码&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用户空间调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">periodic</span><span class="hljs-params">()</span><br>&#123;<br>    count = count + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alarm!\n&quot;</span>);<br>    sigreturn();		<span class="hljs-comment">// sigreturn系统调用</span><br>&#125;<br><br><span class="hljs-comment">// tests whether the kernel calls</span><br><span class="hljs-comment">// the alarm handler even a single time.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test0</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test0 start\n&quot;</span>);<br>    count = <span class="hljs-number">0</span>;<br>    sigalarm(<span class="hljs-number">2</span>, periodic);	<span class="hljs-comment">// sigalarm系统调用</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span> * <span class="hljs-number">500000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">1000000</span>) == <span class="hljs-number">0</span>)<br>            write(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    sigalarm(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test0 passed\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\ntest0 failed: the kernel never called the alarm handler\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// user.h 系统调用函数声明</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> ticks, <span class="hljs-type">void</span> (*handler)())</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// usys.pl 函数入口点</span><br>entry(<span class="hljs-string">&quot;sigalarm&quot;</span>);<br>entry(<span class="hljs-string">&quot;sigreturn&quot;</span>);<br><br><span class="hljs-comment">// syscall.h 系统调用号</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_sigalarm  22</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_sigreturn  23</span><br><br><span class="hljs-comment">// usys.S 最终生成的汇编代码</span><br>.global sigalarm<br>sigalarm:<br> li a7, SYS_sigalarm<br> ecall<br> ret<br>.global sigreturn<br>sigreturn:<br> li a7, SYS_sigreturn<br> ecall<br> ret<br><br><span class="hljs-comment">// syscall.c 内核的系统调用处理函数</span><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_return</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br>[SYS_sigalarm]   sys_sigalarm,<br>[SYS_sigreturn ]   sys_return,<br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// sysproc.c 系统调用对应的处理函数</span><br>uint64 <span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>uint64 <span class="hljs-title function_">sys_return</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// Makefile 加入alarmtest对象</span><br>UPROGS=\<br>	$U/_cat\<br>	$U/_echo\<br>	$U/_forktest\<br>	$U/_grep\<br>	$U/_init\<br>	$U/_kill\<br>	$U/_ln\<br>	$U/_ls\<br>	$U/_mkdir\<br>	$U/_rm\<br>	$U/_sh\<br>	$U/_stressfs\<br>	$U/_usertests\<br>	$U/_grind\<br>	$U/_wc\<br>	$U/_zombie\<br>	$U/_alarmtest\<br></code></pre></td></tr></table></figure><p>首先获取ticks和handler参数是必要的，test0只需要将在特定时机将handler赋值给epc即可，test1需要保存执行handler前的进程现场，handler结束后还原现场，test2需保证在执行handler时不会再次触发alarm。<br>其大致实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> alarm_call_exist;                   <span class="hljs-comment">// 是否存在alarm调用</span><br>    <span class="hljs-type">int</span> allow_trigger_alarm;                <span class="hljs-comment">// 是否允许触发alarm调用，如果现在正在处理handler函数，不能再次触发</span><br>    <span class="hljs-type">int</span> time_interval;                      <span class="hljs-comment">// alarm间隔</span><br>    uint64 handler_fn;                      <span class="hljs-comment">// alarm调用函数</span><br>    <span class="hljs-type">int</span> elapsed_time;                       <span class="hljs-comment">// 自上次调用起经历时间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> <span class="hljs-title">alarm_saved_trapframe</span>;</span> <span class="hljs-comment">// alarm调用前的trapframe</span><br>&#125;;<br><br><span class="hljs-comment">// proc.c</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc *<span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>found:<br>    p-&gt;alarm_call_exist = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置成不需要触发alarm</span><br>    p-&gt;allow_trigger_alarm = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// sysproc.c</span><br>uint64 <span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-type">int</span> ticks;<br>    uint64 handler;<br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;ticks) &lt; <span class="hljs-number">0</span>)	<span class="hljs-comment">// 获取参数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">1</span>, &amp;handler) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (ticks == <span class="hljs-number">0</span>)	<span class="hljs-comment">// 取消alarm调用</span><br>    &#123;<br>        p-&gt;alarm_call_exist = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tick %d handler %p\n&quot;</span>, ticks, handler);<br>    p-&gt;alarm_call_exist = <span class="hljs-number">1</span>; <span class="hljs-comment">// 将两个标志变量均设置为有效</span><br>    p-&gt;allow_trigger_alarm = <span class="hljs-number">1</span>;<br>    p-&gt;time_interval = ticks;<br>    p-&gt;handler_fn = handler;<br>    p-&gt;elapsed_time = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开启计时器</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>uint64 <span class="hljs-title function_">sys_return</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span> (p-&gt;alarm_call_exist == <span class="hljs-number">1</span>) <span class="hljs-comment">// 如果存在alarm调用</span><br>    &#123;<br>        *p-&gt;trapframe = p-&gt;alarm_saved_trapframe; <span class="hljs-comment">// 还原现场</span><br>        p-&gt;allow_trigger_alarm = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 允许触发alarm调用</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// trap.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>    <span class="hljs-keyword">if</span> (which_dev == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;alarm_call_exist == <span class="hljs-number">1</span> &amp;&amp; p-&gt;allow_trigger_alarm == <span class="hljs-number">1</span>)<br>        &#123;<br>            p-&gt;elapsed_time++;<br>            <span class="hljs-keyword">if</span> (p-&gt;elapsed_time &gt; p-&gt;time_interval) <span class="hljs-comment">// 大于规定间隔时间</span><br>            &#123;<br>                p-&gt;alarm_saved_trapframe = *p-&gt;trapframe; <span class="hljs-comment">// 保存此时进程状态</span><br>                p-&gt;trapframe-&gt;epc = p-&gt;handler_fn;        <span class="hljs-comment">// 返回地址设置为handler funtion</span><br>                p-&gt;allow_trigger_alarm = <span class="hljs-number">0</span>;               <span class="hljs-comment">// handler function返回前不再触发</span><br>                p-&gt;elapsed_time = <span class="hljs-number">0</span>;                      <span class="hljs-comment">// 重置计时器</span><br>            &#125;<br>        &#125;<br><br>        yield();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在代码中alarm调用指的是时钟中断时触发执行handler function的过程，而不是sigalarm系统调用，sigalarm系统调用更像是一个开启alarm触发机制的函数。当然这只是为了便于表述，实际上alarm调用只是时间中断的一个机制而已，并不是系统调用。</p><p>在之前我使用struct trapframe指针的形式存储alarm_saved_trapframe成员，并在allocproc函数中申请空间<br>类似于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((p-&gt;alarm_saved_trapframe= (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)<br>    &#123;<br>        freeproc(p);<br>        release(&amp;p-&gt;lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>但忘了在freeproc中释放空间，导致usertests没有通过，后以结构体存储，通过了全部测试，当然使用指针存储并在freeproc中释放应该也可以，但kalloc申请一页的空间，还是有些浪费的。</p><p>测试通过截图<br><img src="https://img-blog.csdnimg.cn/da1a496e5be748aba7be04d904b96236.png" srcset="/img/loading.gif" lazyload><br>参考博客：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/440454679">MIT 6.S081 Lab4: traps</a></p><h1 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy-on-Write"></a>Copy-on-Write</h1><p><a href="https://www.jiasun.top/blog/MIT6.S081%202021%20Copy-on-Write%20Fork%20for%20xv6.html">MIT6.S081 2021 Copy-on-Write Fork for xv6</a></p><h1 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h1><p><a href="https://www.jiasun.top/blog/MIT6.S081%20Multithreading.html">MIT6.S081 Multithreading</a></p><h1 id="networking"><a href="#networking" class="headerlink" title="networking"></a>networking</h1><p><a href="https://www.jiasun.top/blog/MIT6.S081%202021%20networking.html">MIT6.S081 2021 networking</a></p><h1 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h1><p><a href="https://www.jiasun.top/blog/MIT6.S081%202021%20locks.html">MIT6.S081 2021 locks</a></p><h1 id="file-system"><a href="#file-system" class="headerlink" title="file system"></a>file system</h1><p><a href="https://www.jiasun.top/blog/MIT6.S081%202021%20file%20system.html">MIT6.S081 2021 file system</a></p><h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h1><p><a href="https://www.jiasun.top/blog/MIT6.S081%202021%20mmap.html">MIT6.S081 2021 mmap</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%9B%BD%E5%A4%96%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/" class="category-chain-item">国外课程实验</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/MIT6-S081-file-system-traps-Copy-on-Write/" class="print-no-link">#MIT6.S081 file system traps Copy-on-Write</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/blog/%E5%9D%97%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95.html" title="块设备文件读取实验记录"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">块设备文件读取实验记录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/blog/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E6%8C%87%E5%8D%97%E9%87%8D%E5%86%99.html" title="王道考研机试指南重写"><span class="hidden-mobile">王道考研机试指南重写</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var e=Object.assign({appId:"uU0wegCOTLXqtIgWmhAD3MFq-gzGzoHsz",appKey:"0e2MMh7ddBCGGytOe9UEy5NP",path:"window.location.pathname",placeholder:null,avatar:"retro",meta:["nick","mail"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"https://uu0wegco.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(e),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var e="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(e),Fluid.plugins.fancyBox(e)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>